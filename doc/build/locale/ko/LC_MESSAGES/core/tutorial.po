# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: SQLAlchemy 1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-02-21 14:32+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../core/tutorial.rst:5
msgid "SQL Expression Language Tutorial"
msgstr ""

#: ../../core/tutorial.rst:7
msgid ""
"The SQLAlchemy Expression Language presents a system of representing "
"relational database structures and expressions using Python constructs. "
"These constructs are modeled to resemble those of the underlying database"
" as closely as possible, while providing a modicum of abstraction of the "
"various implementation differences between database backends. While the "
"constructs attempt to represent equivalent concepts between backends with"
" consistent structures, they do not conceal useful concepts that are "
"unique to particular subsets of backends. The Expression Language "
"therefore presents a method of writing backend-neutral SQL expressions, "
"but does not attempt to enforce that expressions are backend-neutral."
msgstr ""

#: ../../core/tutorial.rst:18
msgid ""
"The Expression Language is in contrast to the Object Relational Mapper, "
"which is a distinct API that builds on top of the Expression Language. "
"Whereas the ORM, introduced in :ref:`ormtutorial_toplevel`, presents a "
"high level and abstracted pattern of usage, which itself is an example of"
" applied usage of the Expression Language, the Expression Language "
"presents a system of representing the primitive constructs of the "
"relational database directly without opinion."
msgstr ""

#: ../../core/tutorial.rst:26
msgid ""
"While there is overlap among the usage patterns of the ORM and the "
"Expression Language, the similarities are more superficial than they may "
"at first appear. One approaches the structure and content of data from "
"the perspective of a user-defined `domain model "
"<http://en.wikipedia.org/wiki/Domain_model>`_ which is transparently "
"persisted and refreshed from its underlying storage model. The other "
"approaches it from the perspective of literal schema and SQL expression "
"representations which are explicitly composed into messages consumed "
"individually by the database."
msgstr ""

#: ../../core/tutorial.rst:36
msgid ""
"A successful application may be constructed using the Expression Language"
" exclusively, though the application will need to define its own system "
"of translating application concepts into individual database messages and"
" from individual database result sets. Alternatively, an application "
"constructed with the ORM may, in advanced scenarios, make occasional "
"usage of the Expression Language directly in certain areas where specific"
" database interactions are required."
msgstr ""

#: ../../core/tutorial.rst:44
msgid ""
"The following tutorial is in doctest format, meaning each ``>>>`` line "
"represents something you can type at a Python command prompt, and the "
"following text represents the expected return value. The tutorial has no "
"prerequisites."
msgstr ""

#: ../../core/tutorial.rst:50
msgid "Version Check"
msgstr ""

#: ../../core/tutorial.rst:53
msgid ""
"A quick check to verify that we are on at least **version 1.3** of "
"SQLAlchemy:"
msgstr ""

#: ../../core/tutorial.rst:62
msgid "Connecting"
msgstr ""

#: ../../core/tutorial.rst:64
msgid ""
"For this tutorial we will use an in-memory-only SQLite database. This is "
"an easy way to test things without needing to have an actual database "
"defined anywhere. To connect we use :func:`~sqlalchemy.create_engine`:"
msgstr ""

#: ../../core/tutorial.rst:73
msgid ""
"The ``echo`` flag is a shortcut to setting up SQLAlchemy logging, which "
"is accomplished via Python's standard ``logging`` module. With it "
"enabled, we'll see all the generated SQL produced. If you are working "
"through this tutorial and want less output generated, set it to "
"``False``. This tutorial will format the SQL behind a popup window so it "
"doesn't get in our way; just click the \"SQL\" links to see what's being "
"generated."
msgstr ""

#: ../../core/tutorial.rst:80
msgid ""
"The return value of :func:`.create_engine` is an instance of "
":class:`.Engine`, and it represents the core interface to the database, "
"adapted through a :term:`dialect` that handles the details of the "
"database and :term:`DBAPI` in use.  In this case the SQLite dialect will "
"interpret instructions to the Python built-in ``sqlite3`` module."
msgstr ""

msgid "Lazy Connecting"
msgstr ""

#: ../../core/tutorial.rst:89
msgid ""
"The :class:`.Engine`, when first returned by :func:`.create_engine`, has "
"not actually tried to connect to the database yet; that happens only the "
"first time it is asked to perform a task against the database."
msgstr ""

#: ../../core/tutorial.rst:93
msgid ""
"The first time a method like :meth:`.Engine.execute` or "
":meth:`.Engine.connect` is called, the :class:`.Engine` establishes a "
"real :term:`DBAPI` connection to the database, which is then used to emit"
" the SQL."
msgstr ""

#: ../../core/tutorial.rst:99
msgid ""
":ref:`database_urls` - includes examples of :func:`.create_engine` "
"connecting to several kinds of databases with links to more information."
msgstr ""

#: ../../core/tutorial.rst:103
msgid "Define and Create Tables"
msgstr ""

#: ../../core/tutorial.rst:105
msgid ""
"The SQL Expression Language constructs its expressions in most cases "
"against table columns. In SQLAlchemy, a column is most often represented "
"by an object called :class:`~sqlalchemy.schema.Column`, and in all cases "
"a :class:`~sqlalchemy.schema.Column` is associated with a "
":class:`~sqlalchemy.schema.Table`. A collection of "
":class:`~sqlalchemy.schema.Table` objects and their associated child "
"objects is referred to as **database metadata**. In this tutorial we will"
" explicitly lay out several :class:`~sqlalchemy.schema.Table` objects, "
"but note that SA can also \"import\" whole sets of "
":class:`~sqlalchemy.schema.Table` objects automatically from an existing "
"database (this process is called **table reflection**)."
msgstr ""

#: ../../core/tutorial.rst:117
msgid ""
"We define our tables all within a catalog called "
":class:`~sqlalchemy.schema.MetaData`, using the "
":class:`~sqlalchemy.schema.Table` construct, which resembles regular SQL "
"CREATE TABLE statements. We'll make two tables, one of which represents "
"\"users\" in an application, and another which represents zero or more "
"\"email addresses\" for each row in the \"users\" table:"
msgstr ""

#: ../../core/tutorial.rst:140
msgid ""
"All about how to define :class:`~sqlalchemy.schema.Table` objects, as "
"well as how to create them from an existing database automatically, is "
"described in :ref:`metadata_toplevel`."
msgstr ""

#: ../../core/tutorial.rst:144
msgid ""
"Next, to tell the :class:`~sqlalchemy.schema.MetaData` we'd actually like"
" to create our selection of tables for real inside the SQLite database, "
"we use :func:`~sqlalchemy.schema.MetaData.create_all`, passing it the "
"``engine`` instance which points to our database. This will check for the"
" presence of each table first before creating, so it's safe to call "
"multiple times:"
msgstr ""

#: ../../core/tutorial.rst:174
msgid ""
"Users familiar with the syntax of CREATE TABLE may notice that the "
"VARCHAR columns were generated without a length; on SQLite and "
"PostgreSQL, this is a valid datatype, but on others, it's not allowed. So"
" if running this tutorial on one of those databases, and you wish to use "
"SQLAlchemy to issue CREATE TABLE, a \"length\" may be provided to the "
":class:`~sqlalchemy.types.String` type as below::"
msgstr ""

#: ../../core/tutorial.rst:183
msgid ""
"The length field on :class:`~sqlalchemy.types.String`, as well as similar"
" precision/scale fields available on :class:`~sqlalchemy.types.Integer`, "
":class:`~sqlalchemy.types.Numeric`, etc. are not referenced by SQLAlchemy"
" other than when creating tables."
msgstr ""

#: ../../core/tutorial.rst:187
msgid ""
"Additionally, Firebird and Oracle require sequences to generate new "
"primary key identifiers, and SQLAlchemy doesn't generate or assume these "
"without being instructed. For that, you use the "
":class:`~sqlalchemy.schema.Sequence` construct::"
msgstr ""

#: ../../core/tutorial.rst:194
msgid "A full, foolproof :class:`~sqlalchemy.schema.Table` is therefore::"
msgstr ""

#: ../../core/tutorial.rst:203
msgid ""
"We include this more verbose :class:`~.schema.Table` construct separately"
" to highlight the difference between a minimal construct geared primarily"
" towards in-Python usage only, versus one that will be used to emit "
"CREATE TABLE statements on a particular set of backends with more "
"stringent requirements."
msgstr ""

#: ../../core/tutorial.rst:212
msgid "Insert Expressions"
msgstr ""

#: ../../core/tutorial.rst:214
msgid ""
"The first SQL expression we'll create is the "
":class:`~sqlalchemy.sql.expression.Insert` construct, which represents an"
" INSERT statement. This is typically created relative to its target "
"table::"
msgstr ""

#: ../../core/tutorial.rst:220
msgid ""
"To see a sample of the SQL this construct produces, use the ``str()`` "
"function::"
msgstr ""

#: ../../core/tutorial.rst:226
msgid ""
"Notice above that the INSERT statement names every column in the "
"``users`` table. This can be limited by using the ``values()`` method, "
"which establishes the VALUES clause of the INSERT explicitly::"
msgstr ""

#: ../../core/tutorial.rst:234
msgid ""
"Above, while the ``values`` method limited the VALUES clause to just two "
"columns, the actual data we placed in ``values`` didn't get rendered into"
" the string; instead we got named bind parameters. As it turns out, our "
"data *is* stored within our :class:`~sqlalchemy.sql.expression.Insert` "
"construct, but it typically only comes out when the statement is actually"
" executed; since the data consists of literal values, SQLAlchemy "
"automatically generates bind parameters for them. We can peek at this "
"data for now by looking at the compiled form of the statement::"
msgstr ""

#: ../../core/tutorial.rst:247
msgid "Executing"
msgstr ""

#: ../../core/tutorial.rst:249
msgid ""
"The interesting part of an :class:`~sqlalchemy.sql.expression.Insert` is "
"executing it. In this tutorial, we will generally focus on the most "
"explicit method of executing a SQL construct, and later touch upon some "
"\"shortcut\" ways to do it. The ``engine`` object we created is a "
"repository for database connections capable of issuing SQL to the "
"database. To acquire a connection, we use the ``connect()`` method::"
msgstr ""

#: ../../core/tutorial.rst:260
msgid ""
"The :class:`~sqlalchemy.engine.Connection` object represents an actively "
"checked out DBAPI connection resource. Lets feed it our "
":class:`~sqlalchemy.sql.expression.Insert` object and see what happens:"
msgstr ""

#: ../../core/tutorial.rst:271
msgid ""
"So the INSERT statement was now issued to the database. Although we got "
"positional \"qmark\" bind parameters instead of \"named\" bind parameters"
" in the output. How come ? Because when executed, the "
":class:`~sqlalchemy.engine.Connection` used the SQLite **dialect** to "
"help generate the statement; when we use the ``str()`` function, the "
"statement isn't aware of this dialect, and falls back onto a default "
"which uses named parameters. We can view this manually as follows:"
msgstr ""

#: ../../core/tutorial.rst:285
msgid ""
"What about the ``result`` variable we got when we called ``execute()`` ? "
"As the SQLAlchemy :class:`~sqlalchemy.engine.Connection` object "
"references a DBAPI connection, the result, known as a "
":class:`~sqlalchemy.engine.ResultProxy` object, is analogous to the DBAPI"
" cursor object. In the case of an INSERT, we can get important "
"information from it, such as the primary key values which were generated "
"from our statement using :attr:`.ResultProxy.inserted_primary_key`:"
msgstr ""

#: ../../core/tutorial.rst:298
msgid ""
"The value of ``1`` was automatically generated by SQLite, but only "
"because we did not specify the ``id`` column in our "
":class:`~sqlalchemy.sql.expression.Insert` statement; otherwise, our "
"explicit value would have been used. In either case, SQLAlchemy always "
"knows how to get at a newly generated primary key value, even though the "
"method of generating them is different across different databases; each "
"database's :class:`~sqlalchemy.engine.interfaces.Dialect` knows the "
"specific steps needed to determine the correct value (or values; note "
"that :attr:`.ResultProxy.inserted_primary_key` returns a list so that it "
"supports composite primary keys).    Methods here range from using "
"``cursor.lastrowid``, to selecting from a database-specific function, to "
"using ``INSERT..RETURNING`` syntax; this all occurs transparently."
msgstr ""

#: ../../core/tutorial.rst:314
msgid "Executing Multiple Statements"
msgstr ""

#: ../../core/tutorial.rst:316
msgid ""
"Our insert example above was intentionally a little drawn out to show "
"some various behaviors of expression language constructs. In the usual "
"case, an :class:`~sqlalchemy.sql.expression.Insert` statement is usually "
"compiled against the parameters sent to the ``execute()`` method on "
":class:`~sqlalchemy.engine.Connection`, so that there's no need to use "
"the ``values`` keyword with :class:`~sqlalchemy.sql.expression.Insert`. "
"Lets create a generic :class:`~sqlalchemy.sql.expression.Insert` "
"statement again and use it in the \"normal\" way:"
msgstr ""

#: ../../core/tutorial.rst:334
msgid ""
"Above, because we specified all three columns in the ``execute()`` "
"method, the compiled :class:`~.expression.Insert` included all three "
"columns. The :class:`~.expression.Insert` statement is compiled at "
"execution time based on the parameters we specified; if we specified "
"fewer parameters, the :class:`~.expression.Insert` would have fewer "
"entries in its VALUES clause."
msgstr ""

#: ../../core/tutorial.rst:341
msgid ""
"To issue many inserts using DBAPI's ``executemany()`` method, we can send"
" in a list of dictionaries each containing a distinct set of parameters "
"to be inserted, as we do here to add some email addresses:"
msgstr ""

#: ../../core/tutorial.rst:358
msgid ""
"Above, we again relied upon SQLite's automatic generation of primary key "
"identifiers for each ``addresses`` row."
msgstr ""

#: ../../core/tutorial.rst:361
msgid ""
"When executing multiple sets of parameters, each dictionary must have the"
" **same** set of keys; i.e. you cant have fewer keys in some dictionaries"
" than others. This is because the "
":class:`~sqlalchemy.sql.expression.Insert` statement is compiled against "
"the **first** dictionary in the list, and it's assumed that all "
"subsequent argument dictionaries are compatible with that statement."
msgstr ""

#: ../../core/tutorial.rst:368
msgid ""
"The \"executemany\" style of invocation is available for each of the "
":func:`.insert`, :func:`.update` and :func:`.delete` constructs."
msgstr ""

#: ../../core/tutorial.rst:375
msgid "Selecting"
msgstr ""

#: ../../core/tutorial.rst:377
msgid ""
"We began with inserts just so that our test database had some data in it."
" The more interesting part of the data is selecting it! We'll cover "
"UPDATE and DELETE statements later. The primary construct used to "
"generate SELECT statements is the :func:`.select` function:"
msgstr ""

#: ../../core/tutorial.rst:391
msgid ""
"Above, we issued a basic :func:`.select` call, placing the ``users`` "
"table within the COLUMNS clause of the select, and then executing. "
"SQLAlchemy expanded the ``users`` table into the set of each of its "
"columns, and also generated a FROM clause for us. The result returned is "
"again a :class:`~sqlalchemy.engine.ResultProxy` object, which acts much "
"like a DBAPI cursor, including methods such as "
":func:`~sqlalchemy.engine.ResultProxy.fetchone` and "
":func:`~sqlalchemy.engine.ResultProxy.fetchall`. The easiest way to get "
"rows from it is to just iterate:"
msgstr ""

#: ../../core/tutorial.rst:408
msgid ""
"Above, we see that printing each row produces a simple tuple-like result."
" We have more options at accessing the data in each row. One very common "
"way is through dictionary access, using the string names of columns:"
msgstr ""

#: ../../core/tutorial.rst:423
msgid "Integer indexes work as well:"
msgstr ""

#: ../../core/tutorial.rst:431
msgid ""
"But another way, whose usefulness will become apparent later on, is to "
"use the :class:`~sqlalchemy.schema.Column` objects directly as keys:"
msgstr ""

#: ../../core/tutorial.rst:444
msgid ""
"Result sets which have pending rows remaining should be explicitly closed"
" before discarding. While the cursor and connection resources referenced "
"by the :class:`~sqlalchemy.engine.ResultProxy` will be respectively "
"closed and returned to the connection pool when the object is garbage "
"collected, it's better to make it explicit as some database APIs are very"
" picky about such things:"
msgstr ""

#: ../../core/tutorial.rst:455
msgid ""
"If we'd like to more carefully control the columns which are placed in "
"the COLUMNS clause of the select, we reference individual "
":class:`~sqlalchemy.schema.Column` objects from our "
":class:`~sqlalchemy.schema.Table`. These are available as named "
"attributes off the ``c`` attribute of the "
":class:`~sqlalchemy.schema.Table` object:"
msgstr ""

#: ../../core/tutorial.rst:473
msgid ""
"Lets observe something interesting about the FROM clause. Whereas the "
"generated statement contains two distinct sections, a \"SELECT columns\" "
"part and a \"FROM table\" part, our :func:`.select` construct only has a "
"list containing columns. How does this work ? Let's try putting *two* "
"tables into our :func:`.select` statement:"
msgstr ""

#: ../../core/tutorial.rst:495
msgid ""
"It placed **both** tables into the FROM clause. But also, it made a real "
"mess. Those who are familiar with SQL joins know that this is a "
"**Cartesian product**; each row from the ``users`` table is produced "
"against each row from the ``addresses`` table. So to put some sanity into"
" this statement, we need a WHERE clause.  We do that using "
":meth:`.Select.where`:"
msgstr ""

#: ../../core/tutorial.rst:516
msgid ""
"So that looks a lot better, we added an expression to our :func:`.select`"
" which had the effect of adding ``WHERE users.id = addresses.user_id`` to"
" our statement, and our results were managed down so that the join of "
"``users`` and ``addresses`` rows made sense. But let's look at that "
"expression? It's using just a Python equality operator between two "
"different :class:`~sqlalchemy.schema.Column` objects. It should be clear "
"that something is up. Saying ``1 == 1`` produces ``True``, and ``1 == 2``"
" produces ``False``, not a WHERE clause. So lets see exactly what that "
"expression is doing:"
msgstr ""

#: ../../core/tutorial.rst:530
msgid ""
"Wow, surprise ! This is neither a ``True`` nor a ``False``. Well what is "
"it ?"
msgstr ""

#: ../../core/tutorial.rst:537
msgid ""
"As you can see, the ``==`` operator is producing an object that is very "
"much like the :class:`~.expression.Insert` and :func:`.select` objects "
"we've made so far, thanks to Python's ``__eq__()`` builtin; you call "
"``str()`` on it and it produces SQL. By now, one can see that everything "
"we are working with is ultimately the same type of object. SQLAlchemy "
"terms the base class of all of these expressions as "
":class:`~.expression.ColumnElement`."
msgstr ""

#: ../../core/tutorial.rst:545
msgid "Operators"
msgstr ""

#: ../../core/tutorial.rst:547
msgid ""
"Since we've stumbled upon SQLAlchemy's operator paradigm, let's go "
"through some of its capabilities. We've seen how to equate two columns to"
" each other:"
msgstr ""

#: ../../core/tutorial.rst:555
msgid ""
"If we use a literal value (a literal meaning, not a SQLAlchemy clause "
"object), we get a bind parameter:"
msgstr ""

#: ../../core/tutorial.rst:563
msgid ""
"The ``7`` literal is embedded the resulting "
":class:`~.expression.ColumnElement`; we can use the same trick we did "
"with the :class:`~sqlalchemy.sql.expression.Insert` object to see it:"
msgstr ""

#: ../../core/tutorial.rst:572
msgid ""
"Most Python operators, as it turns out, produce a SQL expression here, "
"like equals, not equals, etc.:"
msgstr ""

#: ../../core/tutorial.rst:588
msgid "If we add two integer columns together, we get an addition expression:"
msgstr ""

#: ../../core/tutorial.rst:595
msgid ""
"Interestingly, the type of the :class:`~sqlalchemy.schema.Column` is "
"important! If we use ``+`` with two string based columns (recall we put "
"types like :class:`~sqlalchemy.types.Integer` and "
":class:`~sqlalchemy.types.String` on our "
":class:`~sqlalchemy.schema.Column` objects at the beginning), we get "
"something different:"
msgstr ""

#: ../../core/tutorial.rst:606
msgid ""
"Where ``||`` is the string concatenation operator used on most databases."
" But not all of them. MySQL users, fear not:"
msgstr ""

#: ../../core/tutorial.rst:615
msgid ""
"The above illustrates the SQL that's generated for an "
":class:`~sqlalchemy.engine.Engine` that's connected to a MySQL database; "
"the ``||`` operator now compiles as MySQL's ``concat()`` function."
msgstr ""

#: ../../core/tutorial.rst:619
msgid ""
"If you have come across an operator which really isn't available, you can"
" always use the :meth:`.Operators.op` method; this generates whatever "
"operator you need:"
msgstr ""

#: ../../core/tutorial.rst:627
msgid ""
"This function can also be used to make bitwise operators explicit. For "
"example::"
msgstr ""

#: ../../core/tutorial.rst:631
msgid "is a bitwise AND of the value in ``somecolumn``."
msgstr ""

#: ../../core/tutorial.rst:633
msgid ""
"When using :meth:`.Operators.op`, the return type of the expression may "
"be important, especialy when the operator is used in an expression that "
"will be sent as a result column.   For this case, be sure to make the "
"type explicit, if not what's normally expected, using "
":func:`.type_coerce`::"
msgstr ""

#: ../../core/tutorial.rst:643
msgid ""
"For boolean operators, use the :meth:`.Operators.bool_op` method, which "
"will ensure that the return type of the expression is handled as "
"boolean::"
msgstr ""

#: ../../core/tutorial.rst:648
msgid "Added the :meth:`.Operators.bool_op` method."
msgstr ""

#: ../../core/tutorial.rst:651
msgid "Operator Customization"
msgstr ""

#: ../../core/tutorial.rst:653
msgid ""
"While :meth:`.Operators.op` is handy to get at a custom operator in a "
"hurry, the Core supports fundamental customization and extension of the "
"operator system at the type level.   The behavior of existing operators "
"can be modified on a per-type basis, and new operations can be defined "
"which become available for all column expressions that are part of that "
"particular type.  See the section :ref:`types_operators` for a "
"description."
msgstr ""

#: ../../core/tutorial.rst:663
msgid "Conjunctions"
msgstr ""

#: ../../core/tutorial.rst:666
msgid ""
"We'd like to show off some of our operators inside of :func:`.select` "
"constructs. But we need to lump them together a little more, so let's "
"first introduce some conjunctions. Conjunctions are those little words "
"like AND and OR that put things together. We'll also hit upon NOT. "
":func:`.and_`, :func:`.or_`, and :func:`.not_` can work from the "
"corresponding functions SQLAlchemy provides (notice we also throw in a "
":meth:`~.ColumnOperators.like`):"
msgstr ""

#: ../../core/tutorial.rst:692
msgid ""
"And you can also use the re-jiggered bitwise AND, OR and NOT operators, "
"although because of Python operator precedence you have to watch your "
"parenthesis:"
msgstr ""

#: ../../core/tutorial.rst:710
msgid ""
"So with all of this vocabulary, let's select all users who have an email "
"address at AOL or MSN, whose name starts with a letter between \"m\" and "
"\"z\", and we'll also generate a column containing their full name "
"combined with their email address. We will add two new constructs to this"
" statement, :meth:`~.ColumnOperators.between` and "
":meth:`~.ColumnElement.label`. :meth:`~.ColumnOperators.between` produces"
" a BETWEEN clause, and :meth:`~.ColumnElement.label` is used in a column "
"expression to produce labels using the ``AS`` keyword; it's recommended "
"when selecting from expressions that otherwise would not have a name:"
msgstr ""

#: ../../core/tutorial.rst:743
msgid ""
"Once again, SQLAlchemy figured out the FROM clause for our statement. In "
"fact it will determine the FROM clause based on all of its other bits; "
"the columns clause, the where clause, and also some other elements which "
"we haven't covered yet, which include ORDER BY, GROUP BY, and HAVING."
msgstr ""

#: ../../core/tutorial.rst:748
msgid ""
"A shortcut to using :func:`.and_` is to chain together multiple "
":meth:`~.Select.where` clauses.   The above can also be written as:"
msgstr ""

#: ../../core/tutorial.rst:772
msgid ""
"The way that we can build up a :func:`.select` construct through "
"successive method calls is called :term:`method chaining`."
msgstr ""

#: ../../core/tutorial.rst:778
msgid "Using Textual SQL"
msgstr ""

#: ../../core/tutorial.rst:780
msgid ""
"Our last example really became a handful to type. Going from what one "
"understands to be a textual SQL expression into a Python construct which "
"groups components together in a programmatic style can be hard. That's "
"why SQLAlchemy lets you just use strings, for those cases when the SQL is"
" already known and there isn't a strong need for the statement to support"
" dynamic features.  The :func:`~.expression.text` construct is used to "
"compose a textual statement that is passed to the database mostly "
"unchanged.  Below, we create a :func:`~.expression.text` object and "
"execute it:"
msgstr ""

#: ../../core/tutorial.rst:807
msgid ""
"Above, we can see that bound parameters are specified in "
":func:`~.expression.text` using the named colon format; this format is "
"consistent regardless of database backend.  To send values in for the "
"parameters, we passed them into the :meth:`~.Connection.execute` method "
"as additional arguments."
msgstr ""

#: ../../core/tutorial.rst:814
msgid "Specifying Bound Parameter Behaviors"
msgstr ""

#: ../../core/tutorial.rst:816
msgid ""
"The :func:`~.expression.text` construct supports pre-established bound "
"values using the :meth:`.TextClause.bindparams` method::"
msgstr ""

#: ../../core/tutorial.rst:822
msgid "The parameters can also be explicitly typed::"
msgstr ""

#: ../../core/tutorial.rst:827
msgid ""
"Typing for bound parameters is necessary when the type requires Python-"
"side or special SQL-side processing provided by the datatype."
msgstr ""

#: ../../core/tutorial.rst:832
msgid ":meth:`.TextClause.bindparams` - full method description"
msgstr ""

#: ../../core/tutorial.rst:837
msgid "Specifying Result-Column Behaviors"
msgstr ""

#: ../../core/tutorial.rst:839
msgid ""
"We may also specify information about the result columns using the "
":meth:`.TextClause.columns` method; this method can be used to specify "
"the return types, based on name::"
msgstr ""

#: ../../core/tutorial.rst:845
msgid ""
"or it can be passed full column expressions positionally, either typed or"
" untyped.  In this case it's a good idea to list out the columns "
"explicitly within our textual SQL, since the correlation of our column "
"expressions to the SQL will be done positionally::"
msgstr ""

#: ../../core/tutorial.rst:853
msgid ""
"When we call the :meth:`.TextClause.columns` method, we get back a "
":class:`.TextAsFrom` object that supports the full suite of "
":attr:`.TextAsFrom.c` and other \"selectable\" operations::"
msgstr ""

#: ../../core/tutorial.rst:862
msgid ""
"The positional form of :meth:`.TextClause.columns` is particularly useful"
" when relating textual SQL to existing Core or ORM models, because we can"
" use column expressions directly without worrying about name conflicts or"
" other issues with the result column names in the textual SQL:"
msgstr ""

#: ../../core/tutorial.rst:886
msgid ""
"Above, there's three columns in the result that are named \"id\", but "
"since we've associated these with column expressions positionally, the "
"names aren't an issue when the result-columns are fetched using the "
"actual column object as a key. Fetching the ``email_address`` column "
"would be::"
msgstr ""

#: ../../core/tutorial.rst:895
msgid ""
"If on the other hand we used a string column key, the usual rules of "
"name- based matching still apply, and we'd get an ambiguous column error "
"for the ``id`` value::"
msgstr ""

#: ../../core/tutorial.rst:904
msgid ""
"It's important to note that while accessing columns from a result set "
"using :class:`.Column` objects may seem unusual, it is in fact the only "
"system used by the ORM, which occurs transparently beneath the facade of "
"the :class:`~.orm.query.Query` object; in this way, the "
":meth:`.TextClause.columns` method is typically very applicable to "
"textual statements to be used in an ORM context.   The example at "
":ref:`orm_tutorial_literal_sql` illustrates a simple usage."
msgstr ""

#: ../../core/tutorial.rst:914
msgid ""
"The :meth:`.TextClause.columns` method now accepts column expressions "
"which will be matched positionally to a plain text SQL result set, "
"eliminating the need for column names to match or even be unique in the "
"SQL statement when matching table metadata or ORM models to textual SQL."
msgstr ""

#: ../../core/tutorial.rst:921
msgid ":meth:`.TextClause.columns` - full method description"
msgstr ""

#: ../../core/tutorial.rst:923
msgid ""
":ref:`orm_tutorial_literal_sql` - integrating ORM-level queries with "
":func:`.text`"
msgstr ""

#: ../../core/tutorial.rst:928
msgid "Using text() fragments inside bigger statements"
msgstr ""

#: ../../core/tutorial.rst:930
msgid ""
":func:`~.expression.text` can also be used to produce fragments of SQL "
"that can be freely within a :func:`~.expression.select` object, which "
"accepts :func:`~.expression.text` objects as an argument for most of its "
"builder functions. Below, we combine the usage of "
":func:`~.expression.text` within a :func:`.select` object.  The "
":func:`~.expression.select` construct provides the \"geometry\" of the "
"statement, and the :func:`~.expression.text` construct provides the "
"textual content within this form.  We can build a statement without the "
"need to refer to any pre-established :class:`.Table` metadata:"
msgstr ""

#: ../../core/tutorial.rst:962
msgid ""
"The :func:`.select` construct emits warnings when string SQL fragments "
"are coerced to :func:`.text`, and :func:`.text` should be used "
"explicitly.  See :ref:`migration_2992` for background."
msgstr ""

#: ../../core/tutorial.rst:972
msgid ""
"Using More Specific Text with :func:`.table`, :func:`.literal_column`, "
"and :func:`.column`"
msgstr ""

#: ../../core/tutorial.rst:974
msgid ""
"We can move our level of structure back in the other direction too, by "
"using :func:`~.expression.column`, :func:`~.expression.literal_column`, "
"and :func:`~.expression.table` for some of the key elements of our "
"statement.   Using these constructs, we can get some more expression "
"capabilities than if we used :func:`~.expression.text` directly, as they "
"provide to the Core more information about how the strings they store are"
" to be used, but still without the need to get into full :class:`.Table` "
"based metadata.  Below, we also specify the :class:`.String` datatype for"
" two of the key :func:`~.expression.literal_column` objects, so that the "
"string-specific concatenation operator becomes available. We also use "
":func:`~.expression.literal_column` in order to use table-qualified "
"expressions, e.g. ``users.fullname``, that will be rendered as is; using "
":func:`~.expression.column` implies an individual column name that may be"
" quoted:"
msgstr ""

#: ../../core/tutorial.rst:1018
msgid "Ordering or Grouping by a Label"
msgstr ""

#: ../../core/tutorial.rst:1020
msgid ""
"One place where we sometimes want to use a string as a shortcut is when "
"our statement has some labeled column element that we want to refer to in"
" a place such as the \"ORDER BY\" or \"GROUP BY\" clause; other "
"candidates include fields within an \"OVER\" or \"DISTINCT\" clause.  If "
"we have such a label in our :func:`.select` construct, we can refer to it"
" directly by passing the string straight into :meth:`.select.order_by` or"
" :meth:`.select.group_by`, among others.  This will refer to the named "
"label and also prevent the expression from being rendered twice.  Label "
"names that resolve to columns are rendered fully:"
msgstr ""

#: ../../core/tutorial.rst:1044
msgid ""
"We can use modifiers like :func:`.asc` or :func:`.desc` by passing the "
"string name:"
msgstr ""

#: ../../core/tutorial.rst:1061
msgid ""
"Note that the string feature here is very much tailored to when we have "
"already used the :meth:`~.ColumnElement.label` method to create a "
"specifically-named label.  In other cases, we always want to refer to the"
" :class:`.ColumnElement` object directly so that the expression system "
"can make the most effective choices for rendering.  Below, we illustrate "
"how using the :class:`.ColumnElement` eliminates ambiguity when we want "
"to order by a column name that appears more than once:"
msgstr ""

#: ../../core/tutorial.rst:1088
msgid "Using Aliases"
msgstr ""

#: ../../core/tutorial.rst:1090
msgid ""
"The alias in SQL corresponds to a \"renamed\" version of a table or "
"SELECT statement, which occurs anytime you say \"SELECT .. FROM sometable"
" AS someothername\". The ``AS`` creates a new name for the table. Aliases"
" are a key construct as they allow any table or subquery to be referenced"
" by a unique name. In the case of a table, this allows the same table to "
"be named in the FROM clause multiple times. In the case of a SELECT "
"statement, it provides a parent name for the columns represented by the "
"statement, allowing them to be referenced relative to this name."
msgstr ""

#: ../../core/tutorial.rst:1099
msgid ""
"In SQLAlchemy, any :class:`.Table`, :func:`.select` construct, or other "
"selectable can be turned into an alias using the "
":meth:`.FromClause.alias` method, which produces a :class:`.Alias` "
"construct.  As an example, suppose we know that our user ``jack`` has two"
" particular email addresses. How can we locate jack based on the "
"combination of those two addresses?   To accomplish this, we'd use a join"
" to the ``addresses`` table, once for each address.   We create two "
":class:`.Alias` constructs against ``addresses``, and then use them both "
"within a :func:`.select` construct:"
msgstr ""

#: ../../core/tutorial.rst:1128
msgid ""
"Note that the :class:`.Alias` construct generated the names "
"``addresses_1`` and ``addresses_2`` in the final SQL result.  The "
"generation of these names is determined by the position of the construct "
"within the statement.   If we created a query using only the second "
"``a2`` alias, the name would come out as ``addresses_1``.  The generation"
" of the names is also *deterministic*, meaning the same SQLAlchemy "
"statement construct will produce the identical SQL string each time it is"
" rendered for a particular dialect."
msgstr ""

#: ../../core/tutorial.rst:1136
msgid ""
"Since on the outside, we refer to the alias using the :class:`.Alias` "
"construct itself, we don't need to be concerned about the generated name."
"  However, for the purposes of debugging, it can be specified by passing "
"a string name to the :meth:`.FromClause.alias` method::"
msgstr ""

#: ../../core/tutorial.rst:1143
msgid ""
"Aliases can of course be used for anything which you can SELECT from, "
"including SELECT statements themselves. We can self-join the ``users`` "
"table back to the :func:`.select` we've created by making an alias of the"
" entire statement. The ``correlate(None)`` directive is to avoid "
"SQLAlchemy's attempt to \"correlate\" the inner ``users`` table with the "
"outer one:"
msgstr ""

#: ../../core/tutorial.rst:1166
msgid "Using Joins"
msgstr ""

#: ../../core/tutorial.rst:1168
msgid ""
"We're halfway along to being able to construct any SELECT expression. The"
" next cornerstone of the SELECT is the JOIN expression. We've already "
"been doing joins in our examples, by just placing two tables in either "
"the columns clause or the where clause of the :func:`.select` construct. "
"But if we want to make a real \"JOIN\" or \"OUTERJOIN\" construct, we use"
" the :meth:`~.FromClause.join` and :meth:`~.FromClause.outerjoin` "
"methods, most commonly accessed from the left table in the join:"
msgstr ""

#: ../../core/tutorial.rst:1181
msgid ""
"The alert reader will see more surprises; SQLAlchemy figured out how to "
"JOIN the two tables ! The ON condition of the join, as it's called, was "
"automatically generated based on the "
":class:`~sqlalchemy.schema.ForeignKey` object which we placed on the "
"``addresses`` table way at the beginning of this tutorial. Already the "
"``join()`` construct is looking like a much better way to join tables."
msgstr ""

#: ../../core/tutorial.rst:1188
msgid ""
"Of course you can join on whatever expression you want, such as if we "
"want to join on all users who use the same name in their email address as"
" their username:"
msgstr ""

#: ../../core/tutorial.rst:1200
msgid ""
"When we create a :func:`.select` construct, SQLAlchemy looks around at "
"the tables we've mentioned and then places them in the FROM clause of the"
" statement. When we use JOINs however, we know what FROM clause we want, "
"so here we make use of the :meth:`~.Select.select_from` method:"
msgstr ""

#: ../../core/tutorial.rst:1217
msgid ""
"The :meth:`~.FromClause.outerjoin` method creates ``LEFT OUTER JOIN`` "
"constructs, and is used in the same way as :meth:`~.FromClause.join`:"
msgstr ""

#: ../../core/tutorial.rst:1228
msgid ""
"That's the output ``outerjoin()`` produces, unless, of course, you're "
"stuck in a gig using Oracle prior to version 9, and you've set up your "
"engine (which would be using ``OracleDialect``) to use Oracle-specific "
"SQL:"
msgstr ""

#: ../../core/tutorial.rst:1240
msgid ""
"If you don't know what that SQL means, don't worry ! The secret tribe of "
"Oracle DBAs don't want their black magic being found out ;)."
msgstr ""

#: ../../core/tutorial.rst:1245
msgid ":func:`.expression.join`"
msgstr ""

#: ../../core/tutorial.rst:1247
msgid ":func:`.expression.outerjoin`"
msgstr ""

#: ../../core/tutorial.rst:1249
msgid ":class:`.Join`"
msgstr ""

#: ../../core/tutorial.rst:1252
msgid "Everything Else"
msgstr ""

#: ../../core/tutorial.rst:1254
msgid ""
"The concepts of creating SQL expressions have been introduced. What's "
"left are more variants of the same themes. So now we'll catalog the rest "
"of the important things we'll need to know."
msgstr ""

#: ../../core/tutorial.rst:1261
msgid "Bind Parameter Objects"
msgstr ""

#: ../../core/tutorial.rst:1263
msgid ""
"Throughout all these examples, SQLAlchemy is busy creating bind "
"parameters wherever literal expressions occur. You can also specify your "
"own bind parameters with your own names, and use the same statement "
"repeatedly. The :func:`.bindparam` construct is used to produce a bound "
"parameter with a given name.  While SQLAlchemy always refers to bound "
"parameters by name on the API side, the database dialect converts to the "
"appropriate named or positional style at execution time, as here where it"
" converts to positional for SQLite:"
msgstr ""

#: ../../core/tutorial.rst:1283
msgid ""
"Another important aspect of :func:`.bindparam` is that it may be assigned"
" a type. The type of the bind parameter will determine its behavior "
"within expressions and also how the data bound to it is processed before "
"being sent off to the database:"
msgstr ""

#: ../../core/tutorial.rst:1299
msgid ""
":func:`.bindparam` constructs of the same name can also be used multiple "
"times, where only a single named value is needed in the execute "
"parameters:"
msgstr ""

#: ../../core/tutorial.rst:1326
msgid ":func:`.bindparam`"
msgstr ""

#: ../../core/tutorial.rst:1329
msgid "Functions"
msgstr ""

#: ../../core/tutorial.rst:1331
msgid ""
"SQL functions are created using the :data:`~.expression.func` keyword, "
"which generates functions using attribute access:"
msgstr ""

#: ../../core/tutorial.rst:1343
msgid ""
"By \"generates\", we mean that **any** SQL function is created based on "
"the word you choose::"
msgstr ""

#: ../../core/tutorial.rst:1349
msgid ""
"Certain function names are known by SQLAlchemy, allowing special "
"behavioral rules to be applied. Some for example are \"ANSI\" functions, "
"which mean they don't get the parenthesis added after them, such as "
"CURRENT_TIMESTAMP:"
msgstr ""

#: ../../core/tutorial.rst:1358
msgid ""
"Functions are most typically used in the columns clause of a select "
"statement, and can also be labeled as well as given a type. Labeling a "
"function is recommended so that the result can be targeted in a result "
"row based on a string name, and assigning it a type is required when you "
"need result-set processing to occur, such as for Unicode conversion and "
"date conversions. Below, we use the result function ``scalar()`` to just "
"read the first column of the first row and then close the result; the "
"label, even though present, is not important in this case:"
msgstr ""

#: ../../core/tutorial.rst:1380
msgid ""
"Databases such as PostgreSQL and Oracle which support functions that "
"return whole result sets can be assembled into selectable units, which "
"can be used in statements. Such as, a database function ``calculate()`` "
"which takes the parameters ``x`` and ``y``, and returns three columns "
"which we'd like to name ``q``, ``z`` and ``r``, we can construct using "
"\"lexical\" column objects as well as bind parameters:"
msgstr ""

#: ../../core/tutorial.rst:1404
msgid ""
"If we wanted to use our ``calculate`` statement twice with different bind"
" parameters, the "
":func:`~sqlalchemy.sql.expression.ClauseElement.unique_params` function "
"will create copies for us, and mark the bind parameters as \"unique\" so "
"that conflicting names are isolated. Note we also make two separate "
"aliases of our selectable:"
msgstr ""

#: ../../core/tutorial.rst:1428
msgid ":data:`.func`"
msgstr ""

#: ../../core/tutorial.rst:1433
msgid "Window Functions"
msgstr ""

#: ../../core/tutorial.rst:1435
msgid ""
"Any :class:`.FunctionElement`, including functions generated by "
":data:`~.expression.func`, can be turned into a \"window function\", that"
" is an OVER clause, using the :meth:`.FunctionElement.over` method::"
msgstr ""

#: ../../core/tutorial.rst:1447
msgid ""
":meth:`.FunctionElement.over` also supports range specification using "
"either the :paramref:`.expression.over.rows` or "
":paramref:`.expression.over.range` parameters::"
msgstr ""

#: ../../core/tutorial.rst:1462
msgid ""
":paramref:`.expression.over.rows` and :paramref:`.expression.over.range` "
"each accept a two-tuple which contains a combination of negative and "
"positive integers for ranges, zero to indicate \"CURRENT ROW\" and "
"``None`` to indicate \"UNBOUNDED\".  See the examples at :func:`.over` "
"for more detail."
msgstr ""

#: ../../core/tutorial.rst:1467
msgid "support for \"rows\" and \"range\" specification for window functions"
msgstr ""

#: ../../core/tutorial.rst:1472
msgid ":func:`.over`"
msgstr ""

#: ../../core/tutorial.rst:1474
msgid ":meth:`.FunctionElement.over`"
msgstr ""

#: ../../core/tutorial.rst:1477
msgid "Unions and Other Set Operations"
msgstr ""

#: ../../core/tutorial.rst:1479
msgid ""
"Unions come in two flavors, UNION and UNION ALL, which are available via "
"module level functions :func:`~.expression.union` and "
":func:`~.expression.union_all`:"
msgstr ""

#: ../../core/tutorial.rst:1504
msgid ""
"Also available, though not supported on all databases, are "
":func:`~.expression.intersect`, :func:`~.expression.intersect_all`, "
":func:`~.expression.except_`, and :func:`~.expression.except_all`:"
msgstr ""

#: ../../core/tutorial.rst:1530
msgid ""
"A common issue with so-called \"compound\" selectables arises due to the "
"fact that they nest with parenthesis. SQLite in particular doesn't like a"
" statement that starts with parenthesis. So when nesting a \"compound\" "
"inside a \"compound\", it's often necessary to apply "
"``.alias().select()`` to the first element of the outermost compound, if "
"that element is also a compound. For example, to nest a \"union\" and a "
"\"select\" inside of \"except\\_\", SQLite will want the \"union\" to be "
"stated as a subquery:"
msgstr ""

#: ../../core/tutorial.rst:1570
msgid ":func:`.union`"
msgstr ""

#: ../../core/tutorial.rst:1572
msgid ":func:`.union_all`"
msgstr ""

#: ../../core/tutorial.rst:1574
msgid ":func:`.intersect`"
msgstr ""

#: ../../core/tutorial.rst:1576
msgid ":func:`.intersect_all`"
msgstr ""

#: ../../core/tutorial.rst:1578
msgid ":func:`.except_`"
msgstr ""

#: ../../core/tutorial.rst:1580
msgid ":func:`.except_all`"
msgstr ""

#: ../../core/tutorial.rst:1585
msgid "Scalar Selects"
msgstr ""

#: ../../core/tutorial.rst:1587
msgid ""
"A scalar select is a SELECT that returns exactly one row and one column."
"  It can then be used as a column expression.  A scalar select is often a"
" :term:`correlated subquery`, which relies upon the enclosing SELECT "
"statement in order to acquire at least one of its FROM clauses."
msgstr ""

#: ../../core/tutorial.rst:1592
msgid ""
"The :func:`.select` construct can be modified to act as a column "
"expression by calling either the :meth:`~.SelectBase.as_scalar` or "
":meth:`~.SelectBase.label` method:"
msgstr ""

#: ../../core/tutorial.rst:1602
msgid ""
"The above construct is now a :class:`~.expression.ScalarSelect` object, "
"and is no longer part of the :class:`~.expression.FromClause` hierarchy; "
"it instead is within the :class:`~.expression.ColumnElement` family of "
"expression constructs.  We can place this construct the same as any other"
" column within another :func:`.select`:"
msgstr ""

#: ../../core/tutorial.rst:1618
msgid ""
"To apply a non-anonymous column name to our scalar select, we create it "
"using :meth:`.SelectBase.label` instead:"
msgstr ""

#: ../../core/tutorial.rst:1636
msgid ":meth:`.Select.as_scalar`"
msgstr ""

#: ../../core/tutorial.rst:1638
msgid ":meth:`.Select.label`"
msgstr ""

#: ../../core/tutorial.rst:1643
msgid "Correlated Subqueries"
msgstr ""

#: ../../core/tutorial.rst:1645
msgid ""
"Notice in the examples on :ref:`scalar_selects`, the FROM clause of each "
"embedded select did not contain the ``users`` table in its FROM clause. "
"This is because SQLAlchemy automatically :term:`correlates` embedded FROM"
" objects to that of an enclosing query, if present, and if the inner "
"SELECT statement would still have at least one FROM clause of its own.  "
"For example:"
msgstr ""

#: ../../core/tutorial.rst:1667
msgid ""
"Auto-correlation will usually do what's expected, however it can also be "
"controlled. For example, if we wanted a statement to correlate only to "
"the ``addresses`` table but not the ``users`` table, even if both were "
"present in the enclosing SELECT, we use the :meth:`~.Select.correlate` "
"method to specify those FROM clauses that may be correlated:"
msgstr ""

#: ../../core/tutorial.rst:1692
msgid ""
"To entirely disable a statement from correlating, we can pass ``None`` as"
" the argument:"
msgstr ""

#: ../../core/tutorial.rst:1711
msgid ""
"We can also control correlation via exclusion, using the "
":meth:`.Select.correlate_except` method.   Such as, we can write our "
"SELECT for the ``users`` table by telling it to correlate all FROM "
"clauses except for ``users``:"
msgstr ""

#: ../../core/tutorial.rst:1737
msgid "LATERAL correlation"
msgstr ""

#: ../../core/tutorial.rst:1739
msgid ""
"LATERAL correlation is a special sub-category of SQL correlation which "
"allows a selectable unit to refer to another selectable unit within a "
"single FROM clause.  This is an extremely special use case which, while "
"part of the SQL standard, is only known to be supported by recent "
"versions of PostgreSQL."
msgstr ""

#: ../../core/tutorial.rst:1745
msgid ""
"Normally, if a SELECT statement refers to ``table1 JOIN (some SELECT) AS "
"subquery`` in its FROM clause, the subquery on the right side may not "
"refer to the \"table1\" expression from the left side; correlation may "
"only refer to a table that is part of another SELECT that entirely "
"encloses this SELECT.  The LATERAL keyword allows us to turn this "
"behavior around, allowing an expression such as:"
msgstr ""

#: ../../core/tutorial.rst:1759
msgid ""
"Where above, the right side of the JOIN contains a subquery that refers "
"not just to the \"books\" table but also the \"people\" table, "
"correlating to the left side of the JOIN.   SQLAlchemy Core supports a "
"statement like the above using the :meth:`.Select.lateral` method as "
"follows::"
msgstr ""

#: ../../core/tutorial.rst:1775
msgid ""
"Above, we can see that the :meth:`.Select.lateral` method acts a lot like"
" the :meth:`.Select.alias` method, including that we can specify an "
"optional name.  However the construct is the :class:`.Lateral` construct "
"instead of an :class:`.Alias` which provides for the LATERAL keyword as "
"well as special instructions to allow correlation from inside the FROM "
"clause of the enclosing statement."
msgstr ""

#: ../../core/tutorial.rst:1782
msgid ""
"The :meth:`.Select.lateral` method interacts normally with the "
":meth:`.Select.correlate` and :meth:`.Select.correlate_except` methods, "
"except that the correlation rules also apply to any other tables present "
"in the enclosing statement's FROM clause.   Correlation is \"automatic\" "
"to these tables by default, is explicit if the table is specified to "
":meth:`.Select.correlate`, and is explicit to all tables except those "
"specified to :meth:`.Select.correlate_except`."
msgstr ""

#: ../../core/tutorial.rst:1793
msgid "Support for the LATERAL keyword and lateral correlation."
msgstr ""

#: ../../core/tutorial.rst:1797
msgid ":class:`.Lateral`"
msgstr ""

#: ../../core/tutorial.rst:1799
msgid ":meth:`.Select.lateral`"
msgstr ""

#: ../../core/tutorial.rst:1803
msgid "Ordering, Grouping, Limiting, Offset...ing..."
msgstr ""

#: ../../core/tutorial.rst:1805
msgid ""
"Ordering is done by passing column expressions to the "
":meth:`~.SelectBase.order_by` method:"
msgstr ""

#: ../../core/tutorial.rst:1817
msgid ""
"Ascending or descending can be controlled using the "
":meth:`~.ColumnElement.asc` and :meth:`~.ColumnElement.desc` modifiers:"
msgstr ""

#: ../../core/tutorial.rst:1829
msgid ""
"Grouping refers to the GROUP BY clause, and is usually used in "
"conjunction with aggregate functions to establish groups of rows to be "
"aggregated. This is provided via the :meth:`~.SelectBase.group_by` "
"method:"
msgstr ""

#: ../../core/tutorial.rst:1846
msgid ""
"HAVING can be used to filter results on an aggregate value, after GROUP "
"BY has been applied.  It's available here via the :meth:`~.Select.having`"
" method:"
msgstr ""

#: ../../core/tutorial.rst:1865
msgid ""
"A common system of dealing with duplicates in composed SELECT statements "
"is the DISTINCT modifier.  A simple DISTINCT clause can be added using "
"the :meth:`.Select.distinct` method:"
msgstr ""

#: ../../core/tutorial.rst:1882
msgid ""
"Most database backends support a system of limiting how many rows are "
"returned, and the majority also feature a means of starting to return "
"rows after a given \"offset\".   While common backends like PostgreSQL, "
"MySQL and SQLite support LIMIT and OFFSET keywords, other backends need "
"to refer to more esoteric features such as \"window functions\" and row "
"ids to achieve the same effect.  The :meth:`~.Select.limit` and "
":meth:`~.Select.offset` methods provide an easy abstraction into the "
"current backend's methodology:"
msgstr ""

#: ../../core/tutorial.rst:1907
msgid "Inserts, Updates and Deletes"
msgstr ""

#: ../../core/tutorial.rst:1909
msgid ""
"We've seen :meth:`~.TableClause.insert` demonstrated earlier in this "
"tutorial.   Where :meth:`~.TableClause.insert` produces INSERT, the "
":meth:`~.TableClause.update` method produces UPDATE.  Both of these "
"constructs feature a method called :meth:`~.ValuesBase.values` which "
"specifies the VALUES or SET clause of the statement."
msgstr ""

#: ../../core/tutorial.rst:1916
msgid ""
"The :meth:`~.ValuesBase.values` method accommodates any column expression"
" as a value:"
msgstr ""

#: ../../core/tutorial.rst:1929
msgid ""
"When using :meth:`~.TableClause.insert` or :meth:`~.TableClause.update` "
"in an \"execute many\" context, we may also want to specify named bound "
"parameters which we can refer to in the argument list. The two constructs"
" will automatically generate bound placeholders for any column names "
"passed in the dictionaries sent to :meth:`~.Connection.execute` at "
"execution time.  However, if we wish to use explicitly targeted named "
"parameters with composed expressions, we need to use the "
":func:`~.expression.bindparam` construct. When using "
":func:`~.expression.bindparam` with :meth:`~.TableClause.insert` or "
":meth:`~.TableClause.update`, the names of the table's columns themselves"
" are reserved for the \"automatic\" generation of bind names.  We can "
"combine the usage of implicitly available bind names and explicitly named"
" parameters as in the example below:"
msgstr ""

#: ../../core/tutorial.rst:1958
msgid ""
"An UPDATE statement is emitted using the :meth:`~.TableClause.update` "
"construct.  This works much like an INSERT, except there is an additional"
" WHERE clause that can be specified:"
msgstr ""

#: ../../core/tutorial.rst:1974
msgid ""
"When using :meth:`~.TableClause.update` in an \"executemany\" context, we"
" may wish to also use explicitly named bound parameters in the WHERE "
"clause.  Again, :func:`~.expression.bindparam` is the construct used to "
"achieve this:"
msgstr ""

#: ../../core/tutorial.rst:1996
msgid "Correlated Updates"
msgstr ""

#: ../../core/tutorial.rst:1998
msgid ""
"A correlated update lets you update a table using selection from another "
"table, or the same table:"
msgstr ""

#: ../../core/tutorial.rst:2018
msgid "Multiple Table Updates"
msgstr ""

#: ../../core/tutorial.rst:2022
msgid ""
"The PostgreSQL, Microsoft SQL Server, and MySQL backends all support "
"UPDATE statements that refer to multiple tables.   For PG and MSSQL, this"
" is the \"UPDATE FROM\" syntax, which updates one table at a time, but "
"can reference additional tables in an additional \"FROM\" clause that can"
" then be referenced in the WHERE clause directly.   On MySQL, multiple "
"tables can be embedded into a single UPDATE statement separated by a "
"comma. The SQLAlchemy :func:`.update` construct supports both of these "
"modes implicitly, by specifying multiple tables in the WHERE clause::"
msgstr ""

#: ../../core/tutorial.rst:2036
msgid "The resulting SQL from the above statement would render as::"
msgstr ""

#: ../../core/tutorial.rst:2042
msgid ""
"When using MySQL, columns from each table can be assigned to in the SET "
"clause directly, using the dictionary form passed to "
":meth:`.Update.values`::"
msgstr ""

#: ../../core/tutorial.rst:2053
msgid "The tables are referenced explicitly in the SET clause::"
msgstr ""

#: ../../core/tutorial.rst:2059 ../../core/tutorial.rst:2164
msgid ""
"When the construct is used on a non-supporting database, the compiler "
"will raise ``NotImplementedError``.   For convenience, when a statement "
"is printed as a string without specification of a dialect, the \"string "
"SQL\" compiler will be invoked which provides a non-working SQL "
"representation of the construct."
msgstr ""

#: ../../core/tutorial.rst:2068
msgid "Parameter-Ordered Updates"
msgstr ""

#: ../../core/tutorial.rst:2070
msgid ""
"The default behavior of the :func:`.update` construct when rendering the "
"SET clauses is to render them using the column ordering given in the "
"originating :class:`.Table` object. This is an important behavior, since "
"it means that the rendering of a particular UPDATE statement with "
"particular columns will be rendered the same each time, which has an "
"impact on query caching systems that rely on the form of the statement, "
"either client side or server side. Since the parameters themselves are "
"passed to the :meth:`.Update.values` method as Python dictionary keys, "
"there is no other fixed ordering available."
msgstr ""

#: ../../core/tutorial.rst:2081
msgid ""
"However in some cases, the order of parameters rendered in the SET clause"
" of an UPDATE statement can be significant.  The main example of this is "
"when using MySQL and providing updates to column values based on that of "
"other column values.  The end result of the following statement::"
msgstr ""

#: ../../core/tutorial.rst:2088
msgid "Will have a different result than::"
msgstr ""

#: ../../core/tutorial.rst:2092
msgid ""
"This because on MySQL, the individual SET clauses are fully evaluated on "
"a per-value basis, as opposed to on a per-row basis, and as each SET "
"clause is evaluated, the values embedded in the row are changing."
msgstr ""

#: ../../core/tutorial.rst:2096
msgid ""
"To suit this specific use case, the "
":paramref:`~sqlalchemy.sql.expression.update.preserve_parameter_order` "
"flag may be used.  When using this flag, we supply a **Python list of "
"2-tuples** as the argument to the :meth:`.Update.values` method::"
msgstr ""

#: ../../core/tutorial.rst:2104
msgid ""
"The list of 2-tuples is essentially the same structure as a Python "
"dictionary except it is ordered.  Using the above form, we are assured "
"that the \"y\" column's SET clause will render first, then the \"x\" "
"column's SET clause."
msgstr ""

#: ../../core/tutorial.rst:2108
msgid ""
"Added support for explicit ordering of UPDATE parameters using the "
":paramref:`~sqlalchemy.sql.expression.update.preserve_parameter_order` "
"flag."
msgstr ""

#: ../../core/tutorial.rst:2114
msgid ""
":ref:`mysql_insert_on_duplicate_key_update` - background on the MySQL "
"``ON DUPLICATE KEY UPDATE`` clause and how to support parameter ordering."
msgstr ""

#: ../../core/tutorial.rst:2120
msgid "Deletes"
msgstr ""

#: ../../core/tutorial.rst:2122
msgid ""
"Finally, a delete.  This is accomplished easily enough using the "
":meth:`~.TableClause.delete` construct:"
msgstr ""

#: ../../core/tutorial.rst:2142
msgid "Multiple Table Deletes"
msgstr ""

#: ../../core/tutorial.rst:2146
msgid ""
"The PostgreSQL, Microsoft SQL Server, and MySQL backends all support "
"DELETE statements that refer to multiple tables within the WHERE "
"criteria.   For PG and MySQL, this is the \"DELETE USING\" syntax, and "
"for SQL Server, it's a \"DELETE FROM\" that refers to more than one "
"table.  The SQLAlchemy :func:`.delete` construct supports both of these "
"modes implicitly, by specifying multiple tables in the WHERE clause::"
msgstr ""

#: ../../core/tutorial.rst:2158
msgid ""
"On a Postgresql backend, the resulting SQL from the above statement would"
" render as::"
msgstr ""

#: ../../core/tutorial.rst:2171
msgid "Matched Row Counts"
msgstr ""

#: ../../core/tutorial.rst:2173
msgid ""
"Both of :meth:`~.TableClause.update` and :meth:`~.TableClause.delete` are"
" associated with *matched row counts*.  This is a number indicating the "
"number of rows that were matched by the WHERE clause. Note that by "
"\"matched\", this includes rows where no UPDATE actually took place. The "
"value is available as :attr:`~.ResultProxy.rowcount`:"
msgstr ""

#: ../../core/tutorial.rst:2189
msgid "Further Reference"
msgstr ""

#: ../../core/tutorial.rst:2191
msgid "Expression Language Reference: :ref:`expression_api_toplevel`"
msgstr ""

#: ../../core/tutorial.rst:2193
msgid "Database Metadata Reference: :ref:`metadata_toplevel`"
msgstr ""

#: ../../core/tutorial.rst:2195
msgid "Engine Reference: :doc:`/core/engines`"
msgstr ""

#: ../../core/tutorial.rst:2197
msgid "Connection Reference: :ref:`connections_toplevel`"
msgstr ""

#: ../../core/tutorial.rst:2199
msgid "Types Reference: :ref:`types_toplevel`"
msgstr ""

