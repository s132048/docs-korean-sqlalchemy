# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: SQLAlchemy 1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-02-21 14:32+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../core/connections.rst:5
msgid "Working with Engines and Connections"
msgstr ""

#: ../../core/connections.rst:9
msgid ""
"This section details direct usage of the :class:`.Engine`, "
":class:`.Connection`, and related objects. Its important to note that "
"when using the SQLAlchemy ORM, these objects are not generally accessed; "
"instead, the :class:`.Session` object is used as the interface to the "
"database. However, for applications that are built around direct usage of"
" textual SQL statements and/or SQL expression constructs without "
"involvement by the ORM's higher level management services, the "
":class:`.Engine` and :class:`.Connection` are king (and queen?) - read "
"on."
msgstr ""

#: ../../core/connections.rst:19
msgid "Basic Usage"
msgstr ""

#: ../../core/connections.rst:21
msgid ""
"Recall from :doc:`/core/engines` that an :class:`.Engine` is created via "
"the :func:`.create_engine` call::"
msgstr ""

#: ../../core/connections.rst:26
msgid ""
"The typical usage of :func:`.create_engine()` is once per particular "
"database URL, held globally for the lifetime of a single application "
"process. A single :class:`.Engine` manages many individual DBAPI "
"connections on behalf of the process and is intended to be called upon in"
" a concurrent fashion. The :class:`.Engine` is **not** synonymous to the "
"DBAPI ``connect`` function, which represents just one connection resource"
" - the :class:`.Engine` is most efficient when created just once at the "
"module level of an application, not per-object or per-function call."
msgstr ""

#: ../../core/connections.rst:35
msgid ""
"For a multiple-process application that uses the ``os.fork`` system call,"
" or for example the Python ``multiprocessing`` module, it's usually "
"required that a separate :class:`.Engine` be used for each child process."
" This is because the :class:`.Engine` maintains a reference to a "
"connection pool that ultimately references DBAPI connections - these tend"
" to not be portable across process boundaries. An :class:`.Engine` that "
"is configured not to use pooling (which is achieved via the usage of "
":class:`.NullPool`) does not have this requirement."
msgstr ""

#: ../../core/connections.rst:44
msgid ""
"The engine can be used directly to issue SQL to the database. The most "
"generic way is first procure a connection resource, which you get via the"
" :meth:`.Engine.connect` method::"
msgstr ""

#: ../../core/connections.rst:54
msgid ""
"The connection is an instance of :class:`.Connection`, which is a "
"**proxy** object for an actual DBAPI connection.  The DBAPI connection is"
" retrieved from the connection pool at the point at which "
":class:`.Connection` is created."
msgstr ""

#: ../../core/connections.rst:59
msgid ""
"The returned result is an instance of :class:`.ResultProxy`, which "
"references a DBAPI cursor and provides a largely compatible interface "
"with that of the DBAPI cursor.   The DBAPI cursor will be closed by the "
":class:`.ResultProxy` when all of its result rows (if any) are exhausted."
"  A :class:`.ResultProxy` that returns no rows, such as that of an UPDATE"
" statement (without any returned rows), releases cursor resources "
"immediately upon construction."
msgstr ""

#: ../../core/connections.rst:67
msgid ""
"When the :meth:`~.Connection.close` method is called, the referenced "
"DBAPI connection is :term:`released` to the connection pool.   From the "
"perspective of the database itself, nothing is actually \"closed\", "
"assuming pooling is in use.  The pooling mechanism issues a "
"``rollback()`` call on the DBAPI connection so that any transactional "
"state or locks are removed, and the connection is ready for its next "
"usage."
msgstr ""

#: ../../core/connections.rst:74
msgid ""
"The above procedure can be performed in a shorthand way by using the "
":meth:`~.Engine.execute` method of :class:`.Engine` itself::"
msgstr ""

#: ../../core/connections.rst:81
msgid ""
"Where above, the :meth:`~.Engine.execute` method acquires a new "
":class:`.Connection` on its own, executes the statement with that object,"
" and returns the :class:`.ResultProxy`.  In this case, the "
":class:`.ResultProxy` contains a special flag known as "
"``close_with_result``, which indicates that when its underlying DBAPI "
"cursor is closed, the :class:`.Connection` object itself is also closed, "
"which again returns the DBAPI connection to the connection pool, "
"releasing transactional resources."
msgstr ""

#: ../../core/connections.rst:89
msgid ""
"If the :class:`.ResultProxy` potentially has rows remaining, it can be "
"instructed to close out its resources explicitly::"
msgstr ""

#: ../../core/connections.rst:94
msgid ""
"If the :class:`.ResultProxy` has pending rows remaining and is "
"dereferenced by the application without being closed, Python garbage "
"collection will ultimately close out the cursor as well as trigger a "
"return of the pooled DBAPI connection resource to the pool (SQLAlchemy "
"achieves this by the usage of weakref callbacks - *never* the ``__del__``"
" method) - however it's never a good idea to rely upon Python garbage "
"collection to manage resources."
msgstr ""

#: ../../core/connections.rst:101
msgid ""
"Our example above illustrated the execution of a textual SQL string. The "
":meth:`~.Connection.execute` method can of course accommodate more than "
"that, including the variety of SQL expression constructs described in "
":ref:`sqlexpression_toplevel`."
msgstr ""

#: ../../core/connections.rst:107
msgid "Using Transactions"
msgstr ""

#: ../../core/connections.rst:111
msgid ""
"This section describes how to use transactions when working directly with"
" :class:`.Engine` and :class:`.Connection` objects. When using the "
"SQLAlchemy ORM, the public API for transaction control is via the "
":class:`.Session` object, which makes usage of the :class:`.Transaction` "
"object internally. See :ref:`unitofwork_transaction` for further "
"information."
msgstr ""

#: ../../core/connections.rst:118
msgid ""
"The :class:`~sqlalchemy.engine.Connection` object provides a "
":meth:`~.Connection.begin` method which returns a :class:`.Transaction` "
"object. This object is usually used within a try/except clause so that it"
" is guaranteed to invoke :meth:`.Transaction.rollback` or "
":meth:`.Transaction.commit`::"
msgstr ""

#: ../../core/connections.rst:133
msgid ""
"The above block can be created more succinctly using context managers, "
"either given an :class:`.Engine`::"
msgstr ""

#: ../../core/connections.rst:141
msgid ""
"Or from the :class:`.Connection`, in which case the :class:`.Transaction`"
" object is available as well::"
msgstr ""

#: ../../core/connections.rst:151
msgid "Nesting of Transaction Blocks"
msgstr ""

#: ../../core/connections.rst:153
msgid ""
"The :class:`.Transaction` object also handles \"nested\" behavior by "
"keeping track of the outermost begin/commit pair. In this example, two "
"functions both issue a transaction on a :class:`.Connection`, but only "
"the outermost :class:`.Transaction` object actually takes effect when it "
"is committed."
msgstr ""

#: ../../core/connections.rst:186
msgid ""
"Above, ``method_a`` is called first, which calls ``connection.begin()``. "
"Then it calls ``method_b``. When ``method_b`` calls "
"``connection.begin()``, it just increments a counter that is decremented "
"when it calls ``commit()``. If either ``method_a`` or ``method_b`` calls "
"``rollback()``, the whole transaction is rolled back. The transaction is "
"not committed until ``method_a`` calls the ``commit()`` method. This "
"\"nesting\" behavior allows the creation of functions which \"guarantee\""
" that a transaction will be used if one was not already available, but "
"will automatically participate in an enclosing transaction if one exists."
msgstr ""

#: ../../core/connections.rst:202
msgid "Understanding Autocommit"
msgstr ""

#: ../../core/connections.rst:204
msgid ""
"The previous transaction example illustrates how to use "
":class:`.Transaction` so that several executions can take part in the "
"same transaction. What happens when we issue an INSERT, UPDATE or DELETE "
"call without using :class:`.Transaction`?  While some DBAPI "
"implementations provide various special \"non-transactional\" modes, the "
"core behavior of DBAPI per PEP-0249 is that a *transaction is always in "
"progress*, providing only ``rollback()`` and ``commit()`` methods but no "
"``begin()``. SQLAlchemy assumes this is the case for any given DBAPI."
msgstr ""

#: ../../core/connections.rst:213
msgid ""
"Given this requirement, SQLAlchemy implements its own \"autocommit\" "
"feature which works completely consistently across all backends. This is "
"achieved by detecting statements which represent data-changing "
"operations, i.e. INSERT, UPDATE, DELETE, as well as data definition "
"language (DDL) statements such as CREATE TABLE, ALTER TABLE, and then "
"issuing a COMMIT automatically if no transaction is in progress. The "
"detection is based on the presence of the ``autocommit=True`` execution "
"option on the statement.   If the statement is a text-only statement and "
"the flag is not set, a regular expression is used to detect INSERT, "
"UPDATE, DELETE, as well as a variety of other commands for a particular "
"backend::"
msgstr ""

#: ../../core/connections.rst:227
msgid ""
"The \"autocommit\" feature is only in effect when no "
":class:`.Transaction` has otherwise been declared.   This means the "
"feature is not generally used with the ORM, as the :class:`.Session` "
"object by default always maintains an ongoing :class:`.Transaction`."
msgstr ""

#: ../../core/connections.rst:232
msgid ""
"Full control of the \"autocommit\" behavior is available using the "
"generative :meth:`.Connection.execution_options` method provided on "
":class:`.Connection`, :class:`.Engine`, :class:`.Executable`, using the "
"\"autocommit\" flag which will turn on or off the autocommit for the "
"selected scope. For example, a :func:`.text` construct representing a "
"stored procedure that commits might use it so that a SELECT statement "
"will issue a COMMIT::"
msgstr ""

#: ../../core/connections.rst:244
msgid "Connectionless Execution, Implicit Execution"
msgstr ""

#: ../../core/connections.rst:246
msgid ""
"Recall from the first section we mentioned executing with and without "
"explicit usage of :class:`.Connection`. \"Connectionless\" execution "
"refers to the usage of the ``execute()`` method on an object which is not"
" a :class:`.Connection`.  This was illustrated using the "
":meth:`~.Engine.execute` method of :class:`.Engine`::"
msgstr ""

#: ../../core/connections.rst:256
msgid ""
"In addition to \"connectionless\" execution, it is also possible to use "
"the :meth:`~.Executable.execute` method of any :class:`.Executable` "
"construct, which is a marker for SQL expression objects that support "
"execution.   The SQL expression object itself references an "
":class:`.Engine` or :class:`.Connection` known as the **bind**, which it "
"uses in order to provide so-called \"implicit\" execution services."
msgstr ""

#: ../../core/connections.rst:263
msgid "Given a table as below::"
msgstr ""

#: ../../core/connections.rst:273
msgid ""
"Explicit execution delivers the SQL text or constructed SQL expression to"
" the :meth:`~.Connection.execute` method of "
":class:`~sqlalchemy.engine.Connection`:"
msgstr ""

#: ../../core/connections.rst:285
msgid ""
"Explicit, connectionless execution delivers the expression to the "
":meth:`~.Engine.execute` method of :class:`~sqlalchemy.engine.Engine`:"
msgstr ""

#: ../../core/connections.rst:296
msgid ""
"Implicit execution is also connectionless, and makes usage of the "
":meth:`~.Executable.execute` method on the expression itself.   This "
"method is provided as part of the :class:`.Executable` class, which "
"refers to a SQL statement that is sufficient for being invoked against "
"the database.    The method makes usage of the assumption that either an "
":class:`~sqlalchemy.engine.Engine` or "
":class:`~sqlalchemy.engine.Connection` has been **bound** to the "
"expression object.   By \"bound\" we mean that the special attribute "
":attr:`.MetaData.bind` has been used to associate a series of "
":class:`.Table` objects and all SQL constructs derived from them with a "
"specific engine::"
msgstr ""

#: ../../core/connections.rst:315
msgid ""
"Above, we associate an :class:`.Engine` with a :class:`.MetaData` object "
"using the special attribute :attr:`.MetaData.bind`.  The :func:`.select` "
"construct produced from the :class:`.Table` object has a method "
":meth:`~.Executable.execute`, which will search for an :class:`.Engine` "
"that's \"bound\" to the :class:`.Table`."
msgstr ""

#: ../../core/connections.rst:320
msgid "Overall, the usage of \"bound metadata\" has three general effects:"
msgstr ""

#: ../../core/connections.rst:322
msgid ""
"SQL statement objects gain an :meth:`.Executable.execute` method which "
"automatically locates a \"bind\" with which to execute themselves."
msgstr ""

#: ../../core/connections.rst:324
msgid ""
"The ORM :class:`.Session` object supports using \"bound metadata\" in "
"order to establish which :class:`.Engine` should be used to invoke SQL "
"statements on behalf of a particular mapped class, though the "
":class:`.Session` also features its own explicit system of establishing "
"complex :class:`.Engine`/ mapped class configurations."
msgstr ""

#: ../../core/connections.rst:329
msgid ""
"The :meth:`.MetaData.create_all`, :meth:`.MetaData.drop_all`, "
":meth:`.Table.create`, :meth:`.Table.drop`, and \"autoload\" features all"
" make usage of the bound :class:`.Engine` automatically without the need "
"to pass it explicitly."
msgstr ""

#: ../../core/connections.rst:335
msgid ""
"The concepts of \"bound metadata\" and \"implicit execution\" are not "
"emphasized in modern SQLAlchemy. While they offer some convenience, they "
"are no longer required by any API and are never necessary."
msgstr ""

#: ../../core/connections.rst:339
msgid ""
"In applications where multiple :class:`.Engine` objects are present, each"
" one logically associated with a certain set of tables (i.e. *vertical "
"sharding*), the \"bound metadata\" technique can be used so that "
"individual :class:`.Table` can refer to the appropriate :class:`.Engine` "
"automatically; in particular this is supported within the ORM via the "
":class:`.Session` object as a means to associate :class:`.Table` objects "
"with an appropriate :class:`.Engine`, as an alternative to using the bind"
" arguments accepted directly by the :class:`.Session`."
msgstr ""

#: ../../core/connections.rst:346
msgid ""
"However, the \"implicit execution\" technique is not at all appropriate "
"for use with the ORM, as it bypasses the transactional context maintained"
" by the :class:`.Session`."
msgstr ""

#: ../../core/connections.rst:349
msgid ""
"Overall, in the *vast majority* of cases, \"bound metadata\" and "
"\"implicit execution\" are **not useful**.   While \"bound metadata\" has"
" a marginal level of usefulness with regards to ORM configuration, "
"\"implicit execution\" is a very old usage pattern that in most cases is "
"more confusing than it is helpful, and its usage is discouraged. Both "
"patterns seem to encourage the overuse of expedient \"short cuts\" in "
"application design which lead to problems later on."
msgstr ""

#: ../../core/connections.rst:356
msgid ""
"Modern SQLAlchemy usage, especially the ORM, places a heavy stress on "
"working within the context of a transaction at all times; the \"implicit "
"execution\" concept makes the job of associating statement execution with"
" a particular transaction much more difficult. The "
":meth:`.Executable.execute` method on a particular SQL statement usually "
"implies that the execution is not part of any particular transaction, "
"which is usually not the desired effect."
msgstr ""

#: ../../core/connections.rst:363
msgid ""
"In both \"connectionless\" examples, the "
":class:`~sqlalchemy.engine.Connection` is created behind the scenes; the "
":class:`~sqlalchemy.engine.ResultProxy` returned by the ``execute()`` "
"call references the :class:`~sqlalchemy.engine.Connection` used to issue "
"the SQL statement. When the :class:`.ResultProxy` is closed, the "
"underlying :class:`.Connection` is closed for us, resulting in the DBAPI "
"connection being returned to the pool with transactional resources "
"removed."
msgstr ""

#: ../../core/connections.rst:374
msgid "Translation of Schema Names"
msgstr ""

#: ../../core/connections.rst:376
msgid ""
"To support multi-tenancy applications that distribute common sets of "
"tables into multiple schemas, the "
":paramref:`.Connection.execution_options.schema_translate_map` execution "
"option may be used to repurpose a set of :class:`.Table` objects to "
"render under different schema names without any changes."
msgstr ""

#: ../../core/connections.rst:382
msgid "Given a table::"
msgstr ""

#: ../../core/connections.rst:390
msgid ""
"The \"schema\" of this :class:`.Table` as defined by the "
":paramref:`.Table.schema` attribute is ``None``.  The "
":paramref:`.Connection.execution_options.schema_translate_map` can "
"specify that all :class:`.Table` objects with a schema of ``None`` would "
"instead render the schema as ``user_schema_one``::"
msgstr ""

#: ../../core/connections.rst:401
msgid "The above code will invoke SQL on the database of the form::"
msgstr ""

#: ../../core/connections.rst:406
msgid ""
"That is, the schema name is substituted with our translated name.  The "
"map can specify any number of target->destination schemas::"
msgstr ""

#: ../../core/connections.rst:416
msgid ""
"The :paramref:`.Connection.execution_options.schema_translate_map` "
"parameter affects all DDL and SQL constructs generated from the SQL "
"expression language, as derived from the :class:`.Table` or "
":class:`.Sequence` objects. It does **not** impact literal string SQL "
"used via the :func:`.expression.text` construct nor via plain strings "
"passed to :meth:`.Connection.execute`."
msgstr ""

#: ../../core/connections.rst:422
msgid ""
"The feature takes effect **only** in those cases where the name of the "
"schema is derived directly from that of a :class:`.Table` or "
":class:`.Sequence`; it does not impact methods where a string schema name"
" is passed directly. By this pattern, it takes effect within the \"can "
"create\" / \"can drop\" checks performed by methods such as "
":meth:`.MetaData.create_all` or :meth:`.MetaData.drop_all` are called, "
"and it takes effect when using table reflection given a :class:`.Table` "
"object.  However it does **not** affect the operations present on the "
":class:`.Inspector` object, as the schema name is passed to these methods"
" explicitly."
msgstr ""

#: ../../core/connections.rst:437
msgid "Engine Disposal"
msgstr ""

#: ../../core/connections.rst:439
msgid ""
"The :class:`.Engine` refers to a connection pool, which means under "
"normal circumstances, there are open database connections present while "
"the :class:`.Engine` object is still resident in memory.   When an "
":class:`.Engine` is garbage collected, its connection pool is no longer "
"referred to by that :class:`.Engine`, and assuming none of its "
"connections are still checked out, the pool and its connections will also"
" be garbage collected, which has the effect of closing out the actual "
"database connections as well.   But otherwise, the :class:`.Engine` will "
"hold onto open database connections assuming it uses the normally default"
" pool implementation of :class:`.QueuePool`."
msgstr ""

#: ../../core/connections.rst:449
msgid ""
"The :class:`.Engine` is intended to normally be a permanent fixture "
"established up-front and maintained throughout the lifespan of an "
"application.  It is **not** intended to be created and disposed on a per-"
"connection basis; it is instead a registry that maintains both a pool of "
"connections as well as configurational information about the database and"
" DBAPI in use, as well as some degree of internal caching of per-database"
" resources."
msgstr ""

#: ../../core/connections.rst:457
msgid ""
"However, there are many cases where it is desirable that all connection "
"resources referred to by the :class:`.Engine` be completely closed out.  "
"It's generally not a good idea to rely on Python garbage collection for "
"this to occur for these cases; instead, the :class:`.Engine` can be "
"explicitly disposed using the :meth:`.Engine.dispose` method.   This "
"disposes of the engine's underlying connection pool and replaces it with "
"a new one that's empty. Provided that the :class:`.Engine` is discarded "
"at this point and no longer used, all **checked-in** connections which it"
" refers to will also be fully closed."
msgstr ""

#: ../../core/connections.rst:467
msgid "Valid use cases for calling :meth:`.Engine.dispose` include:"
msgstr ""

#: ../../core/connections.rst:469
msgid ""
"When a program wants to release any remaining checked-in connections held"
" by the connection pool and expects to no longer be connected to that "
"database at all for any future operations."
msgstr ""

#: ../../core/connections.rst:473
msgid ""
"When a program uses multiprocessing or ``fork()``, and an "
":class:`.Engine` object is copied to the child process, "
":meth:`.Engine.dispose` should be called so that the engine creates brand"
" new database connections local to that fork.   Database connections "
"generally do **not** travel across process boundaries."
msgstr ""

#: ../../core/connections.rst:479
msgid ""
"Within test suites or multitenancy scenarios where many ad-hoc, short-"
"lived :class:`.Engine` objects may be created and disposed."
msgstr ""

#: ../../core/connections.rst:483
msgid ""
"Connections that are **checked out** are **not** discarded when the "
"engine is disposed or garbage collected, as these connections are still "
"strongly referenced elsewhere by the application. However, after "
":meth:`.Engine.dispose` is called, those connections are no longer "
"associated with that :class:`.Engine`; when they are closed, they will be"
" returned to their now-orphaned connection pool which will ultimately be "
"garbage collected, once all connections which refer to it are also no "
"longer referenced anywhere. Since this process is not easy to control, it"
" is strongly recommended that :meth:`.Engine.dispose` is called only "
"after all checked out connections are checked in or otherwise de-"
"associated from their pool."
msgstr ""

#: ../../core/connections.rst:495
msgid ""
"An alternative for applications that are negatively impacted by the "
":class:`.Engine` object's use of connection pooling is to disable pooling"
" entirely.  This typically incurs only a modest performance impact upon "
"the use of new connections, and means that when a connection is checked "
"in, it is entirely closed out and is not held in memory.  See "
":ref:`pool_switching` for guidelines on how to disable pooling."
msgstr ""

#: ../../core/connections.rst:505
msgid "Using the Threadlocal Execution Strategy"
msgstr ""

#: ../../core/connections.rst:507
msgid ""
"The \"threadlocal\" engine strategy is an optional feature which can be "
"used by non-ORM applications to associate transactions with the current "
"thread, such that all parts of the application can participate in that "
"transaction implicitly without the need to explicitly reference a "
":class:`.Connection`."
msgstr ""

#: ../../core/connections.rst:515
msgid ""
"The \"threadlocal\" feature is generally discouraged.   It's designed for"
" a particular pattern of usage which is generally considered as a legacy "
"pattern.  It has **no impact** on the \"thread safety\" of SQLAlchemy "
"components or one's application. It also should not be used when using an"
" ORM :class:`~sqlalchemy.orm.session.Session` object, as the "
":class:`~sqlalchemy.orm.session.Session` itself represents an ongoing "
"transaction and itself handles the job of maintaining connection and "
"transactional resources."
msgstr ""

#: ../../core/connections.rst:525
msgid "Enabling ``threadlocal`` is achieved as follows::"
msgstr ""

#: ../../core/connections.rst:529
msgid ""
"The above :class:`.Engine` will now acquire a :class:`.Connection` using "
"connection resources derived from a thread-local variable whenever "
":meth:`.Engine.execute` or :meth:`.Engine.contextual_connect` is called. "
"This connection resource is maintained as long as it is referenced, which"
" allows multiple points of an application to share a transaction while "
"using connectionless execution::"
msgstr ""

#: ../../core/connections.rst:550
msgid ""
"Explicit execution can be mixed with connectionless execution by using "
"the :meth:`.Engine.connect` method to acquire a :class:`.Connection` that"
" is not part of the threadlocal scope::"
msgstr ""

#: ../../core/connections.rst:568
msgid ""
"To access the :class:`.Connection` that is bound to the threadlocal "
"scope, call :meth:`.Engine.contextual_connect`::"
msgstr ""

#: ../../core/connections.rst:575
msgid ""
"Calling :meth:`~.Connection.close` on the \"contextual\" connection does "
"not :term:`release` its resources until all other usages of that resource"
" are closed as well, including that any ongoing transactions are rolled "
"back or committed."
msgstr ""

#: ../../core/connections.rst:582
msgid "Working with Raw DBAPI Connections"
msgstr ""

#: ../../core/connections.rst:584
msgid ""
"There are some cases where SQLAlchemy does not provide a genericized way "
"at accessing some :term:`DBAPI` functions, such as calling stored "
"procedures as well as dealing with multiple result sets.  In these cases,"
" it's just as expedient to deal with the raw DBAPI connection directly."
msgstr ""

#: ../../core/connections.rst:589
msgid ""
"The most common way to access the raw DBAPI connection is to get it from "
"an already present :class:`.Connection` object directly.  It is present "
"using the :attr:`.Connection.connection` attribute::"
msgstr ""

#: ../../core/connections.rst:596
msgid ""
"The DBAPI connection here is actually a \"proxied\" in terms of the "
"originating connection pool, however this is an implementation detail "
"that in most cases can be ignored.    As this DBAPI connection is still "
"contained within the scope of an owning :class:`.Connection` object, it "
"is best to make use of the :class:`.Connection` object for most features "
"such as transaction control as well as calling the "
":meth:`.Connection.close` method; if these operations are performed on "
"the DBAPI connection directly, the owning :class:`.Connection` will not "
"be aware of these changes in state."
msgstr ""

#: ../../core/connections.rst:605
msgid ""
"To overcome the limitations imposed by the DBAPI connection that is "
"maintained by an owning :class:`.Connection`, a DBAPI connection is also "
"available without the need to procure a :class:`.Connection` first, using"
" the :meth:`.Engine.raw_connection` method of :class:`.Engine`::"
msgstr ""

#: ../../core/connections.rst:613
msgid ""
"This DBAPI connection is again a \"proxied\" form as was the case before."
" The purpose of this proxying is now apparent, as when we call the "
"``.close()`` method of this connection, the DBAPI connection is typically"
" not actually closed, but instead :term:`released` back to the engine's "
"connection pool::"
msgstr ""

#: ../../core/connections.rst:621
msgid ""
"While SQLAlchemy may in the future add built-in patterns for more DBAPI "
"use cases, there are diminishing returns as these cases tend to be rarely"
" needed and they also vary highly dependent on the type of DBAPI in use, "
"so in any case the direct DBAPI calling pattern is always there for those"
" cases where it is needed."
msgstr ""

#: ../../core/connections.rst:627
msgid "Some recipes for DBAPI connection use follow."
msgstr ""

#: ../../core/connections.rst:632
msgid "Calling Stored Procedures"
msgstr ""

#: ../../core/connections.rst:634
msgid ""
"For stored procedures with special syntactical or parameter concerns, "
"DBAPI-level `callproc "
"<http://legacy.python.org/dev/peps/pep-0249/#callproc>`_ may be used::"
msgstr ""

#: ../../core/connections.rst:649
msgid "Multiple Result Sets"
msgstr ""

#: ../../core/connections.rst:651
msgid ""
"Multiple result set support is available from a raw DBAPI cursor using "
"the `nextset <http://legacy.python.org/dev/peps/pep-0249/#nextset>`_ "
"method::"
msgstr ""

#: ../../core/connections.rst:668
msgid "Registering New Dialects"
msgstr ""

#: ../../core/connections.rst:670
msgid ""
"The :func:`.create_engine` function call locates the given dialect using "
"setuptools entrypoints.   These entry points can be established for third"
" party dialects within the setup.py script.  For example, to create a new"
" dialect \"foodialect://\", the steps are as follows:"
msgstr ""

#: ../../core/connections.rst:675
msgid "Create a package called ``foodialect``."
msgstr ""

#: ../../core/connections.rst:676
msgid ""
"The package should have a module containing the dialect class, which is "
"typically a subclass of "
":class:`sqlalchemy.engine.default.DefaultDialect`. In this example let's "
"say it's called ``FooDialect`` and its module is accessed via "
"``foodialect.dialect``."
msgstr ""

#: ../../core/connections.rst:680
msgid "The entry point can be established in setup.py as follows::"
msgstr ""

#: ../../core/connections.rst:687
msgid ""
"If the dialect is providing support for a particular DBAPI on top of an "
"existing SQLAlchemy-supported database, the name can be given including a"
" database-qualification.  For example, if ``FooDialect`` were in fact a "
"MySQL dialect, the entry point could be established like this::"
msgstr ""

#: ../../core/connections.rst:697
msgid ""
"The above entrypoint would then be accessed as "
"``create_engine(\"mysql+foodialect://\")``."
msgstr ""

#: ../../core/connections.rst:700
msgid "Registering Dialects In-Process"
msgstr ""

#: ../../core/connections.rst:702
msgid ""
"SQLAlchemy also allows a dialect to be registered within the current "
"process, bypassing the need for separate installation.   Use the "
"``register()`` function as follows::"
msgstr ""

#: ../../core/connections.rst:708
msgid ""
"The above will respond to ``create_engine(\"mysql+foodialect://\")`` and "
"load the ``MyMySQLDialect`` class from the ``myapp.dialect`` module."
msgstr ""

#: ../../core/connections.rst:714
msgid "Connection / Engine API"
msgstr ""

#: of sqlalchemy.engine.Connection:1
msgid "Provides high-level functionality for a wrapped DB-API connection."
msgstr ""

#: of sqlalchemy.engine.Connection:3
msgid ""
"Provides execution support for string-based SQL statements as well as "
":class:`.ClauseElement`, :class:`.Compiled` and "
":class:`.DefaultGenerator` objects. Provides a :meth:`begin` method to "
"return :class:`.Transaction` objects."
msgstr ""

#: of sqlalchemy.engine.Connection:8
msgid ""
"The Connection object is **not** thread-safe.  While a Connection can be "
"shared among threads using properly synchronized access, it is still "
"possible that the underlying DBAPI connection may not support shared "
"access between threads.  Check the DBAPI documentation for details."
msgstr ""

#: of sqlalchemy.engine.Connection:13
msgid ""
"The Connection object represents a single dbapi connection checked out "
"from the connection pool. In this state, the connection pool has no "
"affect upon the connection, including its expiration or timeout state. "
"For the connection pool to properly manage connections, connections "
"should be returned to the connection pool (i.e. ``connection.close()``) "
"whenever the connection is not in use."
msgstr ""

#: of sqlalchemy.engine.Connection.begin:1
msgid "Begin a transaction and return a transaction handle."
msgstr ""

#: of sqlalchemy.engine.Connection.begin:3
msgid ""
"The returned object is an instance of :class:`.Transaction`. This object "
"represents the \"scope\" of the transaction, which completes when either "
"the :meth:`.Transaction.rollback` or :meth:`.Transaction.commit` method "
"is called."
msgstr ""

#: of sqlalchemy.engine.Connection.begin:8
msgid ""
"Nested calls to :meth:`.begin` on the same :class:`.Connection` will "
"return new :class:`.Transaction` objects that represent an emulated "
"transaction within the scope of the enclosing transaction, that is::"
msgstr ""

#: of sqlalchemy.engine.Connection.begin:18
msgid ""
"Calls to :meth:`.Transaction.commit` only have an effect when invoked via"
" the outermost :class:`.Transaction` object, though the "
":meth:`.Transaction.rollback` method of any of the :class:`.Transaction` "
"objects will roll back the transaction."
msgstr ""

#: of sqlalchemy.engine.Connection.begin:24
#: sqlalchemy.engine.Connection.transaction:32 sqlalchemy.engine.Engine:8
#: sqlalchemy.engine.Engine.begin:24 sqlalchemy.engine.Engine.transaction:29
msgid "See also:"
msgstr ""

#: of sqlalchemy.engine.Connection.begin:26
msgid ":meth:`.Connection.begin_nested` - use a SAVEPOINT"
msgstr ""

#: of sqlalchemy.engine.Connection.begin:28
msgid ":meth:`.Connection.begin_twophase` - use a two phase /XID transaction"
msgstr ""

#: of sqlalchemy.engine.Connection.begin:30
msgid ":meth:`.Engine.begin` - context manager available from :class:`.Engine`."
msgstr ""

#: of sqlalchemy.engine.Connection.begin_nested:1
msgid "Begin a nested transaction and return a transaction handle."
msgstr ""

#: of sqlalchemy.engine.Connection.begin_nested:3
msgid "The returned object is an instance of :class:`.NestedTransaction`."
msgstr ""

#: of sqlalchemy.engine.Connection.begin_nested:5
msgid ""
"Nested transactions require SAVEPOINT support in the underlying database."
"  Any transaction in the hierarchy may ``commit`` and ``rollback``, "
"however the outermost transaction still controls the overall ``commit`` "
"or ``rollback`` of the transaction of a whole."
msgstr ""

#: of sqlalchemy.engine.Connection.begin_nested:11
#: sqlalchemy.engine.Connection.begin_twophase:12
msgid "See also :meth:`.Connection.begin`, :meth:`.Connection.begin_twophase`."
msgstr ""

#: of sqlalchemy.engine.Connection.begin_twophase:1
msgid "Begin a two-phase or XA transaction and return a transaction handle."
msgstr ""

#: of sqlalchemy.engine.Connection.begin_twophase:4
msgid ""
"The returned object is an instance of :class:`.TwoPhaseTransaction`, "
"which in addition to the methods provided by :class:`.Transaction`, also "
"provides a :meth:`~.TwoPhaseTransaction.prepare` method."
msgstr ""

#: of sqlalchemy.engine.Connection.begin_twophase
#: sqlalchemy.engine.Connection.execute
#: sqlalchemy.engine.Connection.execution_options
#: sqlalchemy.engine.Engine.contextual_connect
#: sqlalchemy.engine.Engine.table_names
msgid "Parameters"
msgstr ""

#: of sqlalchemy.engine.Connection.begin_twophase:9
msgid ""
"the two phase transaction id.  If not supplied, a random id will be "
"generated."
msgstr ""

#: of sqlalchemy.engine.Connection.close:1
msgid "Close this :class:`.Connection`."
msgstr ""

#: of sqlalchemy.engine.Connection.close:3
msgid ""
"This results in a release of the underlying database resources, that is, "
"the DBAPI connection referenced internally. The DBAPI connection is "
"typically restored back to the connection-holding :class:`.Pool` "
"referenced by the :class:`.Engine` that produced this "
":class:`.Connection`. Any transactional state present on the DBAPI "
"connection is also unconditionally released via the DBAPI connection's "
"``rollback()`` method, regardless of any :class:`.Transaction` object "
"that may be outstanding with regards to this :class:`.Connection`."
msgstr ""

#: of sqlalchemy.engine.Connection.close:14
msgid ""
"After :meth:`~.Connection.close` is called, the :class:`.Connection` is "
"permanently in a closed state, and will allow no further operations."
msgstr ""

#: of sqlalchemy.engine.Connection.closed:1
msgid "Return True if this connection is closed."
msgstr ""

#: of sqlalchemy.engine.Connection.connect:1
#: sqlalchemy.engine.Connection.contextual_connect:1
msgid "Returns a branched version of this :class:`.Connection`."
msgstr ""

#: of sqlalchemy.engine.Connection.connect:3
#: sqlalchemy.engine.Connection.contextual_connect:3
msgid ""
"The :meth:`.Connection.close` method on the returned :class:`.Connection`"
" can be called and this :class:`.Connection` will remain open."
msgstr ""

#: of sqlalchemy.engine.Connection.connect:7
msgid ""
"This method provides usage symmetry with :meth:`.Engine.connect`, "
"including for usage with context managers."
msgstr ""

#: of sqlalchemy.engine.Connection.connection:1
msgid "The underlying DB-API connection managed by this Connection."
msgstr ""

#: of sqlalchemy.engine.Connection.connection:6
#: sqlalchemy.engine.Engine.raw_connection:18
msgid ":ref:`dbapi_connections`"
msgstr ""

#: of sqlalchemy.engine.Connection.contextual_connect:7
msgid ""
"This method provides usage symmetry with "
":meth:`.Engine.contextual_connect`, including for usage with context "
"managers."
msgstr ""

#: of sqlalchemy.engine.Connection.default_isolation_level:1
msgid "The default isolation level assigned to this :class:`.Connection`."
msgstr ""

#: of sqlalchemy.engine.Connection.default_isolation_level:3
msgid ""
"This is the isolation level setting that the :class:`.Connection` has "
"when first procured via the :meth:`.Engine.connect` method. This level "
"stays in place until the "
":paramref:`.Connection.execution_options.isolation_level` is used to "
"change the setting on a per-:class:`.Connection` basis."
msgstr ""

#: of sqlalchemy.engine.Connection.default_isolation_level:9
msgid ""
"Unlike :meth:`.Connection.get_isolation_level`, this attribute is set "
"ahead of time from the first connection procured by the dialect, so SQL "
"query is not invoked when this accessor is called."
msgstr ""

#: of sqlalchemy.engine.Connection.default_isolation_level:17
#: sqlalchemy.engine.Connection.execution_options:101
msgid ":meth:`.Connection.get_isolation_level` - view current level"
msgstr ""

#: of sqlalchemy.engine.Connection.default_isolation_level:19
#: sqlalchemy.engine.Connection.execution_options:98
#: sqlalchemy.engine.Connection.get_isolation_level:24
msgid ""
":paramref:`.create_engine.isolation_level` - set per :class:`.Engine` "
"isolation level"
msgstr ""

#: of sqlalchemy.engine.Connection.default_isolation_level:22
#: sqlalchemy.engine.Connection.get_isolation_level:27
msgid ""
":paramref:`.Connection.execution_options.isolation_level` - set per "
":class:`.Connection` isolation level"
msgstr ""

#: of sqlalchemy.engine.Connection.detach:1
msgid "Detach the underlying DB-API connection from its connection pool."
msgstr ""

#: of sqlalchemy.engine.Connection.detach:3 sqlalchemy.engine.Engine.begin:4
msgid "E.g.::"
msgstr ""

#: of sqlalchemy.engine.Connection.detach:14
msgid ""
"This :class:`.Connection` instance will remain usable.  When closed (or "
"exited from a context manager context as above), the DB-API connection "
"will be literally closed and not returned to its originating pool."
msgstr ""

#: of sqlalchemy.engine.Connection.detach:19
msgid ""
"This method can be used to insulate the rest of an application from a "
"modified state on a connection (such as a transaction isolation level or "
"similar)."
msgstr ""

#: of sqlalchemy.engine.Connection.execute:1
msgid "Executes a SQL statement construct and returns a :class:`.ResultProxy`."
msgstr ""

#: of sqlalchemy.engine.Connection.execute:4
msgid ""
"The statement to be executed.  May be one of:  * a plain string * any "
":class:`.ClauseElement` construct that is also   a subclass of "
":class:`.Executable`, such as a   :func:`~.expression.select` construct *"
" a :class:`.FunctionElement`, such as that generated   by :data:`.func`, "
"will be automatically wrapped in   a SELECT statement, which is then "
"executed. * a :class:`.DDLElement` object * a :class:`.DefaultGenerator` "
"object * a :class:`.Compiled` object"
msgstr ""

#: of sqlalchemy.engine.Connection.execute:4
msgid "The statement to be executed.  May be one of:"
msgstr ""

#: of sqlalchemy.engine.Connection.execute:7
msgid "a plain string"
msgstr ""

#: of sqlalchemy.engine.Connection.execute:8
msgid ""
"any :class:`.ClauseElement` construct that is also a subclass of "
":class:`.Executable`, such as a :func:`~.expression.select` construct"
msgstr ""

#: of sqlalchemy.engine.Connection.execute:11
msgid ""
"a :class:`.FunctionElement`, such as that generated by :data:`.func`, "
"will be automatically wrapped in a SELECT statement, which is then "
"executed."
msgstr ""

#: of sqlalchemy.engine.Connection.execute:14
msgid "a :class:`.DDLElement` object"
msgstr ""

#: of sqlalchemy.engine.Connection.execute:15
msgid "a :class:`.DefaultGenerator` object"
msgstr ""

#: of sqlalchemy.engine.Connection.execute:16
msgid "a :class:`.Compiled` object"
msgstr ""

#: of sqlalchemy.engine.Connection.execute:18
msgid ""
"represent bound parameter values to be used in the execution.   "
"Typically, the format is either a collection of one or more dictionaries "
"passed to \\*multiparams::      conn.execute(         table.insert(),"
"         {\"id\":1, \"value\":\"v1\"},         {\"id\":2, "
"\"value\":\"v2\"}     )  ...or individual key/values interpreted by "
"\\**params::      conn.execute(         table.insert(), id=1, "
"value=\"v1\"     )  In the case that a plain SQL string is passed, and "
"the underlying DBAPI accepts positional bind parameters, a collection of "
"tuples or individual values in \\*multiparams may be passed::      "
"conn.execute(         \"INSERT INTO table (id, value) VALUES (?, ?)\","
"         (1, \"v1\"), (2, \"v2\")     )      conn.execute(         "
"\"INSERT INTO table (id, value) VALUES (?, ?)\",         1, \"v1\"     )"
"  Note above, the usage of a question mark \"?\" or other symbol is "
"contingent upon the \"paramstyle\" accepted by the DBAPI in use, which "
"may be any of \"qmark\", \"named\", \"pyformat\", \"format\", "
"\"numeric\".   See `pep-249 <http://www.python.org/dev/peps/pep-0249/>`_ "
"for details on paramstyle.  To execute a textual SQL statement which uses"
" bound parameters in a DBAPI-agnostic way, use the "
":func:`~.expression.text` construct."
msgstr ""

#: of sqlalchemy.engine.Connection.execute:18
msgid ""
"represent bound parameter values to be used in the execution.   "
"Typically, the format is either a collection of one or more dictionaries "
"passed to \\*multiparams::"
msgstr ""

#: of sqlalchemy.engine.Connection.execute:29
msgid "...or individual key/values interpreted by \\**params::"
msgstr ""

#: of sqlalchemy.engine.Connection.execute:35
msgid ""
"In the case that a plain SQL string is passed, and the underlying DBAPI "
"accepts positional bind parameters, a collection of tuples or individual "
"values in \\*multiparams may be passed::"
msgstr ""

#: of sqlalchemy.engine.Connection.execute:49
msgid ""
"Note above, the usage of a question mark \"?\" or other symbol is "
"contingent upon the \"paramstyle\" accepted by the DBAPI in use, which "
"may be any of \"qmark\", \"named\", \"pyformat\", \"format\", "
"\"numeric\".   See `pep-249 <http://www.python.org/dev/peps/pep-0249/>`_ "
"for details on paramstyle."
msgstr ""

#: of sqlalchemy.engine.Connection.execute:55
msgid ""
"To execute a textual SQL statement which uses bound parameters in a "
"DBAPI-agnostic way, use the :func:`~.expression.text` construct."
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:1
msgid "Set non-SQL options for the connection which take effect during execution."
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:4
msgid ""
"The method returns a copy of this :class:`.Connection` which references "
"the same underlying DBAPI connection, but also defines the given "
"execution options which will take effect for a call to :meth:`execute`. "
"As the new :class:`.Connection` references the same underlying resource, "
"it's usually a good idea to ensure that the copies will be discarded "
"immediately, which is implicit if used as in::"
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:14
msgid ""
"Note that any key/value can be passed to "
":meth:`.Connection.execution_options`, and it will be stored in the "
"``_execution_options`` dictionary of the :class:`.Connection`.   It is "
"suitable for usage by end-user schemes to communicate with event "
"listeners, for example."
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:20
msgid ""
"The keywords that are currently recognized by SQLAlchemy itself include "
"all those listed under :meth:`.Executable.execution_options`, as well as "
"others that are specific to :class:`.Connection`."
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:24
msgid ""
"Available on: Connection, statement. When True, a COMMIT will be invoked "
"after execution when executed in 'autocommit' mode, i.e. when an explicit"
" transaction is not begun on the connection. Note that DBAPI connections "
"by default are always in a transaction - SQLAlchemy uses rules applied to"
" different kinds of statements to determine if COMMIT will be invoked in "
"order to provide its \"autocommit\" feature. Typically, all "
"INSERT/UPDATE/DELETE statements as well as CREATE/DROP statements have "
"autocommit behavior enabled; SELECT constructs do not. Use this option "
"when invoking a SELECT or other specific SQL construct where COMMIT is "
"desired (typically when calling stored procedures and such), and an "
"explicit transaction is not in progress."
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:38
msgid ""
"Available on: Connection. A dictionary where :class:`.Compiled` objects "
"will be cached when the :class:`.Connection` compiles a clause expression"
" into a :class:`.Compiled` object. It is the user's responsibility to "
"manage the size of this dictionary, which will have keys corresponding to"
" the dialect, clause element, the column names within the VALUES or SET "
"clause of an INSERT or UPDATE, as well as the \"batch\" mode for an "
"INSERT or UPDATE statement. The format of this dictionary is not "
"guaranteed to stay the same in future releases.  Note that the ORM makes "
"use of its own \"compiled\" caches for some operations, including flush "
"operations.  The caching used by the ORM internally supersedes a cache "
"dictionary specified here."
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:38
msgid ""
"Available on: Connection. A dictionary where :class:`.Compiled` objects "
"will be cached when the :class:`.Connection` compiles a clause expression"
" into a :class:`.Compiled` object. It is the user's responsibility to "
"manage the size of this dictionary, which will have keys corresponding to"
" the dialect, clause element, the column names within the VALUES or SET "
"clause of an INSERT or UPDATE, as well as the \"batch\" mode for an "
"INSERT or UPDATE statement. The format of this dictionary is not "
"guaranteed to stay the same in future releases."
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:50
msgid ""
"Note that the ORM makes use of its own \"compiled\" caches for some "
"operations, including flush operations.  The caching used by the ORM "
"internally supersedes a cache dictionary specified here."
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:55
msgid ""
"Available on: :class:`.Connection`. Set the transaction isolation level "
"for the lifespan of this :class:`.Connection` object (*not* the "
"underlying DBAPI connection, for which the level is reset to its original"
" setting upon termination of this :class:`.Connection` object).  Valid "
"values include those string values accepted by the "
":paramref:`.create_engine.isolation_level` parameter passed to "
":func:`.create_engine`.  These levels are semi-database specific; see "
"individual dialect documentation for valid levels.  Note that this option"
" necessarily affects the underlying DBAPI connection for the lifespan of "
"the originating :class:`.Connection`, and is not per-execution. This "
"setting is not removed until the underlying DBAPI connection is returned "
"to the connection pool, i.e. the :meth:`.Connection.close` method is "
"called.  .. warning::  The ``isolation_level`` execution option should"
"    **not** be used when a transaction is already established, that    "
"is, the :meth:`.Connection.begin` method or similar has been    called.  "
"A database cannot change the isolation level on a    transaction in "
"progress, and different DBAPIs and/or    SQLAlchemy dialects may "
"implicitly roll back or commit    the transaction, or not affect the "
"connection at all.     .. versionchanged:: 0.9.9 A warning is emitted "
"when the       ``isolation_level`` execution option is used after a"
"       transaction has been started with :meth:`.Connection.begin`       "
"or similar.  .. note:: The ``isolation_level`` execution option is "
"implicitly    reset if the :class:`.Connection` is invalidated, e.g. via"
"    the :meth:`.Connection.invalidate` method, or if a    disconnection "
"error occurs.  The new connection produced after    the invalidation will"
" not have the isolation level re-applied    to it automatically.  .. "
"seealso::        :paramref:`.create_engine.isolation_level`       - set "
"per :class:`.Engine` isolation level        "
":meth:`.Connection.get_isolation_level` - view current level        "
":ref:`SQLite Transaction Isolation <sqlite_isolation_level>`        "
":ref:`PostgreSQL Transaction Isolation <postgresql_isolation_level>`"
"        :ref:`MySQL Transaction Isolation <mysql_isolation_level>`"
"        :ref:`SQL Server Transaction Isolation <mssql_isolation_level>`"
"        :ref:`session_transaction_isolation` - for the ORM"
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:55
msgid ""
"Available on: :class:`.Connection`. Set the transaction isolation level "
"for the lifespan of this :class:`.Connection` object (*not* the "
"underlying DBAPI connection, for which the level is reset to its original"
" setting upon termination of this :class:`.Connection` object)."
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:62
msgid ""
"Valid values include those string values accepted by the "
":paramref:`.create_engine.isolation_level` parameter passed to "
":func:`.create_engine`.  These levels are semi-database specific; see "
"individual dialect documentation for valid levels."
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:69
msgid ""
"Note that this option necessarily affects the underlying DBAPI connection"
" for the lifespan of the originating :class:`.Connection`, and is not "
"per-execution. This setting is not removed until the underlying DBAPI "
"connection is returned to the connection pool, i.e. the "
":meth:`.Connection.close` method is called."
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:76
msgid ""
"The ``isolation_level`` execution option should **not** be used when a "
"transaction is already established, that is, the "
":meth:`.Connection.begin` method or similar has been called.  A database "
"cannot change the isolation level on a transaction in progress, and "
"different DBAPIs and/or SQLAlchemy dialects may implicitly roll back or "
"commit the transaction, or not affect the connection at all."
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:84
msgid ""
"A warning is emitted when the ``isolation_level`` execution option is "
"used after a transaction has been started with :meth:`.Connection.begin` "
"or similar."
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:89
msgid ""
"The ``isolation_level`` execution option is implicitly reset if the "
":class:`.Connection` is invalidated, e.g. via the "
":meth:`.Connection.invalidate` method, or if a disconnection error "
"occurs.  The new connection produced after the invalidation will not have"
" the isolation level re-applied to it automatically."
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:103
msgid ":ref:`SQLite Transaction Isolation <sqlite_isolation_level>`"
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:105
msgid ":ref:`PostgreSQL Transaction Isolation <postgresql_isolation_level>`"
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:107
msgid ":ref:`MySQL Transaction Isolation <mysql_isolation_level>`"
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:109
msgid ":ref:`SQL Server Transaction Isolation <mssql_isolation_level>`"
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:111
msgid ":ref:`session_transaction_isolation` - for the ORM"
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:113
msgid ""
"When ``True``, if the final parameter list or dictionary is totally "
"empty, will invoke the statement on the cursor as "
"``cursor.execute(statement)``, not passing the parameter collection at "
"all. Some DBAPIs such as psycopg2 and mysql-python consider percent signs"
" as significant only when parameters are present; this option allows code"
" to generate SQL containing percent signs (and possibly other characters)"
" that is neutral regarding whether it's executed by the DBAPI or piped "
"into a script that's later invoked by command line tools.  .. "
"versionadded:: 0.7.6"
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:113
msgid ""
"When ``True``, if the final parameter list or dictionary is totally "
"empty, will invoke the statement on the cursor as "
"``cursor.execute(statement)``, not passing the parameter collection at "
"all. Some DBAPIs such as psycopg2 and mysql-python consider percent signs"
" as significant only when parameters are present; this option allows code"
" to generate SQL containing percent signs (and possibly other characters)"
" that is neutral regarding whether it's executed by the DBAPI or piped "
"into a script that's later invoked by command line tools."
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:127
msgid ""
"Available on: Connection, statement. Indicate to the dialect that results"
" should be \"streamed\" and not pre-buffered, if possible.  This is a "
"limitation of many DBAPIs.  The flag is currently understood only by the "
"psycopg2, mysqldb and pymysql dialects."
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:133
msgid ""
"Available on: Connection, Engine. A dictionary mapping schema names to "
"schema names, that will be applied to the :paramref:`.Table.schema` "
"element of each :class:`.Table` encountered when SQL or DDL expression "
"elements are compiled into strings; the resulting schema name will be "
"converted based on presence in the map of the original name.  .. "
"versionadded:: 1.1  .. seealso::    :ref:`schema_translating`"
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:133
msgid ""
"Available on: Connection, Engine. A dictionary mapping schema names to "
"schema names, that will be applied to the :paramref:`.Table.schema` "
"element of each :class:`.Table` encountered when SQL or DDL expression "
"elements are compiled into strings; the resulting schema name will be "
"converted based on presence in the map of the original name."
msgstr ""

#: of sqlalchemy.engine.Connection.execution_options:144
#: sqlalchemy.engine.Connection.schema_for_object:12
#: sqlalchemy.engine.Engine.schema_for_object:12
msgid ":ref:`schema_translating`"
msgstr ""

#: of sqlalchemy.engine.Connection.get_isolation_level:1
msgid "Return the current isolation level assigned to this :class:`.Connection`."
msgstr ""

#: of sqlalchemy.engine.Connection.get_isolation_level:4
msgid ""
"This will typically be the default isolation level as determined by the "
"dialect, unless if the "
":paramref:`.Connection.execution_options.isolation_level` feature has "
"been used to alter the isolation level on a per-:class:`.Connection` "
"basis."
msgstr ""

#: of sqlalchemy.engine.Connection.get_isolation_level:10
msgid ""
"This attribute will typically perform a live SQL operation in order to "
"procure the current isolation level, so the value returned is the actual "
"level on the underlying DBAPI connection regardless of how this state was"
" set.  Compare to the :attr:`.Connection.default_isolation_level` "
"accessor which returns the dialect-level setting without performing a SQL"
" query."
msgstr ""

#: of sqlalchemy.engine.Connection.get_isolation_level:22
msgid ":attr:`.Connection.default_isolation_level` - view default level"
msgstr ""

#: of sqlalchemy.engine.Connection.in_transaction:1
msgid "Return True if a transaction is in progress."
msgstr ""

#: of sqlalchemy.engine.Connection.info:1
msgid ""
"Info dictionary associated with the underlying DBAPI connection referred "
"to by this :class:`.Connection`, allowing user-defined data to be "
"associated with the connection."
msgstr ""

#: of sqlalchemy.engine.Connection.info:5
msgid ""
"The data here will follow along with the DBAPI connection including after"
" it is returned to the connection pool and used again in subsequent "
"instances of :class:`.Connection`."
msgstr ""

#: of sqlalchemy.engine.Connection.invalidate:1
msgid ""
"Invalidate the underlying DBAPI connection associated with this "
":class:`.Connection`."
msgstr ""

#: of sqlalchemy.engine.Connection.invalidate:4
msgid ""
"The underlying DBAPI connection is literally closed (if possible), and is"
" discarded.  Its source connection pool will typically lazily create a "
"new connection to replace it."
msgstr ""

#: of sqlalchemy.engine.Connection.invalidate:8
msgid ""
"Upon the next use (where \"use\" typically means using the "
":meth:`.Connection.execute` method or similar), this :class:`.Connection`"
" will attempt to procure a new DBAPI connection using the services of the"
" :class:`.Pool` as a source of connectivity (e.g. a \"reconnection\")."
msgstr ""

#: of sqlalchemy.engine.Connection.invalidate:14
msgid ""
"If a transaction was in progress (e.g. the :meth:`.Connection.begin` "
"method has been called) when :meth:`.Connection.invalidate` method is "
"called, at the DBAPI level all state associated with this transaction is "
"lost, as the DBAPI connection is closed.  The :class:`.Connection` will "
"not allow a reconnection to proceed until the :class:`.Transaction` "
"object is ended, by calling the :meth:`.Transaction.rollback` method; "
"until that point, any attempt at continuing to use the "
":class:`.Connection` will raise an "
":class:`~sqlalchemy.exc.InvalidRequestError`. This is to prevent "
"applications from accidentally continuing an ongoing transactional "
"operations despite the fact that the transaction has been lost due to an "
"invalidation."
msgstr ""

#: of sqlalchemy.engine.Connection.invalidate:29
msgid ""
"The :meth:`.Connection.invalidate` method, just like auto-invalidation, "
"will at the connection pool level invoke the "
":meth:`.PoolEvents.invalidate` event."
msgstr ""

#: of sqlalchemy.engine.Connection.invalidate:35
msgid ":ref:`pool_connection_invalidation`"
msgstr ""

#: of sqlalchemy.engine.Connection.invalidated:1
msgid "Return True if this connection was invalidated."
msgstr ""

#: of sqlalchemy.engine.Connection.run_callable:1
#: sqlalchemy.engine.Engine.run_callable:1
msgid ""
"Given a callable object or function, execute it, passing a "
":class:`.Connection` as the first argument."
msgstr ""

#: of sqlalchemy.engine.Connection.run_callable:4
#: sqlalchemy.engine.Engine.run_callable:4
msgid ""
"The given \\*args and \\**kwargs are passed subsequent to the "
":class:`.Connection` argument."
msgstr ""

#: of sqlalchemy.engine.Connection.run_callable:7
msgid ""
"This function, along with :meth:`.Engine.run_callable`, allows a function"
" to be run with a :class:`.Connection` or :class:`.Engine` object without"
" the need to know which one is being dealt with."
msgstr ""

#: of sqlalchemy.engine.Connectable.scalar:1
#: sqlalchemy.engine.Connection.scalar:1 sqlalchemy.engine.Engine.scalar:1
msgid "Executes and returns the first column of the first row."
msgstr ""

#: of sqlalchemy.engine.Connection.scalar:3
msgid "The underlying result/cursor is closed after execution."
msgstr ""

#: of sqlalchemy.engine.Connection.schema_for_object:1
#: sqlalchemy.engine.Engine.schema_for_object:1
msgid "Return the \".schema\" attribute for an object."
msgstr ""

#: of sqlalchemy.engine.Connection.schema_for_object:3
#: sqlalchemy.engine.Engine.schema_for_object:3
msgid ""
"Used for :class:`.Table`, :class:`.Sequence` and similar objects, and "
"takes into account the "
":paramref:`.Connection.execution_options.schema_translate_map` parameter."
msgstr ""

#: of sqlalchemy.engine.Connection.transaction:1
#: sqlalchemy.engine.Engine.transaction:1
msgid "Execute the given function within a transaction boundary."
msgstr ""

#: of sqlalchemy.engine.Connection.transaction:3
msgid ""
"The function is passed this :class:`.Connection` as the first argument, "
"followed by the given \\*args and \\**kwargs, e.g.::"
msgstr ""

#: of sqlalchemy.engine.Connection.transaction:12
#: sqlalchemy.engine.Engine.transaction:14
msgid ""
"The operations inside the function are all invoked within the context of "
"a single :class:`.Transaction`. Upon success, the transaction is "
"committed.  If an exception is raised, the transaction is rolled back "
"before propagating the exception."
msgstr ""

#: of sqlalchemy.engine.Connection.transaction:20
msgid ""
"The :meth:`.transaction` method is superseded by the usage of the Python "
"``with:`` statement, which can be used with :meth:`.Connection.begin`::"
msgstr ""

#: of sqlalchemy.engine.Connection.transaction:27
msgid "As well as with :meth:`.Engine.begin`::"
msgstr ""

#: of sqlalchemy.engine.Connection.transaction:34
#: sqlalchemy.engine.Engine.transaction:31
msgid ":meth:`.Engine.begin` - engine-level transactional context"
msgstr ""

#: of sqlalchemy.engine.Connection.transaction:37
msgid ""
":meth:`.Engine.transaction` - engine-level version of "
":meth:`.Connection.transaction`"
msgstr ""

#: of sqlalchemy.engine.Connectable:1
msgid "Interface for an object which supports execution of SQL constructs."
msgstr ""

#: of sqlalchemy.engine.Connectable:3
msgid ""
"The two implementations of :class:`.Connectable` are :class:`.Connection`"
" and :class:`.Engine`."
msgstr ""

#: of sqlalchemy.engine.Connectable:6
msgid ""
"Connectable must also implement the 'dialect' member which references a "
":class:`.Dialect` instance."
msgstr ""

#: of sqlalchemy.engine.Connectable.connect:1
msgid "Return a :class:`.Connection` object."
msgstr ""

#: of sqlalchemy.engine.Connectable.connect:3
#: sqlalchemy.engine.Connectable.contextual_connect:4
msgid ""
"Depending on context, this may be ``self`` if this object is already an "
"instance of :class:`.Connection`, or a newly procured "
":class:`.Connection` if this object is an instance of :class:`.Engine`."
msgstr ""

#: of sqlalchemy.engine.Connectable.contextual_connect:1
msgid ""
"Return a :class:`.Connection` object which may be part of an ongoing "
"context."
msgstr ""

#: of sqlalchemy.engine.Connectable.create:1
msgid "Emit CREATE statements for the given schema entity."
msgstr ""

#: of sqlalchemy.engine.Connectable.create:3
msgid ""
"Use the create() method on the given schema object directly, i.e. "
":meth:`.Table.create`, :meth:`.Index.create`, "
":meth:`.MetaData.create_all`"
msgstr ""

#: of sqlalchemy.engine.Connectable.drop:1
msgid "Emit DROP statements for the given schema entity."
msgstr ""

#: of sqlalchemy.engine.Connectable.drop:3
msgid ""
"Use the drop() method on the given schema object directly, i.e. "
":meth:`.Table.drop`, :meth:`.Index.drop`, :meth:`.MetaData.drop_all`"
msgstr ""

#: of sqlalchemy.engine.Connectable.execute:1
#: sqlalchemy.engine.Engine.execute:1
msgid "Executes the given construct and returns a :class:`.ResultProxy`."
msgstr ""

#: of sqlalchemy.engine.Connectable.scalar:3 sqlalchemy.engine.Engine.scalar:3
msgid "The underlying cursor is closed after execution."
msgstr ""

#: of sqlalchemy.engine.CreateEnginePlugin:1
msgid ""
"A set of hooks intended to augment the construction of an "
":class:`.Engine` object based on entrypoint names in a URL."
msgstr ""

#: of sqlalchemy.engine.CreateEnginePlugin:4
msgid ""
"The purpose of :class:`.CreateEnginePlugin` is to allow third-party "
"systems to apply engine, pool and dialect level event listeners without "
"the need for the target application to be modified; instead, the plugin "
"names can be added to the database URL.  Target applications for "
":class:`.CreateEnginePlugin` include:"
msgstr ""

#: of sqlalchemy.engine.CreateEnginePlugin:10
msgid ""
"connection and SQL performance tools, e.g. which use events to track "
"number of checkouts and/or time spent with statements"
msgstr ""

#: of sqlalchemy.engine.CreateEnginePlugin:13
msgid "connectivity plugins such as proxies"
msgstr ""

#: of sqlalchemy.engine.CreateEnginePlugin:15
msgid ""
"Plugins are registered using entry points in a similar way as that of "
"dialects::"
msgstr ""

#: of sqlalchemy.engine.CreateEnginePlugin:23
msgid ""
"A plugin that uses the above names would be invoked from a database URL "
"as in::"
msgstr ""

#: of sqlalchemy.engine.CreateEnginePlugin:31
msgid ""
"Alternatively, the :paramref:`.create_engine.plugins\" argument may be "
"passed as a list to :func:`.create_engine`::"
msgstr ""

#: of sqlalchemy.engine.CreateEnginePlugin:38
msgid "plugin names can also be specified to :func:`.create_engine` as a list"
msgstr ""

#: of sqlalchemy.engine.CreateEnginePlugin:41
msgid ""
"The ``plugin`` argument supports multiple instances, so that a URL may "
"specify multiple plugins; they are loaded in the order stated in the "
"URL::"
msgstr ""

#: of sqlalchemy.engine.CreateEnginePlugin:49
msgid ""
"A plugin can receive additional arguments from the URL string as well as "
"from the keyword arguments passed to :func:`.create_engine`. The "
":class:`.URL` object and the keyword dictionary are passed to the "
"constructor so that these arguments can be extracted from the url's "
":attr:`.URL.query` collection as well as from the dictionary::"
msgstr ""

#: of sqlalchemy.engine.CreateEnginePlugin:61
msgid ""
"Arguments like those illustrated above would be consumed from the "
"following::"
msgstr ""

#: of sqlalchemy.engine.CreateEnginePlugin:71
msgid ""
"The URL and dictionary are used for subsequent setup of the engine as "
"they are, so the plugin can modify their arguments in-place. Arguments "
"that are only understood by the plugin should be popped or otherwise "
"removed so that they aren't interpreted as erroneous arguments "
"afterwards."
msgstr ""

#: of sqlalchemy.engine.CreateEnginePlugin:77
msgid ""
"When the engine creation process completes and produces the "
":class:`.Engine` object, it is again passed to the plugin via the "
":meth:`.CreateEnginePlugin.engine_created` hook.  In this hook, "
"additional changes can be made to the engine, most typically involving "
"setup of events (e.g. those defined in :ref:`core_event_toplevel`)."
msgstr ""

#: of sqlalchemy.engine.CreateEnginePlugin.engine_created:1
msgid "Receive the :class:`.Engine` object when it is fully constructed."
msgstr ""

#: of sqlalchemy.engine.CreateEnginePlugin.engine_created:3
msgid ""
"The plugin may make additional changes to the engine, such as registering"
" engine or connection pool events."
msgstr ""

#: of sqlalchemy.engine.CreateEnginePlugin.handle_dialect_kwargs:1
msgid "parse and modify dialect kwargs"
msgstr ""

#: of sqlalchemy.engine.CreateEnginePlugin.handle_pool_kwargs:1
msgid "parse and modify pool kwargs"
msgstr ""

#: of sqlalchemy.engine.Engine:1
msgid ""
"Connects a :class:`~sqlalchemy.pool.Pool` and "
":class:`~sqlalchemy.engine.interfaces.Dialect` together to provide a "
"source of database connectivity and behavior."
msgstr ""

#: of sqlalchemy.engine.Engine:5
msgid ""
"An :class:`.Engine` object is instantiated publicly using the "
":func:`~sqlalchemy.create_engine` function."
msgstr ""

#: of sqlalchemy.engine.Engine:10
msgid ":doc:`/core/engines`"
msgstr ""

#: of sqlalchemy.engine.Engine:12 sqlalchemy.engine.ResultProxy.close:31
msgid ":ref:`connections_toplevel`"
msgstr ""

#: of sqlalchemy.engine.Engine.begin:1
msgid ""
"Return a context manager delivering a :class:`.Connection` with a "
":class:`.Transaction` established."
msgstr ""

#: of sqlalchemy.engine.Engine.begin:10
msgid ""
"Upon successful operation, the :class:`.Transaction` is committed.  If an"
" error is raised, the :class:`.Transaction` is rolled back."
msgstr ""

#: of sqlalchemy.engine.Engine.begin:14
msgid ""
"The ``close_with_result`` flag is normally ``False``, and indicates that "
"the :class:`.Connection` will be closed when the operation is complete."
"   When set to ``True``, it indicates the :class:`.Connection` is in "
"\"single use\" mode, where the :class:`.ResultProxy` returned by the "
"first call to :meth:`.Connection.execute` will close the "
":class:`.Connection` when that :class:`.ResultProxy` has exhausted all "
"result rows."
msgstr ""

#: of sqlalchemy.engine.Engine.begin:26
msgid ""
":meth:`.Engine.connect` - procure a :class:`.Connection` from an "
":class:`.Engine`."
msgstr ""

#: of sqlalchemy.engine.Engine.begin:29
msgid ""
":meth:`.Connection.begin` - start a :class:`.Transaction` for a "
"particular :class:`.Connection`."
msgstr ""

#: of sqlalchemy.engine.Engine.connect:1
msgid "Return a new :class:`.Connection` object."
msgstr ""

#: of sqlalchemy.engine.Engine.connect:3
msgid ""
"The :class:`.Connection` object is a facade that uses a DBAPI connection "
"internally in order to communicate with the database.  This connection is"
" procured from the connection-holding :class:`.Pool` referenced by this "
":class:`.Engine`. When the :meth:`~.Connection.close` method of the "
":class:`.Connection` object is called, the underlying DBAPI connection is"
" then returned to the connection pool, where it may be used again in a "
"subsequent call to :meth:`~.Engine.connect`."
msgstr ""

#: of sqlalchemy.engine.Engine.contextual_connect:1
msgid ""
"Return a :class:`.Connection` object which may be part of some ongoing "
"context."
msgstr ""

#: of sqlalchemy.engine.Engine.contextual_connect:4
msgid ""
"By default, this method does the same thing as :meth:`.Engine.connect`. "
"Subclasses of :class:`.Engine` may override this method to provide "
"contextual behavior."
msgstr ""

#: of sqlalchemy.engine.Engine.contextual_connect:8
msgid ""
"When True, the first :class:`.ResultProxy` created by the "
":class:`.Connection` will call the :meth:`.Connection.close` method of "
"that connection as soon as any pending result rows are exhausted. This is"
" used to supply the \"connectionless execution\" behavior provided by the"
" :meth:`.Engine.execute` method."
msgstr ""

#: of sqlalchemy.engine.Engine.dispose:1
msgid "Dispose of the connection pool used by this :class:`.Engine`."
msgstr ""

#: of sqlalchemy.engine.Engine.dispose:3
msgid ""
"This has the effect of fully closing all **currently checked in** "
"database connections.  Connections that are still checked out will "
"**not** be closed, however they will no longer be associated with this "
":class:`.Engine`, so when they are closed individually, eventually the "
":class:`.Pool` which they are associated with will be garbage collected "
"and they will be closed out fully, if not already closed on checkin."
msgstr ""

#: of sqlalchemy.engine.Engine.dispose:11
msgid ""
"A new connection pool is created immediately after the old one has been "
"disposed.   This new pool, like all SQLAlchemy connection pools, does not"
" make any actual connections to the database until one is first "
"requested, so as long as the :class:`.Engine` isn't used again, no new "
"connections will be made."
msgstr ""

#: of sqlalchemy.engine.Engine.dispose:19
msgid ":ref:`engine_disposal`"
msgstr ""

#: of sqlalchemy.engine.Engine.driver:1
msgid ""
"Driver name of the :class:`~sqlalchemy.engine.interfaces.Dialect` in use "
"by this :class:`Engine`."
msgstr ""

#: of sqlalchemy.engine.Engine.execute:3
msgid "The arguments are the same as those used by :meth:`.Connection.execute`."
msgstr ""

#: of sqlalchemy.engine.Engine.execute:6
msgid ""
"Here, a :class:`.Connection` is acquired using the "
":meth:`~.Engine.contextual_connect` method, and the statement executed "
"with that connection. The returned :class:`.ResultProxy` is flagged such "
"that when the :class:`.ResultProxy` is exhausted and its underlying "
"cursor is closed, the :class:`.Connection` created here will also be "
"closed, which allows its associated DBAPI connection resource to be "
"returned to the connection pool."
msgstr ""

#: of sqlalchemy.engine.Engine.execution_options:1
msgid ""
"Return a new :class:`.Engine` that will provide :class:`.Connection` "
"objects with the given execution options."
msgstr ""

#: of sqlalchemy.engine.Engine.execution_options:4
msgid ""
"The returned :class:`.Engine` remains related to the original "
":class:`.Engine` in that it shares the same connection pool and other "
"state:"
msgstr ""

#: of sqlalchemy.engine.Engine.execution_options:8
msgid ""
"The :class:`.Pool` used by the new :class:`.Engine` is the same instance."
"  The :meth:`.Engine.dispose` method will replace the connection pool "
"instance for the parent engine as well as this one."
msgstr ""

#: of sqlalchemy.engine.Engine.execution_options:12
msgid ""
"Event listeners are \"cascaded\" - meaning, the new :class:`.Engine` "
"inherits the events of the parent, and new events can be associated with "
"the new :class:`.Engine` individually."
msgstr ""

#: of sqlalchemy.engine.Engine.execution_options:15
msgid ""
"The logging configuration and logging_name is copied from the parent "
":class:`.Engine`."
msgstr ""

#: of sqlalchemy.engine.Engine.execution_options:18
msgid ""
"The intent of the :meth:`.Engine.execution_options` method is to "
"implement \"sharding\" schemes where multiple :class:`.Engine` objects "
"refer to the same connection pool, but are differentiated by options that"
" would be consumed by a custom event::"
msgstr ""

#: of sqlalchemy.engine.Engine.execution_options:27
msgid ""
"Above, the ``shard1`` engine serves as a factory for :class:`.Connection`"
" objects that will contain the execution option ``shard_id=shard1``, and "
"``shard2`` will produce :class:`.Connection` objects that contain the "
"execution option ``shard_id=shard2``."
msgstr ""

#: of sqlalchemy.engine.Engine.execution_options:32
msgid ""
"An event handler can consume the above execution option to perform a "
"schema switch or other operation, given a connection.  Below we emit a "
"MySQL ``use`` statement to switch databases, at the same time keeping "
"track of which database we've established using the "
":attr:`.Connection.info` dictionary, which gives us a persistent storage "
"space that follows the DBAPI connection::"
msgstr ""

#: of sqlalchemy.engine.Engine.execution_options:58
msgid ""
":meth:`.Connection.execution_options` - update execution options on a "
":class:`.Connection` object."
msgstr ""

#: of sqlalchemy.engine.Engine.execution_options:61
msgid ""
":meth:`.Engine.update_execution_options` - update the execution options "
"for a given :class:`.Engine` in place."
msgstr ""

#: of sqlalchemy.engine.Engine.has_table:1
msgid "Return True if the given backend has a table of the given name."
msgstr ""

#: of sqlalchemy.engine.Engine.has_table:5
msgid ""
":ref:`metadata_reflection_inspector` - detailed schema inspection using "
"the :class:`.Inspector` interface."
msgstr ""

#: of sqlalchemy.engine.Engine.has_table:8
msgid ""
":class:`.quoted_name` - used to pass quoting information along with a "
"schema identifier."
msgstr ""

#: of sqlalchemy.engine.Engine.name:1
msgid ""
"String name of the :class:`~sqlalchemy.engine.interfaces.Dialect` in use "
"by this :class:`Engine`."
msgstr ""

#: of sqlalchemy.engine.Engine.raw_connection:1
msgid "Return a \"raw\" DBAPI connection from the connection pool."
msgstr ""

#: of sqlalchemy.engine.Engine.raw_connection:3
msgid ""
"The returned object is a proxied version of the DBAPI connection object "
"used by the underlying driver in use. The object will have all the same "
"behavior as the real DBAPI connection, except that its ``close()`` method"
" will result in the connection being returned to the pool, rather than "
"being closed for real."
msgstr ""

#: of sqlalchemy.engine.Engine.raw_connection:10
msgid ""
"This method provides direct DBAPI connection access for special "
"situations when the API provided by :class:`.Connection` is not needed."
"   When a :class:`.Connection` object is already present, the DBAPI "
"connection is available using the :attr:`.Connection.connection` "
"accessor."
msgstr ""

#: of sqlalchemy.engine.Engine.run_callable:7
msgid ""
"This function, along with :meth:`.Connection.run_callable`, allows a "
"function to be run with a :class:`.Connection` or :class:`.Engine` object"
" without the need to know which one is being dealt with."
msgstr ""

#: of sqlalchemy.engine.Engine.table_names:1
msgid "Return a list of all table names available in the database."
msgstr ""

#: of sqlalchemy.engine.Engine.table_names:3
msgid "Optional, retrieve names from a non-default schema."
msgstr ""

#: of sqlalchemy.engine.Engine.table_names:5
msgid ""
"Optional, use a specified connection. Default is the "
"``contextual_connect`` for this ``Engine``."
msgstr ""

#: of sqlalchemy.engine.Engine.transaction:3
msgid ""
"The function is passed a :class:`.Connection` newly procured from "
":meth:`.Engine.contextual_connect` as the first argument, followed by the"
" given \\*args and \\**kwargs."
msgstr ""

#: of sqlalchemy.engine.Engine.transaction:7
msgid "e.g.::"
msgstr ""

#: of sqlalchemy.engine.Engine.transaction:22
msgid ""
"The :meth:`.transaction` method is superseded by the usage of the Python "
"``with:`` statement, which can be used with :meth:`.Engine.begin`::"
msgstr ""

#: of sqlalchemy.engine.Engine.transaction:34
msgid ""
":meth:`.Connection.transaction` - connection-level version of "
":meth:`.Engine.transaction`"
msgstr ""

#: of sqlalchemy.engine.Engine.update_execution_options:1
msgid "Update the default execution_options dictionary of this :class:`.Engine`."
msgstr ""

#: of sqlalchemy.engine.Engine.update_execution_options:4
msgid ""
"The given keys/values in \\**opt are added to the default execution "
"options that will be used for all connections.  The initial contents of "
"this dictionary can be sent via the ``execution_options`` parameter to "
":func:`.create_engine`."
msgstr ""

#: of sqlalchemy.engine.Engine.update_execution_options:12
msgid ":meth:`.Connection.execution_options`"
msgstr ""

#: of sqlalchemy.engine.Engine.update_execution_options:14
msgid ":meth:`.Engine.execution_options`"
msgstr ""

#: of sqlalchemy.engine.ExceptionContext:1
msgid "Encapsulate information about an error condition in progress."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext:3
msgid ""
"This object exists solely to be passed to the "
":meth:`.ConnectionEvents.handle_error` event, supporting an interface "
"that can be extended without backwards-incompatibility."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.chained_exception:1
msgid ""
"The exception that was returned by the previous handler in the exception "
"chain, if any."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.chained_exception:4
msgid ""
"If present, this exception will be the one ultimately raised by "
"SQLAlchemy unless a subsequent handler replaces it."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.chained_exception:7
#: sqlalchemy.engine.ExceptionContext.cursor:3
#: sqlalchemy.engine.ExceptionContext.execution_context:16
#: sqlalchemy.engine.ExceptionContext.parameters:3
#: sqlalchemy.engine.ExceptionContext.statement:3
msgid "May be None."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.connection:1
msgid "The :class:`.Connection` in use during the exception."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.connection:3
msgid ""
"This member is present, except in the case of a failure when first "
"connecting."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.connection:8
msgid ":attr:`.ExceptionContext.engine`"
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.cursor:1
msgid "The DBAPI cursor object."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.engine:1
msgid "The :class:`.Engine` in use during the exception."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.engine:3
msgid ""
"This member should always be present, even in the case of a failure when "
"first connecting."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.execution_context:1
msgid ""
"The :class:`.ExecutionContext` corresponding to the execution operation "
"in progress."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.execution_context:4
msgid ""
"This is present for statement execution operations, but not for "
"operations such as transaction begin/end.  It also is not present when "
"the exception was raised before the :class:`.ExecutionContext` could be "
"constructed."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.execution_context:9
msgid ""
"Note that the :attr:`.ExceptionContext.statement` and "
":attr:`.ExceptionContext.parameters` members may represent a different "
"value than that of the :class:`.ExecutionContext`, potentially in the "
"case where a :meth:`.ConnectionEvents.before_cursor_execute` event or "
"similar modified the statement/parameters to be sent."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.invalidate_pool_on_disconnect:1
msgid ""
"Represent whether all connections in the pool should be invalidated when "
"a \"disconnect\" condition is in effect."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.invalidate_pool_on_disconnect:4
msgid ""
"Setting this flag to False within the scope of the "
":meth:`.ConnectionEvents.handle_error` event will have the effect such "
"that the full collection of connections in the pool will not be "
"invalidated during a disconnect; only the current connection that is the "
"subject of the error will actually be invalidated."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.invalidate_pool_on_disconnect:10
msgid ""
"The purpose of this flag is for custom disconnect-handling schemes where "
"the invalidation of other connections in the pool is to be performed "
"based on other conditions, or even on a per-connection basis."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.is_disconnect:1
msgid ""
"Represent whether the exception as occurred represents a \"disconnect\" "
"condition."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.is_disconnect:4
msgid ""
"This flag will always be True or False within the scope of the "
":meth:`.ConnectionEvents.handle_error` handler."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.is_disconnect:7
msgid ""
"SQLAlchemy will defer to this flag in order to determine whether or not "
"the connection should be invalidated subsequently.    That is, by "
"assigning to this flag, a \"disconnect\" event which then results in a "
"connection and pool invalidation can be invoked or prevented by changing "
"this flag."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.original_exception:1
msgid "The exception object which was caught."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.original_exception:3
msgid "This member is always present."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.parameters:1
msgid "Parameter collection that was emitted directly to the DBAPI."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.sqlalchemy_exception:1
msgid ""
"The :class:`sqlalchemy.exc.StatementError` which wraps the original, and "
"will be raised if exception handling is not circumvented by the event."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.sqlalchemy_exception:4
msgid ""
"May be None, as not all exception types are wrapped by SQLAlchemy. For "
"DBAPI-level exceptions that subclass the dbapi's Error class, this field "
"will always be present."
msgstr ""

#: of sqlalchemy.engine.ExceptionContext.statement:1
msgid "String SQL statement that was emitted directly to the DBAPI."
msgstr ""

#: of sqlalchemy.engine.NestedTransaction:1
msgid "Represent a 'nested', or SAVEPOINT transaction."
msgstr ""

#: of sqlalchemy.engine.NestedTransaction:3
msgid ""
"A new :class:`.NestedTransaction` object may be procured using the "
":meth:`.Connection.begin_nested` method."
msgstr ""

#: of sqlalchemy.engine.NestedTransaction:6
msgid "The interface is the same as that of :class:`.Transaction`."
msgstr ""

#: of sqlalchemy.engine.ResultProxy:1
msgid "Wraps a DB-API cursor object to provide easier access to row columns."
msgstr ""

#: of sqlalchemy.engine.ResultProxy:3
msgid ""
"Individual columns may be accessed by their integer position, case-"
"insensitive column name, or by ``schema.Column`` object. e.g.::"
msgstr ""

#: of sqlalchemy.engine.ResultProxy:15
msgid ""
"``ResultProxy`` also handles post-processing of result column data using "
"``TypeEngine`` objects, which are referenced from the originating SQL "
"statement that produced this result set."
msgstr ""

#: of sqlalchemy.engine.ResultProxy._cursor_description:1
msgid "May be overridden by subclasses."
msgstr ""

#: of sqlalchemy.engine.ResultProxy._soft_close:1
msgid "Soft close this :class:`.ResultProxy`."
msgstr ""

#: of sqlalchemy.engine.ResultProxy._soft_close:3
msgid ""
"This releases all DBAPI cursor resources, but leaves the ResultProxy "
"\"open\" from a semantic perspective, meaning the fetchXXX() methods will"
" continue to return empty results."
msgstr ""

#: of sqlalchemy.engine.ResultProxy._soft_close:7
msgid "This method is called automatically when:"
msgstr ""

#: of sqlalchemy.engine.ResultProxy._soft_close:9
msgid "all result rows are exhausted using the fetchXXX() methods."
msgstr ""

#: of sqlalchemy.engine.ResultProxy._soft_close:10
msgid "cursor.description is None."
msgstr ""

#: of sqlalchemy.engine.ResultProxy._soft_close:12
msgid ""
"This method is **not public**, but is documented in order to clarify the "
"\"autoclose\" process used."
msgstr ""

#: of sqlalchemy.engine.ResultProxy._soft_close:19
msgid ":meth:`.ResultProxy.close`"
msgstr ""

#: of sqlalchemy.engine.ResultProxy.close:1
msgid "Close this ResultProxy."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.close:3
msgid ""
"This closes out the underlying DBAPI cursor corresonding to the statement"
" execution, if one is still present.  Note that the DBAPI cursor is "
"automatically released when the :class:`.ResultProxy` exhausts all "
"available rows.  :meth:`.ResultProxy.close` is generally an optional "
"method except in the case when discarding a :class:`.ResultProxy` that "
"still has additional rows pending for fetch."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.close:10
msgid ""
"In the case of a result that is the product of :ref:`connectionless "
"execution <dbengine_implicit>`, the underlying :class:`.Connection` "
"object is also closed, which :term:`releases` DBAPI connection resources."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.close:15
msgid ""
"After this method is called, it is no longer valid to call upon the fetch"
" methods, which will raise a :class:`.ResourceClosedError` on subsequent "
"use."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.close:19
msgid ""
"- the :meth:`.ResultProxy.close` method has been separated out from the "
"process that releases the underlying DBAPI cursor resource.   The \"auto "
"close\" feature of the :class:`.Connection` now performs a so-called "
"\"soft close\", which releases the underlying DBAPI cursor, but allows "
"the :class:`.ResultProxy` to still behave as an open-but-exhausted result"
" set; the actual :meth:`.ResultProxy.close` method is never called.    It"
" is still safe to discard a :class:`.ResultProxy` that has been fully "
"exhausted without calling this method."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.close:33
msgid ":meth:`.ResultProxy._soft_close`"
msgstr ""

#: of sqlalchemy.engine.ResultProxy.fetchall:1
msgid "Fetch all rows, just like DB-API ``cursor.fetchall()``."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.fetchall:3
#: sqlalchemy.engine.ResultProxy.fetchmany:4
#: sqlalchemy.engine.ResultProxy.fetchone:3
msgid ""
"After all rows have been exhausted, the underlying DBAPI cursor resource "
"is released, and the object may be safely discarded."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.fetchall:7
msgid ""
"Subsequent calls to :meth:`.ResultProxy.fetchall` will return an empty "
"list.   After the :meth:`.ResultProxy.close` method is called, the method"
" will raise :class:`.ResourceClosedError`."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.fetchall:11
#: sqlalchemy.engine.ResultProxy.fetchmany:13
#: sqlalchemy.engine.ResultProxy.fetchone:12
msgid ""
"- Added \"soft close\" behavior which allows the result to be used in an "
"\"exhausted\" state prior to calling the :meth:`.ResultProxy.close` "
"method."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.fetchmany:1
msgid ""
"Fetch many rows, just like DB-API "
"``cursor.fetchmany(size=cursor.arraysize)``."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.fetchmany:8
msgid ""
"Calls to :meth:`.ResultProxy.fetchmany` after all rows have been "
"exhausted will return an empty list.   After the "
":meth:`.ResultProxy.close` method is called, the method will raise "
":class:`.ResourceClosedError`."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.fetchone:1
msgid "Fetch one row, just like DB-API ``cursor.fetchone()``."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.fetchone:7
msgid ""
"Calls to :meth:`.ResultProxy.fetchone` after all rows have been exhausted"
" will return ``None``. After the :meth:`.ResultProxy.close` method is "
"called, the method will raise :class:`.ResourceClosedError`."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.first:1
msgid "Fetch the first row and then close the result set unconditionally."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.first:3
#: sqlalchemy.engine.ResultProxy.scalar:3
msgid "Returns None if no row is present."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.first:5
#: sqlalchemy.engine.ResultProxy.scalar:5
msgid ""
"After calling this method, the object is fully closed, e.g. the "
":meth:`.ResultProxy.close` method will have been called."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.inserted_primary_key:1
msgid "Return the primary key for the row just inserted."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.inserted_primary_key:3
msgid ""
"The return value is a list of scalar values corresponding to the list of "
"primary key columns in the target table."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.inserted_primary_key:7
msgid ""
"This only applies to single row :func:`.insert` constructs which did not "
"explicitly specify :meth:`.Insert.returning`."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.inserted_primary_key:11
msgid ""
"Note that primary key columns which specify a server_default clause, or "
"otherwise do not qualify as \"autoincrement\" columns (see the notes at "
":class:`.Column`), and were generated using the database-side default, "
"will appear in this list as ``None`` unless the backend supports "
"\"returning\" and the insert statement executed with the \"implicit "
"returning\" enabled."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.inserted_primary_key:20
#: sqlalchemy.engine.ResultProxy.last_inserted_params:4
msgid ""
"Raises :class:`~sqlalchemy.exc.InvalidRequestError` if the executed "
"statement is not a compiled expression construct or is not an insert() "
"construct."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.is_insert:1
msgid ""
"True if this :class:`.ResultProxy` is the result of a executing an "
"expression language compiled :func:`.expression.insert` construct."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.is_insert:5
msgid ""
"When True, this implies that the :attr:`inserted_primary_key` attribute "
"is accessible, assuming the statement did not include a user defined "
"\"returning\" construct."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.keys:1
msgid "Return the current set of string keys for rows."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.last_inserted_params:1
msgid "Return the collection of inserted parameters from this execution."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.last_updated_params:1
msgid "Return the collection of updated parameters from this execution."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.last_updated_params:4
msgid ""
"Raises :class:`~sqlalchemy.exc.InvalidRequestError` if the executed "
"statement is not a compiled expression construct or is not an update() "
"construct."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.lastrow_has_defaults:1
msgid ""
"Return ``lastrow_has_defaults()`` from the underlying "
":class:`.ExecutionContext`."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.lastrow_has_defaults:4
#: sqlalchemy.engine.ResultProxy.postfetch_cols:4
#: sqlalchemy.engine.ResultProxy.prefetch_cols:4
msgid "See :class:`.ExecutionContext` for details."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.lastrowid:1
msgid "return the 'lastrowid' accessor on the DBAPI cursor."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.lastrowid:3
msgid ""
"This is a DBAPI specific method and is only functional for those backends"
" which support it, for statements where it is appropriate.  It's behavior"
" is not consistent across backends."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.lastrowid:8
msgid ""
"Usage of this method is normally unnecessary when using insert() "
"expression constructs; the :attr:`~ResultProxy.inserted_primary_key` "
"attribute provides a tuple of primary key values for a newly inserted "
"row, regardless of database backend."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.next:1
msgid "Implement the next() protocol."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.postfetch_cols:1
msgid ""
"Return ``postfetch_cols()`` from the underlying "
":class:`.ExecutionContext`."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.postfetch_cols:6
#: sqlalchemy.engine.ResultProxy.prefetch_cols:6
msgid ""
"Raises :class:`~sqlalchemy.exc.InvalidRequestError` if the executed "
"statement is not a compiled expression construct or is not an insert() or"
" update() construct."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.prefetch_cols:1
msgid "Return ``prefetch_cols()`` from the underlying :class:`.ExecutionContext`."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.returned_defaults:1
msgid ""
"Return the values of default columns that were fetched using the "
":meth:`.ValuesBase.return_defaults` feature."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.returned_defaults:4
msgid ""
"The value is an instance of :class:`.RowProxy`, or ``None`` if "
":meth:`.ValuesBase.return_defaults` was not used or if the backend does "
"not support RETURNING."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.returned_defaults:12
msgid ":meth:`.ValuesBase.return_defaults`"
msgstr ""

#: of sqlalchemy.engine.ResultProxy.returns_rows:1
msgid "True if this :class:`.ResultProxy` returns rows."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.returns_rows:3
msgid ""
"I.e. if it is legal to call the methods :meth:`~.ResultProxy.fetchone`, "
":meth:`~.ResultProxy.fetchmany` :meth:`~.ResultProxy.fetchall`."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.rowcount:1
msgid "Return the 'rowcount' for this result."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.rowcount:3
msgid ""
"The 'rowcount' reports the number of rows *matched* by the WHERE "
"criterion of an UPDATE or DELETE statement."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.rowcount:8
msgid "Notes regarding :attr:`.ResultProxy.rowcount`:"
msgstr ""

#: of sqlalchemy.engine.ResultProxy.rowcount:11
msgid ""
"This attribute returns the number of rows *matched*, which is not "
"necessarily the same as the number of rows that were actually *modified* "
"- an UPDATE statement, for example, may have no net change on a given row"
" if the SET values given are the same as those present in the row "
"already. Such a row would be matched but not modified. On backends that "
"feature both styles, such as MySQL, rowcount is configured by default to "
"return the match count in all cases."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.rowcount:21
msgid ""
":attr:`.ResultProxy.rowcount` is *only* useful in conjunction with an "
"UPDATE or DELETE statement.  Contrary to what the Python DBAPI says, it "
"does *not* return the number of rows available from the results of a "
"SELECT statement as DBAPIs cannot support this functionality when rows "
"are unbuffered."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.rowcount:28
msgid ""
":attr:`.ResultProxy.rowcount` may not be fully implemented by all "
"dialects.  In particular, most DBAPIs do not support an aggregate "
"rowcount result from an executemany call. The "
":meth:`.ResultProxy.supports_sane_rowcount` and "
":meth:`.ResultProxy.supports_sane_multi_rowcount` methods will report "
"from the dialect if each usage is known to be supported."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.rowcount:36
msgid "Statements that use RETURNING may not return a correct rowcount."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.scalar:1
msgid "Fetch the first column of the first row, and close the result set."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.supports_sane_multi_rowcount:1
msgid "Return ``supports_sane_multi_rowcount`` from the dialect."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.supports_sane_multi_rowcount:3
#: sqlalchemy.engine.ResultProxy.supports_sane_rowcount:3
msgid "See :attr:`.ResultProxy.rowcount` for background."
msgstr ""

#: of sqlalchemy.engine.ResultProxy.supports_sane_rowcount:1
msgid "Return ``supports_sane_rowcount`` from the dialect."
msgstr ""

#: of sqlalchemy.engine.RowProxy:1
msgid "Proxy values from a single cursor row."
msgstr ""

#: of sqlalchemy.engine.RowProxy:3
msgid ""
"Mostly follows \"ordered dictionary\" behavior, mapping result values to "
"the string-based column name, the integer position of the result in the "
"row, as well as Column instances which can be mapped to the original "
"Columns that produced this result set (for results that correspond to "
"constructed SQL expressions)."
msgstr ""

#: of sqlalchemy.engine.RowProxy.has_key:1
msgid "Return True if this RowProxy contains the given key."
msgstr ""

#: of sqlalchemy.engine.RowProxy.items:1
msgid "Return a list of tuples, each tuple containing a key/value pair."
msgstr ""

#: of sqlalchemy.engine.RowProxy.keys:1
msgid "Return the list of keys as strings represented by this RowProxy."
msgstr ""

#: of sqlalchemy.engine.Transaction:1
msgid "Represent a database transaction in progress."
msgstr ""

#: of sqlalchemy.engine.Transaction:3
msgid ""
"The :class:`.Transaction` object is procured by calling the "
":meth:`~.Connection.begin` method of :class:`.Connection`::"
msgstr ""

#: of sqlalchemy.engine.Transaction:14
msgid ""
"The object provides :meth:`.rollback` and :meth:`.commit` methods in "
"order to control transaction boundaries.  It also implements a context "
"manager interface so that the Python ``with`` statement can be used with "
"the :meth:`.Connection.begin` method::"
msgstr ""

#: of sqlalchemy.engine.Transaction:23
msgid "The Transaction object is **not** threadsafe."
msgstr ""

#: of sqlalchemy.engine.Transaction:25
msgid ""
"See also:  :meth:`.Connection.begin`, :meth:`.Connection.begin_twophase`,"
" :meth:`.Connection.begin_nested`."
msgstr ""

#: of sqlalchemy.engine.Transaction.close:1
msgid "Close this :class:`.Transaction`."
msgstr ""

#: of sqlalchemy.engine.Transaction.close:3
msgid ""
"If this transaction is the base transaction in a begin/commit nesting, "
"the transaction will rollback().  Otherwise, the method returns."
msgstr ""

#: of sqlalchemy.engine.Transaction.close:7
msgid ""
"This is used to cancel a Transaction without affecting the scope of an "
"enclosing transaction."
msgstr ""

#: of sqlalchemy.engine.Transaction.commit:1
msgid "Commit this :class:`.Transaction`."
msgstr ""

#: of sqlalchemy.engine.Transaction.rollback:1
msgid "Roll back this :class:`.Transaction`."
msgstr ""

#: of sqlalchemy.engine.TwoPhaseTransaction:1
msgid "Represent a two-phase transaction."
msgstr ""

#: of sqlalchemy.engine.TwoPhaseTransaction:3
msgid ""
"A new :class:`.TwoPhaseTransaction` object may be procured using the "
":meth:`.Connection.begin_twophase` method."
msgstr ""

#: of sqlalchemy.engine.TwoPhaseTransaction:6
msgid ""
"The interface is the same as that of :class:`.Transaction` with the "
"addition of the :meth:`prepare` method."
msgstr ""

#: of sqlalchemy.engine.TwoPhaseTransaction.prepare:1
msgid "Prepare this :class:`.TwoPhaseTransaction`."
msgstr ""

#: of sqlalchemy.engine.TwoPhaseTransaction.prepare:3
msgid "After a PREPARE, the transaction can be committed."
msgstr ""

