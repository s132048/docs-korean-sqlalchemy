# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: SQLAlchemy 1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-02-21 14:32+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../core/pooling.rst:4
msgid "Connection Pooling"
msgstr ""

#: ../../core/pooling.rst:8
msgid ""
"A connection pool is a standard technique used to maintain long running "
"connections in memory for efficient re-use, as well as to provide "
"management for the total number of connections an application might use "
"simultaneously."
msgstr ""

#: ../../core/pooling.rst:14
msgid ""
"Particularly for server-side web applications, a connection pool is the "
"standard way to maintain a \"pool\" of active database connections in "
"memory which are reused across requests."
msgstr ""

#: ../../core/pooling.rst:19
msgid ""
"SQLAlchemy includes several connection pool implementations which "
"integrate with the :class:`.Engine`.  They can also be used directly for "
"applications that want to add pooling to an otherwise plain DBAPI "
"approach."
msgstr ""

#: ../../core/pooling.rst:25
msgid "Connection Pool Configuration"
msgstr ""

#: ../../core/pooling.rst:27
msgid ""
"The :class:`~.engine.Engine` returned by the "
":func:`~sqlalchemy.create_engine` function in most cases has a "
":class:`.QueuePool` integrated, pre-configured with reasonable pooling "
"defaults.  If you're reading this section only to learn how to enable "
"pooling - congratulations! You're already done."
msgstr ""

#: ../../core/pooling.rst:33
msgid ""
"The most common :class:`.QueuePool` tuning parameters can be passed "
"directly to :func:`~sqlalchemy.create_engine` as keyword arguments: "
"``pool_size``, ``max_overflow``, ``pool_recycle`` and ``pool_timeout``.  "
"For example::"
msgstr ""

#: ../../core/pooling.rst:41
msgid ""
"In the case of SQLite, the :class:`.SingletonThreadPool` or "
":class:`.NullPool` are selected by the dialect to provide greater "
"compatibility with SQLite's threading and locking model, as well as to "
"provide a reasonable default behavior to SQLite \"memory\" databases, "
"which maintain their entire dataset within the scope of a single "
"connection."
msgstr ""

#: ../../core/pooling.rst:48
msgid ""
"All SQLAlchemy pool implementations have in common that none of them "
"\"pre create\" connections - all implementations wait until first use "
"before creating a connection.   At that point, if no additional "
"concurrent checkout requests for more connections are made, no additional"
" connections are created.   This is why it's perfectly fine for "
":func:`.create_engine` to default to using a :class:`.QueuePool` of size "
"five without regard to whether or not the application really needs five "
"connections queued up - the pool would only grow to that size if the "
"application actually used five connections concurrently, in which case "
"the usage of a small pool is an entirely appropriate default behavior."
msgstr ""

#: ../../core/pooling.rst:62
msgid "Switching Pool Implementations"
msgstr ""

#: ../../core/pooling.rst:64
msgid ""
"The usual way to use a different kind of pool with :func:`.create_engine`"
" is to use the ``poolclass`` argument.   This argument accepts a class "
"imported from the ``sqlalchemy.pool`` module, and handles the details of "
"building the pool for you.   Common options include specifying "
":class:`.QueuePool` with SQLite::"
msgstr ""

#: ../../core/pooling.rst:73
msgid "Disabling pooling using :class:`.NullPool`::"
msgstr ""

#: ../../core/pooling.rst:81
msgid "Using a Custom Connection Function"
msgstr ""

#: ../../core/pooling.rst:83
msgid ""
"All :class:`.Pool` classes accept an argument ``creator`` which is a "
"callable that creates a new connection.  :func:`.create_engine` accepts "
"this function to pass onto the pool via an argument of the same name::"
msgstr ""

#: ../../core/pooling.rst:98
msgid ""
"For most \"initialize on connection\" routines, it's more convenient to "
"use the :class:`.PoolEvents` event hooks, so that the usual URL argument "
"to :func:`.create_engine` is still usable.  ``creator`` is there as a "
"last resort for when a DBAPI has some form of ``connect`` that is not at "
"all supported by SQLAlchemy."
msgstr ""

#: ../../core/pooling.rst:105
msgid "Constructing a Pool"
msgstr ""

#: ../../core/pooling.rst:107
msgid ""
"To use a :class:`.Pool` by itself, the ``creator`` function is the only "
"argument that's required and is passed first, followed by any additional "
"options::"
msgstr ""

#: ../../core/pooling.rst:120
msgid ""
"DBAPI connections can then be procured from the pool using the "
":meth:`.Pool.connect` function.  The return value of this method is a "
"DBAPI connection that's contained within a transparent proxy::"
msgstr ""

#: ../../core/pooling.rst:131
msgid ""
"The purpose of the transparent proxy is to intercept the ``close()`` "
"call, such that instead of the DBAPI connection being closed, it is "
"returned to the pool::"
msgstr ""

#: ../../core/pooling.rst:139
msgid ""
"The proxy also returns its contained DBAPI connection to the pool when it"
" is garbage collected, though it's not deterministic in Python that this "
"occurs immediately (though it is typical with cPython)."
msgstr ""

#: ../../core/pooling.rst:144
msgid ""
"The ``close()`` step also performs the important step of calling the "
"``rollback()`` method of the DBAPI connection.   This is so that any "
"existing transaction on the connection is removed, not only ensuring that"
" no existing state remains on next usage, but also so that table and row "
"locks are released as well as that any isolated data snapshots are "
"removed.   This behavior can be disabled using the ``reset_on_return`` "
"option of :class:`.Pool`."
msgstr ""

#: ../../core/pooling.rst:152
msgid ""
"A particular pre-created :class:`.Pool` can be shared with one or more "
"engines by passing it to the ``pool`` argument of "
":func:`.create_engine`::"
msgstr ""

#: ../../core/pooling.rst:158
msgid "Pool Events"
msgstr ""

#: ../../core/pooling.rst:160
msgid ""
"Connection pools support an event interface that allows hooks to execute "
"upon first connect, upon each new connection, and upon checkout and "
"checkin of connections.   See :class:`.PoolEvents` for details."
msgstr ""

#: ../../core/pooling.rst:167
msgid "Dealing with Disconnects"
msgstr ""

#: ../../core/pooling.rst:169
msgid ""
"The connection pool has the ability to refresh individual connections as "
"well as its entire set of connections, setting the previously pooled "
"connections as \"invalid\".   A common use case is allow the connection "
"pool to gracefully recover when the database server has been restarted, "
"and all previously established connections are no longer functional.   "
"There are two approaches to this."
msgstr ""

#: ../../core/pooling.rst:178
msgid "Disconnect Handling - Pessimistic"
msgstr ""

#: ../../core/pooling.rst:180
msgid ""
"The pessimistic approach refers to emitting a test statement on the SQL "
"connection at the start of each connection pool checkout, to test that "
"the database connection is still viable.   Typically, this is a simple "
"statement like \"SELECT 1\", but may also make use of some DBAPI-specific"
" method to test the connection for liveness."
msgstr ""

#: ../../core/pooling.rst:186
msgid ""
"The approach adds a small bit of overhead to the connection checkout "
"process, however is otherwise the most simple and reliable approach to "
"completely eliminating database errors due to stale pooled connections."
"   The calling application does not need to be concerned about organizing"
" operations to be able to recover from stale connections checked out from"
" the pool."
msgstr ""

#: ../../core/pooling.rst:192
msgid ""
"It is critical to note that the pre-ping approach **does not accommodate "
"for connections dropped in the middle of transactions or other SQL "
"operations**. If the database becomes unavailable while a transaction is "
"in progress, the transaction will be lost and the database error will be "
"raised.   While the :class:`.Connection` object will detect a "
"\"disconnect\" situation and recycle the connection as well as invalidate"
" the rest of the connection pool when this condition occurs, the "
"individual operation where the exception was raised will be lost, and "
"it's up to the application to either abandon the operation, or retry the "
"whole transaction again."
msgstr ""

#: ../../core/pooling.rst:203
msgid ""
"Pessimistic testing of connections upon checkout is achievable by using "
"the :paramref:`.Pool.pre_ping` argument, available from "
":func:`.create_engine` via the :paramref:`.create_engine.pool_pre_ping` "
"argument::"
msgstr ""

#: ../../core/pooling.rst:209
msgid ""
"The \"pre ping\" feature will normally emit SQL equivalent to \"SELECT "
"1\" each time a connection is checked out from the pool; if an error is "
"raised that is detected as a \"disconnect\" situation, the connection "
"will be immediately recycled, and all other pooled connections older than"
" the current time are invalidated, so that the next time they are checked"
" out, they will also be recycled before use."
msgstr ""

#: ../../core/pooling.rst:215
msgid ""
"If the database is still not available when \"pre ping\" runs, then the "
"initial connect will fail and the error for failure to connect will be "
"propagated normally.  In the uncommon situation that the database is "
"available for connections, but is not able to respond to a \"ping\", the "
"\"pre_ping\" will try up to three times before giving up, propagating the"
" database error last received."
msgstr ""

#: ../../core/pooling.rst:223
msgid ""
"the \"SELECT 1\" emitted by \"pre-ping\" is invoked within the scope of "
"the connection pool / dialect, using a very short codepath for minimal "
"Python latency.   As such, this statement is **not logged in the SQL echo"
" output**, and will not show up in SQLAlchemy's engine logging."
msgstr ""

#: ../../core/pooling.rst:228
msgid "Added \"pre-ping\" capability to the :class:`.Pool` class."
msgstr ""

#: ../../core/pooling.rst:232
msgid "Custom / Legacy Pessimistic Ping"
msgstr ""

#: ../../core/pooling.rst:234
msgid ""
"Before :paramref:`.create_engine.pool_pre_ping` was added, the \"pre-"
"ping\" approach historically has been performed manually using the "
":meth:`.ConnectionEvents.engine_connect` engine event. The most common "
"recipe for this is below, for reference purposes in case an application "
"is already using such a recipe, or special behaviors are needed::"
msgstr ""

#: ../../core/pooling.rst:282
msgid ""
"The above recipe has the advantage that we are making use of SQLAlchemy's"
" facilities for detecting those DBAPI exceptions that are known to "
"indicate a \"disconnect\" situation, as well as the :class:`.Engine` "
"object's ability to correctly invalidate the current connection pool when"
" this condition occurs and allowing the current :class:`.Connection` to "
"re-validate onto a new DBAPI connection."
msgstr ""

#: ../../core/pooling.rst:291
msgid "Disconnect Handling - Optimistic"
msgstr ""

#: ../../core/pooling.rst:293
msgid ""
"When pessimistic handling is not employed, as well as when the database "
"is shutdown and/or restarted in the middle of a connection's period of "
"use within a transaction, the other approach to dealing with stale / "
"closed connections is to let SQLAlchemy handle disconnects as  they "
"occur, at which point all connections in the pool are invalidated, "
"meaning they are assumed to be stale and will be refreshed upon next "
"checkout.  This behavior assumes the :class:`.Pool` is used in "
"conjunction with a :class:`.Engine`. The :class:`.Engine` has logic which"
" can detect disconnection events and refresh the pool automatically."
msgstr ""

#: ../../core/pooling.rst:303
msgid ""
"When the :class:`.Connection` attempts to use a DBAPI connection, and an "
"exception is raised that corresponds to a \"disconnect\" event, the "
"connection is invalidated. The :class:`.Connection` then calls the "
":meth:`.Pool.recreate` method, effectively invalidating all connections "
"not currently checked out so that they are replaced with new ones upon "
"next checkout.  This flow is illustrated by the code example below::"
msgstr ""

#: ../../core/pooling.rst:328
msgid ""
"The above example illustrates that no special intervention is needed to "
"refresh the pool, which continues normally after a disconnection event is"
" detected.   However, one database exception is raised, per each "
"connection that is in use while the database unavailability event "
"occurred. In a typical web application using an ORM Session, the above "
"condition would correspond to a single request failing with a 500 error, "
"then the web application continuing normally beyond that.   Hence the "
"approach is \"optimistic\" in that frequent database restarts are not "
"anticipated."
msgstr ""

#: ../../core/pooling.rst:340
msgid "Setting Pool Recycle"
msgstr ""

#: ../../core/pooling.rst:342
msgid ""
"An additional setting that can augment the \"optimistic\" approach is to "
"set the pool recycle parameter.   This parameter prevents the pool from "
"using a particular connection that has passed a certain age, and is "
"appropriate for database backends such as MySQL that automatically close "
"connections that have been stale after a particular period of time::"
msgstr ""

#: ../../core/pooling.rst:351
msgid ""
"Above, any DBAPI connection that has been open for more than one hour "
"will be invalidated and replaced, upon next checkout.   Note that the "
"invalidation **only** occurs during checkout - not on any connections "
"that are held in a checked out state.     ``pool_recycle`` is a function "
"of the :class:`.Pool` itself, independent of whether or not an "
":class:`.Engine` is in use."
msgstr ""

#: ../../core/pooling.rst:360
msgid "More on Invalidation"
msgstr ""

#: ../../core/pooling.rst:362
msgid ""
"The :class:`.Pool` provides \"connection invalidation\" services which "
"allow both explicit invalidation of a connection as well as automatic "
"invalidation in response to conditions that are determined to render a "
"connection unusable."
msgstr ""

#: ../../core/pooling.rst:366
msgid ""
"\"Invalidation\" means that a particular DBAPI connection is removed from"
" the pool and discarded.  The ``.close()`` method is called on this "
"connection if it is not clear that the connection itself might not be "
"closed, however if this method fails, the exception is logged but the "
"operation still proceeds."
msgstr ""

#: ../../core/pooling.rst:371
msgid ""
"When using a :class:`.Engine`, the :meth:`.Connection.invalidate` method "
"is the usual entrypoint to explicit invalidation.   Other conditions by "
"which a DBAPI connection might be invalidated include:"
msgstr ""

#: ../../core/pooling.rst:375
msgid ""
"a DBAPI exception such as :class:`.OperationalError`, raised when a "
"method like ``connection.execute()`` is called, is detected as indicating"
" a so-called \"disconnect\" condition.   As the Python DBAPI provides no "
"standard system for determining the nature of an exception, all "
"SQLAlchemy dialects include a system called ``is_disconnect()`` which "
"will examine the contents of an exception object, including the string "
"message and any potential error codes included with it, in order to "
"determine if this exception indicates that the connection is no longer "
"usable.  If this is the case, the :meth:`._ConnectionFairy.invalidate` "
"method is called and the DBAPI connection is then discarded."
msgstr ""

#: ../../core/pooling.rst:386
msgid ""
"When the connection is returned to the pool, and calling the "
"``connection.rollback()`` or ``connection.commit()`` methods, as dictated"
" by the pool's \"reset on return\" behavior, throws an exception. A final"
" attempt at calling ``.close()`` on the connection will be made, and it "
"is then discarded."
msgstr ""

#: ../../core/pooling.rst:392
msgid ""
"When a listener implementing :meth:`.PoolEvents.checkout` raises the "
":class:`~sqlalchemy.exc.DisconnectionError` exception, indicating that "
"the connection won't be usable and a new connection attempt needs to be "
"made."
msgstr ""

#: ../../core/pooling.rst:396
msgid ""
"All invalidations which occur will invoke the "
":meth:`.PoolEvents.invalidate` event."
msgstr ""

#: ../../core/pooling.rst:402
msgid "Using FIFO vs. LIFO"
msgstr ""

#: ../../core/pooling.rst:404
msgid ""
"The :class:`.QueuePool` class features a flag called "
":paramref:`.QueuePool.use_lifo`, which can also be accessed from "
":func:`.create_engine` via the flag "
":paramref:`.create_engine.pool_use_lifo`. Setting this flag to ``True`` "
"causes the pool's \"queue\" behavior to instead be that of a \"stack\", "
"e.g. the last connection to be returned to the pool is the first one to "
"be used on the next request. In contrast to the pool's long- standing "
"behavior of first-in-first-out, which produces a round-robin effect of "
"using each connection in the pool in series, lifo mode allows excess "
"connections to remain idle in the pool, allowing server-side timeout "
"schemes to close these connections out.   The difference between FIFO and"
" LIFO is basically whether or not its desirable for the pool to keep a "
"full set of connections ready to go even during idle periods::"
msgstr ""

#: ../../core/pooling.rst:420
msgid ""
"Above, we also make use of the :paramref:`.create_engine.pool_pre_ping` "
"flag so that connections which are closed from the server side are "
"gracefully handled by the connection pool and replaced with a new "
"connection."
msgstr ""

#: ../../core/pooling.rst:424
msgid "Note that the flag only applies to :class:`.QueuePool` use."
msgstr ""

#: ../../core/pooling.rst:430 of sqlalchemy.pool.QueuePool.__init__:44
msgid ":ref:`pool_disconnects`"
msgstr ""

#: ../../core/pooling.rst:435
msgid "Using Connection Pools with Multiprocessing"
msgstr ""

#: ../../core/pooling.rst:437
msgid ""
"It's critical that when using a connection pool, and by extension when "
"using an :class:`.Engine` created via :func:`.create_engine`, that the "
"pooled connections **are not shared to a forked process**.  TCP "
"connections are represented as file descriptors, which usually work "
"across process boundaries, meaning this will cause concurrent access to "
"the file descriptor on behalf of two or more entirely independent Python "
"interpreter states."
msgstr ""

#: ../../core/pooling.rst:444
msgid "There are two approaches to dealing with this."
msgstr ""

#: ../../core/pooling.rst:446
msgid ""
"The first is, either create a new :class:`.Engine` within the child "
"process, or upon an existing :class:`.Engine`, call "
":meth:`.Engine.dispose` before the child process uses any connections.  "
"This will remove all existing connections from the pool so that it makes "
"all new ones.  Below is a simple version using "
"``multiprocessing.Process``, but this idea should be adapted to the style"
" of forking in use::"
msgstr ""

#: ../../core/pooling.rst:463
msgid ""
"The next approach is to instrument the :class:`.Pool` itself with events "
"so that connections are automatically invalidated in the subprocess. This"
" is a little more magical but probably more foolproof::"
msgstr ""

#: ../../core/pooling.rst:488
msgid ""
"Above, we use an approach similar to that described in "
":ref:`pool_disconnects_pessimistic` to treat a DBAPI connection that "
"originated in a different parent process as an \"invalid\" connection, "
"coercing the pool to recycle the connection record to make a new "
"connection."
msgstr ""

#: ../../core/pooling.rst:496
msgid "API Documentation - Available Pool Implementations"
msgstr ""

#: of sqlalchemy.pool.Pool:1
msgid "Abstract base class for connection pools."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:1
#: sqlalchemy.pool.SingletonThreadPool.__init__:1
msgid "Construct a Pool."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__ sqlalchemy.pool.QueuePool.__init__
#: sqlalchemy.pool.SingletonThreadPool
#: sqlalchemy.pool.SingletonThreadPool.__init__
#: sqlalchemy.pool._ConnectionFairy.invalidate
#: sqlalchemy.pool._ConnectionRecord.invalidate
msgid "Parameters"
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:3
#: sqlalchemy.pool.SingletonThreadPool.__init__:3
msgid ""
"a callable function that returns a DB-API connection object.  The "
"function will be called with parameters."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:7
#: sqlalchemy.pool.SingletonThreadPool.__init__:7
msgid ""
"If set to a value other than -1, number of seconds between connection "
"recycling, which means upon checkout, if this timeout is surpassed the "
"connection will be closed and replaced with a newly opened connection. "
"Defaults to -1."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:12
#: sqlalchemy.pool.SingletonThreadPool.__init__:12
msgid ""
"String identifier which will be used within the \"name\" field of logging"
" records generated within the \"sqlalchemy.pool\" logger. Defaults to a "
"hexstring of the object's id."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:17
#: sqlalchemy.pool.SingletonThreadPool.__init__:17
msgid ""
"If True, connections being pulled and retrieved from the pool will be "
"logged to the standard output, as well as pool sizing information.  "
"Echoing can also be achieved by enabling logging for the "
"\"sqlalchemy.pool\" namespace. Defaults to False."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:23
#: sqlalchemy.pool.SingletonThreadPool.__init__:23
msgid ""
"If set to True, repeated calls to :meth:`connect` within the same "
"application thread will be guaranteed to return the same connection "
"object, if one has already been retrieved from the pool and has not been "
"returned yet.  Offers a slight performance advantage at the cost of "
"individual transactions by default.  The :meth:`.Pool.unique_connection` "
"method is provided to return a consistently unique connection to bypass "
"this behavior when the flag is set.  .. warning::  The "
":paramref:`.Pool.use_threadlocal` flag    **does not affect the "
"behavior** of :meth:`.Engine.connect`.    :meth:`.Engine.connect` makes "
"use of the    :meth:`.Pool.unique_connection` method which **does not use"
" thread    local context**.  To produce a :class:`.Connection` which "
"refers    to the :meth:`.Pool.connect` method, use    "
":meth:`.Engine.contextual_connect`.     Note that other SQLAlchemy "
"connectivity systems such as    :meth:`.Engine.execute` as well as the "
"orm    :class:`.Session` make use of    "
":meth:`.Engine.contextual_connect` internally, so these functions    are "
"compatible with the :paramref:`.Pool.use_threadlocal` setting.  .. "
"seealso::    :ref:`threadlocal_strategy` - contains detail on the   "
"\"threadlocal\" engine strategy, which provides a more comprehensive   "
"approach to \"threadlocal\" connectivity for the specific   use case of "
"using :class:`.Engine` and :class:`.Connection` objects   directly."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:23
#: sqlalchemy.pool.SingletonThreadPool.__init__:23
msgid ""
"If set to True, repeated calls to :meth:`connect` within the same "
"application thread will be guaranteed to return the same connection "
"object, if one has already been retrieved from the pool and has not been "
"returned yet.  Offers a slight performance advantage at the cost of "
"individual transactions by default.  The :meth:`.Pool.unique_connection` "
"method is provided to return a consistently unique connection to bypass "
"this behavior when the flag is set."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:33
#: sqlalchemy.pool.SingletonThreadPool.__init__:33
msgid ""
"The :paramref:`.Pool.use_threadlocal` flag **does not affect the "
"behavior** of :meth:`.Engine.connect`. :meth:`.Engine.connect` makes use "
"of the :meth:`.Pool.unique_connection` method which **does not use thread"
" local context**.  To produce a :class:`.Connection` which refers to the "
":meth:`.Pool.connect` method, use :meth:`.Engine.contextual_connect`."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:41
#: sqlalchemy.pool.SingletonThreadPool.__init__:41
msgid ""
"Note that other SQLAlchemy connectivity systems such as "
":meth:`.Engine.execute` as well as the orm :class:`.Session` make use of "
":meth:`.Engine.contextual_connect` internally, so these functions are "
"compatible with the :paramref:`.Pool.use_threadlocal` setting."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:49
#: sqlalchemy.pool.SingletonThreadPool.__init__:49
msgid ""
":ref:`threadlocal_strategy` - contains detail on the \"threadlocal\" "
"engine strategy, which provides a more comprehensive approach to "
"\"threadlocal\" connectivity for the specific use case of using "
":class:`.Engine` and :class:`.Connection` objects directly."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:55
#: sqlalchemy.pool.SingletonThreadPool.__init__:55
msgid ""
"Determine steps to take on connections as they are returned to the pool. "
"reset_on_return can have any of these values:  * ``\"rollback\"`` - call "
"rollback() on the connection,   to release locks and transaction "
"resources.   This is the default value.  The vast majority   of use cases"
" should leave this value set. * ``True`` - same as 'rollback', this is "
"here for   backwards compatibility. * ``\"commit\"`` - call commit() on "
"the connection,   to release locks and transaction resources.   A commit "
"here may be desirable for databases that   cache query plans if a commit "
"is emitted,   such as Microsoft SQL Server.  However, this   value is "
"more dangerous than 'rollback' because   any data changes present on the "
"transaction   are committed unconditionally. * ``None`` - don't do "
"anything on the connection.   This setting should generally only be made "
"on a database   that has no transaction support at all,   namely MySQL "
"MyISAM; when used on this backend, performance   can be improved as the "
"\"rollback\" call is still expensive on   MySQL.   It is **strongly "
"recommended** that this setting not be   used for transaction-supporting "
"databases in conjunction with   a persistent pool such as "
":class:`.QueuePool`, as it opens   the possibility for connections still "
"in a transaction to be   idle in the pool.   The setting may be "
"appropriate in the   case of :class:`.NullPool` or special circumstances "
"where   the connection pool in use is not being used to maintain "
"connection   lifecycle.  * ``False`` - same as None, this is here for   "
"backwards compatibility."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:55
#: sqlalchemy.pool.SingletonThreadPool.__init__:55
msgid ""
"Determine steps to take on connections as they are returned to the pool. "
"reset_on_return can have any of these values:"
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:59
#: sqlalchemy.pool.SingletonThreadPool.__init__:59
msgid ""
"``\"rollback\"`` - call rollback() on the connection, to release locks "
"and transaction resources. This is the default value.  The vast majority "
"of use cases should leave this value set."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:63
#: sqlalchemy.pool.SingletonThreadPool.__init__:63
msgid "``True`` - same as 'rollback', this is here for backwards compatibility."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:65
#: sqlalchemy.pool.SingletonThreadPool.__init__:65
msgid ""
"``\"commit\"`` - call commit() on the connection, to release locks and "
"transaction resources. A commit here may be desirable for databases that "
"cache query plans if a commit is emitted, such as Microsoft SQL Server.  "
"However, this value is more dangerous than 'rollback' because any data "
"changes present on the transaction are committed unconditionally."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:73
#: sqlalchemy.pool.SingletonThreadPool.__init__:73
msgid ""
"``None`` - don't do anything on the connection. This setting should "
"generally only be made on a database that has no transaction support at "
"all, namely MySQL MyISAM; when used on this backend, performance can be "
"improved as the \"rollback\" call is still expensive on MySQL.   It is "
"**strongly recommended** that this setting not be used for transaction-"
"supporting databases in conjunction with a persistent pool such as "
":class:`.QueuePool`, as it opens the possibility for connections still in"
" a transaction to be idle in the pool.   The setting may be appropriate "
"in the case of :class:`.NullPool` or special circumstances where the "
"connection pool in use is not being used to maintain connection "
"lifecycle."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:87
#: sqlalchemy.pool.SingletonThreadPool.__init__:87
msgid "``False`` - same as None, this is here for backwards compatibility."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:90
#: sqlalchemy.pool.SingletonThreadPool.__init__:90
msgid ""
"a list of 2-tuples, each of the form ``(callable, target)`` which will be"
" passed to :func:`.event.listen` upon construction.   Provided here so "
"that event listeners can be assigned via :func:`.create_engine` before "
"dialect-level listeners are applied."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:96
#: sqlalchemy.pool.SingletonThreadPool.__init__:96
msgid ""
"Deprecated.  A list of :class:`~sqlalchemy.interfaces.PoolListener`-like "
"objects or dictionaries of callables that receive events when DB-API "
"connections are created, checked out and checked in to the pool.  This "
"has been superseded by :func:`~sqlalchemy.event.listen`."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:103
#: sqlalchemy.pool.SingletonThreadPool.__init__:103
msgid ""
"a :class:`.Dialect` that will handle the job of calling rollback(), "
"close(), or commit() on DBAPI connections. If omitted, a built-in "
"\"stub\" dialect is used.   Applications that make use of "
":func:`~.create_engine` should not use this parameter as it is handled by"
" the engine creation strategy.  .. versionadded:: 1.1 - ``dialect`` is "
"now a public parameter    to the :class:`.Pool`."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:103
#: sqlalchemy.pool.SingletonThreadPool.__init__:103
msgid ""
"a :class:`.Dialect` that will handle the job of calling rollback(), "
"close(), or commit() on DBAPI connections. If omitted, a built-in "
"\"stub\" dialect is used.   Applications that make use of "
":func:`~.create_engine` should not use this parameter as it is handled by"
" the engine creation strategy."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:109
#: sqlalchemy.pool.SingletonThreadPool.__init__:109
msgid "- ``dialect`` is now a public parameter to the :class:`.Pool`."
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:112
#: sqlalchemy.pool.SingletonThreadPool.__init__:112
msgid ""
"if True, the pool will emit a \"ping\" (typically \"SELECT 1\", but is "
"dialect-specific) on the connection upon checkout, to test if the "
"connection is alive or not.   If not, the connection is transparently re-"
"connected and upon success, all other pooled connections established "
"prior to that timestamp are invalidated.     Requires that a dialect is "
"passed as well to interpret the disconnection error.  .. versionadded:: "
"1.2"
msgstr ""

#: of sqlalchemy.pool.Pool.__init__:112
#: sqlalchemy.pool.SingletonThreadPool.__init__:112
msgid ""
"if True, the pool will emit a \"ping\" (typically \"SELECT 1\", but is "
"dialect-specific) on the connection upon checkout, to test if the "
"connection is alive or not.   If not, the connection is transparently re-"
"connected and upon success, all other pooled connections established "
"prior to that timestamp are invalidated.     Requires that a dialect is "
"passed as well to interpret the disconnection error."
msgstr ""

#: of sqlalchemy.pool.Pool.connect:1 sqlalchemy.pool.QueuePool.connect:1
msgid "Return a DBAPI connection from the pool."
msgstr ""

#: of sqlalchemy.pool.Pool.connect:3 sqlalchemy.pool.QueuePool.connect:3
msgid ""
"The connection is instrumented such that when its ``close()`` method is "
"called, the connection will be returned to the pool."
msgstr ""

#: of sqlalchemy.pool.Pool.dispose:1
msgid "Dispose of this pool."
msgstr ""

#: of sqlalchemy.pool.Pool.dispose:3
msgid ""
"This method leaves the possibility of checked-out connections remaining "
"open, as it only affects connections that are idle in the pool."
msgstr ""

#: of sqlalchemy.pool.Pool.dispose:7
msgid "See also the :meth:`Pool.recreate` method."
msgstr ""

#: of sqlalchemy.pool.Pool.recreate:1
msgid ""
"Return a new :class:`.Pool`, of the same class as this one and configured"
" with identical creation arguments."
msgstr ""

#: of sqlalchemy.pool.Pool.recreate:4
msgid ""
"This method is used in conjunction with :meth:`dispose` to close out an "
"entire :class:`.Pool` and create a new one in its place."
msgstr ""

#: of sqlalchemy.pool.Pool.unique_connection:1
#: sqlalchemy.pool.QueuePool.unique_connection:1
msgid ""
"Produce a DBAPI connection that is not referenced by any thread-local "
"context."
msgstr ""

#: of sqlalchemy.pool.Pool.unique_connection:4
#: sqlalchemy.pool.QueuePool.unique_connection:4
msgid ""
"This method is equivalent to :meth:`.Pool.connect` when the "
":paramref:`.Pool.use_threadlocal` flag is not set to True. When "
":paramref:`.Pool.use_threadlocal` is True, the "
":meth:`.Pool.unique_connection` method provides a means of bypassing the "
"threadlocal context."
msgstr ""

#: of sqlalchemy.pool.QueuePool:1
msgid "A :class:`.Pool` that imposes a limit on the number of open connections."
msgstr ""

#: of sqlalchemy.pool.QueuePool:3
msgid ""
":class:`.QueuePool` is the default pooling implementation used for all "
":class:`.Engine` objects, unless the SQLite dialect is in use."
msgstr ""

#: of sqlalchemy.pool.QueuePool.__init__:1
msgid "Construct a QueuePool."
msgstr ""

#: of sqlalchemy.pool.QueuePool.__init__:3
msgid ""
"a callable function that returns a DB-API connection object, same as that"
" of :paramref:`.Pool.creator`."
msgstr ""

#: of sqlalchemy.pool.QueuePool.__init__:6
msgid ""
"The size of the pool to be maintained, defaults to 5. This is the largest"
" number of connections that will be kept persistently in the pool. Note "
"that the pool begins with no connections; once this number of connections"
" is requested, that number of connections will remain. ``pool_size`` can "
"be set to 0 to indicate no size limit; to disable pooling, use a "
":class:`~sqlalchemy.pool.NullPool` instead."
msgstr ""

#: of sqlalchemy.pool.QueuePool.__init__:15
msgid ""
"The maximum overflow size of the pool. When the number of checked-out "
"connections reaches the size set in pool_size, additional connections "
"will be returned up to this limit. When those additional connections are "
"returned to the pool, they are disconnected and discarded. It follows "
"then that the total number of simultaneous connections the pool will "
"allow is pool_size + `max_overflow`, and the total number of \"sleeping\""
" connections the pool will allow is pool_size. `max_overflow` can be set "
"to -1 to indicate no overflow limit; no limit will be placed on the total"
" number of concurrent connections. Defaults to 10."
msgstr ""

#: of sqlalchemy.pool.QueuePool.__init__:28
msgid ""
"The number of seconds to wait before giving up on returning a connection."
" Defaults to 30."
msgstr ""

#: of sqlalchemy.pool.QueuePool.__init__:31
msgid ""
"use LIFO (last-in-first-out) when retrieving connections instead of FIFO "
"(first-in-first-out). Using LIFO, a server-side timeout scheme can reduce"
" the number of connections used during non-peak periods of use.   When "
"planning for server-side timeouts, ensure that a recycle or pre-ping "
"strategy is in use to gracefully handle stale connections.  .. "
"versionadded:: 1.3  .. seealso::    :ref:`pool_use_lifo`    "
":ref:`pool_disconnects`"
msgstr ""

#: of sqlalchemy.pool.QueuePool.__init__:31
msgid ""
"use LIFO (last-in-first-out) when retrieving connections instead of FIFO "
"(first-in-first-out). Using LIFO, a server-side timeout scheme can reduce"
" the number of connections used during non-peak periods of use.   When "
"planning for server-side timeouts, ensure that a recycle or pre-ping "
"strategy is in use to gracefully handle stale connections."
msgstr ""

#: of sqlalchemy.pool.QueuePool.__init__:42
msgid ":ref:`pool_use_lifo`"
msgstr ""

#: of sqlalchemy.pool.QueuePool.__init__:46
msgid ""
"Other keyword arguments including :paramref:`.Pool.recycle`, "
":paramref:`.Pool.echo`, :paramref:`.Pool.reset_on_return` and others are "
"passed to the :class:`.Pool` constructor."
msgstr ""

#: of sqlalchemy.pool.SingletonThreadPool:1
msgid "A Pool that maintains one connection per thread."
msgstr ""

#: of sqlalchemy.pool.SingletonThreadPool:3
msgid ""
"Maintains one connection per each thread, never moving a connection to a "
"thread other than the one which it was created in."
msgstr ""

#: of sqlalchemy.pool.SingletonThreadPool:6
msgid ""
"the :class:`.SingletonThreadPool` will call ``.close()`` on arbitrary "
"connections that exist beyond the size setting of ``pool_size``, e.g. if "
"more unique **thread identities** than what ``pool_size`` states are "
"used.   This cleanup is non-deterministic and not sensitive to whether or"
" not the connections linked to those thread identities are currently in "
"use."
msgstr ""

#: of sqlalchemy.pool.SingletonThreadPool:13
msgid ""
":class:`.SingletonThreadPool` may be improved in a future release, "
"however in its current status it is generally used only for test "
"scenarios using a SQLite ``:memory:`` database and is not recommended for"
" production use."
msgstr ""

#: of sqlalchemy.pool.SingletonThreadPool:19
msgid "Options are the same as those of :class:`.Pool`, as well as:"
msgstr ""

#: of sqlalchemy.pool.SingletonThreadPool:21
msgid ""
"The number of threads in which to maintain connections at once.  Defaults"
" to five."
msgstr ""

#: of sqlalchemy.pool.SingletonThreadPool:24
msgid ""
":class:`.SingletonThreadPool` is used by the SQLite dialect automatically"
" when a memory-based database is used. See :ref:`sqlite_toplevel`."
msgstr ""

#: of sqlalchemy.pool.AssertionPool:1
msgid ""
"A :class:`.Pool` that allows at most one checked out connection at any "
"given time."
msgstr ""

#: of sqlalchemy.pool.AssertionPool:4
msgid ""
"This will raise an exception if more than one connection is checked out "
"at a time.  Useful for debugging code that is using more connections than"
" desired."
msgstr ""

#: of sqlalchemy.pool.AssertionPool:8
msgid ""
":class:`.AssertionPool` also logs a traceback of where the original "
"connection was checked out, and reports this in the assertion error "
"raised."
msgstr ""

#: of sqlalchemy.pool.NullPool:1
msgid "A Pool which does not pool connections."
msgstr ""

#: of sqlalchemy.pool.NullPool:3
msgid ""
"Instead it literally opens and closes the underlying DB-API connection "
"per each connection open/close."
msgstr ""

#: of sqlalchemy.pool.NullPool:6
msgid ""
"Reconnect-related functions such as ``recycle`` and connection "
"invalidation are not supported by this Pool implementation, since no "
"connections are held persistently."
msgstr ""

#: of sqlalchemy.pool.NullPool:10
msgid ""
":class:`.NullPool` is used by the SQlite dialect automatically when a "
"file-based database is used. See :ref:`sqlite_toplevel`."
msgstr ""

#: of sqlalchemy.pool.StaticPool:1
msgid "A Pool of exactly one connection, used for all requests."
msgstr ""

#: of sqlalchemy.pool.StaticPool:3
msgid ""
"Reconnect-related functions such as ``recycle`` and connection "
"invalidation (which is also used to support auto-reconnect) are not "
"currently supported by this Pool implementation but may be implemented in"
" a future release."
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy:1
msgid "Proxies a DBAPI connection and provides return-on-dereference support."
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy:4
msgid ""
"This is an internal object used by the :class:`.Pool` implementation to "
"provide context management to a DBAPI connection delivered by that "
":class:`.Pool`."
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy:8
msgid ""
"The name \"fairy\" is inspired by the fact that the "
":class:`._ConnectionFairy` object's lifespan is transitory, as it lasts "
"only for the length of a specific DBAPI connection being checked out from"
" the pool, and additionally that as a transparent proxy, it is mostly "
"invisible."
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy:16
msgid ":class:`._ConnectionRecord`"
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy._connection_record:1
msgid ""
"A reference to the :class:`._ConnectionRecord` object associated with the"
" DBAPI connection."
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy._connection_record:4
msgid "This is currently an internal accessor which is subject to change."
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy.connection:1
#: sqlalchemy.pool._ConnectionRecord.connection:1
msgid "A reference to the actual DBAPI connection being tracked."
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy.cursor:1
msgid "Return a new DBAPI cursor for the underlying connection."
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy.cursor:3
msgid "This method is a proxy for the ``connection.cursor()`` DBAPI method."
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy.detach:1
msgid "Separate this connection from its Pool."
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy.detach:3
msgid ""
"This means that the connection will no longer be returned to the pool "
"when closed, and will instead be literally closed.  The containing "
"ConnectionRecord is separated from the DB-API connection, and will create"
" a new connection when next used."
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy.detach:8
msgid ""
"Note that any overall connection limiting constraints imposed by a Pool "
"implementation may be violated after a detach, as the detached connection"
" is removed from the pool's knowledge and control."
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy.info:1
msgid ""
"Info dictionary associated with the underlying DBAPI connection referred "
"to by this :class:`.ConnectionFairy`, allowing user-defined data to be "
"associated with the connection."
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy.info:5
msgid ""
"The data here will follow along with the DBAPI connection including after"
" it is returned to the connection pool and used again in subsequent "
"instances of :class:`._ConnectionFairy`.  It is shared with the "
":attr:`._ConnectionRecord.info` and :attr:`.Connection.info` accessors."
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy.info:11
msgid ""
"The dictionary associated with a particular DBAPI connection is discarded"
" when the connection itself is discarded."
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy.invalidate:1
msgid "Mark this connection as invalidated."
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy.invalidate:3
msgid ""
"This method can be called directly, and is also called as a result of the"
" :meth:`.Connection.invalidate` method.   When invoked, the DBAPI "
"connection is immediately closed and discarded from further use by the "
"pool.  The invalidation mechanism proceeds via the "
":meth:`._ConnectionRecord.invalidate` internal method."
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy.invalidate:9
#: sqlalchemy.pool._ConnectionRecord.invalidate:8
msgid "an exception object indicating a reason for the invalidation."
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy.invalidate:11
#: sqlalchemy.pool._ConnectionRecord.invalidate:10
msgid ""
"if True, the connection isn't closed; instead, this connection will be "
"recycled on next checkout.  .. versionadded:: 1.0.3"
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy.invalidate:11
#: sqlalchemy.pool._ConnectionRecord.invalidate:10
msgid ""
"if True, the connection isn't closed; instead, this connection will be "
"recycled on next checkout."
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy.invalidate:18
#: sqlalchemy.pool._ConnectionRecord.invalidate:17
msgid ":ref:`pool_connection_invalidation`"
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy.is_valid:1
msgid ""
"Return True if this :class:`._ConnectionFairy` still refers to an active "
"DBAPI connection."
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy.record_info:1
msgid ""
"Info dictionary associated with the :class:`._ConnectionRecord container "
"referred to by this :class:`.ConnectionFairy`."
msgstr ""

#: of sqlalchemy.pool._ConnectionFairy.record_info:4
msgid ""
"Unlike the :attr:`._ConnectionFairy.info` dictionary, the lifespan of "
"this dictionary is persistent across connections that are disconnected "
"and/or invalidated within the lifespan of a :class:`._ConnectionRecord`."
msgstr ""

#: of sqlalchemy.pool._ConnectionRecord:1
msgid ""
"Internal object which maintains an individual DBAPI connection referenced"
" by a :class:`.Pool`."
msgstr ""

#: of sqlalchemy.pool._ConnectionRecord:4
msgid ""
"The :class:`._ConnectionRecord` object always exists for any particular "
"DBAPI connection whether or not that DBAPI connection has been \"checked "
"out\".  This is in contrast to the :class:`._ConnectionFairy` which is "
"only a public facade to the DBAPI connection while it is checked out."
msgstr ""

#: of sqlalchemy.pool._ConnectionRecord:10
msgid ""
"A :class:`._ConnectionRecord` may exist for a span longer than that of a "
"single DBAPI connection.  For example, if the "
":meth:`._ConnectionRecord.invalidate` method is called, the DBAPI "
"connection associated with this :class:`._ConnectionRecord` will be "
"discarded, but the :class:`._ConnectionRecord` may be used again, in "
"which case a new DBAPI connection is produced when the :class:`.Pool` "
"next uses this record."
msgstr ""

#: of sqlalchemy.pool._ConnectionRecord:19
msgid ""
"The :class:`._ConnectionRecord` is delivered along with connection pool "
"events, including :meth:`.PoolEvents.connect` and "
":meth:`.PoolEvents.checkout`, however :class:`._ConnectionRecord` still "
"remains an internal object whose API and internals may change."
msgstr ""

#: of sqlalchemy.pool._ConnectionRecord:26
msgid ":class:`._ConnectionFairy`"
msgstr ""

#: of sqlalchemy.pool._ConnectionRecord.connection:3
msgid ""
"May be ``None`` if this :class:`._ConnectionRecord` has been marked as "
"invalidated; a new DBAPI connection may replace it if the owning pool "
"calls upon this :class:`._ConnectionRecord` to reconnect."
msgstr ""

#: of sqlalchemy.pool._ConnectionRecord.info:1
msgid "The ``.info`` dictionary associated with the DBAPI connection."
msgstr ""

#: of sqlalchemy.pool._ConnectionRecord.info:3
msgid ""
"This dictionary is shared among the :attr:`._ConnectionFairy.info` and "
":attr:`.Connection.info` accessors."
msgstr ""

#: of sqlalchemy.pool._ConnectionRecord.info:8
msgid ""
"The lifespan of this dictionary is linked to the DBAPI connection itself,"
" meaning that it is **discarded** each time the DBAPI connection is "
"closed and/or invalidated.   The :attr:`._ConnectionRecord.record_info` "
"dictionary remains persistent throughout the lifespan of the "
":class:`._ConnectionRecord` container."
msgstr ""

#: of sqlalchemy.pool._ConnectionRecord.invalidate:1
msgid "Invalidate the DBAPI connection held by this :class:`._ConnectionRecord`."
msgstr ""

#: of sqlalchemy.pool._ConnectionRecord.invalidate:3
msgid ""
"This method is called for all connection invalidations, including when "
"the :meth:`._ConnectionFairy.invalidate` or "
":meth:`.Connection.invalidate` methods are called, as well as when any "
"so-called \"automatic invalidation\" condition occurs."
msgstr ""

#: of sqlalchemy.pool._ConnectionRecord.record_info:1
msgid "An \"info' dictionary associated with the connection record itself."
msgstr ""

#: of sqlalchemy.pool._ConnectionRecord.record_info:4
msgid ""
"Unlike the :attr:`._ConnectionRecord.info` dictionary, which is linked to"
" the lifespan of the DBAPI connection, this dictionary is linked to the "
"lifespan of the :class:`._ConnectionRecord` container itself and will "
"remain persisent throughout the life of the :class:`._ConnectionRecord`."
msgstr ""

