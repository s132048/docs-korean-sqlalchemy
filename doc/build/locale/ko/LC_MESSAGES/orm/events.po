# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: SQLAlchemy 1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-02-21 14:32+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../orm/events.rst:4
msgid "ORM Events"
msgstr ""

#: ../../orm/events.rst:6
msgid "The ORM includes a wide variety of hooks available for subscription."
msgstr ""

#: ../../orm/events.rst:8
msgid ""
"For an introduction to the most commonly used ORM events, see the section"
" :ref:`session_events_toplevel`.   The event system in general is "
"discussed at :ref:`event_toplevel`.  Non-ORM events such as those "
"regarding connections and low-level statement execution are described in "
":ref:`core_event_toplevel`."
msgstr ""

#: ../../orm/events.rst:14
msgid "Attribute Events"
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents:1
msgid "Define events for object attributes."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents:3
msgid ""
"These are typically defined on the class-bound descriptor for the target "
"class."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents:6
#: sqlalchemy.orm.events.InstanceEvents:3 sqlalchemy.orm.events.MapperEvents:3
#: sqlalchemy.orm.events.SessionEvents:3
msgid "e.g.::"
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents:15
msgid ""
"Listeners have the option to return a possibly modified version of the "
"value, when the ``retval=True`` flag is passed to "
":func:`~.event.listen`::"
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents:28
msgid ""
"A validation function like the above can also raise an exception such as "
":exc:`ValueError` to halt the operation."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents:31
msgid "Several modifiers are available to the :func:`~.event.listen` function."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents
#: sqlalchemy.orm.events.AttributeEvents.append
#: sqlalchemy.orm.events.AttributeEvents.bulk_replace
#: sqlalchemy.orm.events.AttributeEvents.init_collection
#: sqlalchemy.orm.events.AttributeEvents.init_scalar
#: sqlalchemy.orm.events.AttributeEvents.modified
#: sqlalchemy.orm.events.AttributeEvents.remove
#: sqlalchemy.orm.events.AttributeEvents.set
#: sqlalchemy.orm.events.InstanceEvents
#: sqlalchemy.orm.events.InstanceEvents.expire
#: sqlalchemy.orm.events.InstanceEvents.init
#: sqlalchemy.orm.events.InstanceEvents.init_failure
#: sqlalchemy.orm.events.InstanceEvents.load
#: sqlalchemy.orm.events.InstanceEvents.pickle
#: sqlalchemy.orm.events.InstanceEvents.refresh
#: sqlalchemy.orm.events.InstanceEvents.refresh_flush
#: sqlalchemy.orm.events.InstanceEvents.unpickle
#: sqlalchemy.orm.events.MapperEvents
#: sqlalchemy.orm.events.MapperEvents.after_delete
#: sqlalchemy.orm.events.MapperEvents.after_insert
#: sqlalchemy.orm.events.MapperEvents.after_update
#: sqlalchemy.orm.events.MapperEvents.before_delete
#: sqlalchemy.orm.events.MapperEvents.before_insert
#: sqlalchemy.orm.events.MapperEvents.before_update
#: sqlalchemy.orm.events.MapperEvents.instrument_class
#: sqlalchemy.orm.events.MapperEvents.mapper_configured
#: sqlalchemy.orm.events.SessionEvents.after_begin
#: sqlalchemy.orm.events.SessionEvents.after_bulk_delete
#: sqlalchemy.orm.events.SessionEvents.after_bulk_update
#: sqlalchemy.orm.events.SessionEvents.after_commit
#: sqlalchemy.orm.events.SessionEvents.after_flush
#: sqlalchemy.orm.events.SessionEvents.after_flush_postexec
#: sqlalchemy.orm.events.SessionEvents.after_rollback
#: sqlalchemy.orm.events.SessionEvents.after_soft_rollback
#: sqlalchemy.orm.events.SessionEvents.after_transaction_create
#: sqlalchemy.orm.events.SessionEvents.after_transaction_end
#: sqlalchemy.orm.events.SessionEvents.before_commit
#: sqlalchemy.orm.events.SessionEvents.before_flush
#: sqlalchemy.orm.events.SessionEvents.detached_to_persistent
#: sqlalchemy.orm.events.SessionEvents.loaded_as_persistent
#: sqlalchemy.orm.events.SessionEvents.pending_to_persistent
#: sqlalchemy.orm.events.SessionEvents.pending_to_transient
#: sqlalchemy.orm.events.SessionEvents.persistent_to_detached
#: sqlalchemy.orm.events.SessionEvents.persistent_to_transient
#: sqlalchemy.orm.events.SessionEvents.transient_to_pending
msgid "Parameters"
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents:33
msgid ""
"When True, indicates that the \"set\" event would like to receive the "
"\"old\" value being replaced unconditionally, even if this requires "
"firing off database loads. Note that ``active_history`` can also be set "
"directly via :func:`.column_property` and :func:`.relationship`."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents:40
msgid ""
"When True, the listener function will be established not just for the "
"class attribute given, but for attributes of the same name on all current"
" subclasses of that class, as well as all future subclasses of that "
"class, using an additional listener that listens for instrumentation "
"events."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents:46
msgid ""
"When True, the \"target\" argument to the event will be the "
":class:`.InstanceState` management object, rather than the mapped "
"instance itself."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents:49
msgid ""
"when True, the user-defined event listening must return the \"value\" "
"argument from the function.  This gives the listening function the "
"opportunity to change the value that is ultimately used for a \"set\" or "
"\"append\" event."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.append:1
msgid "Receive a collection append event."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.append:5
#: sqlalchemy.orm.events.AttributeEvents.bulk_replace:5
#: sqlalchemy.orm.events.AttributeEvents.dispose_collection:5
#: sqlalchemy.orm.events.AttributeEvents.init_collection:5
#: sqlalchemy.orm.events.AttributeEvents.init_scalar:5
#: sqlalchemy.orm.events.AttributeEvents.modified:5
#: sqlalchemy.orm.events.AttributeEvents.remove:5
#: sqlalchemy.orm.events.AttributeEvents.set:5
#: sqlalchemy.orm.events.InstanceEvents.expire:6
#: sqlalchemy.orm.events.InstanceEvents.first_init:5
#: sqlalchemy.orm.events.InstanceEvents.init:5
#: sqlalchemy.orm.events.InstanceEvents.init_failure:6
#: sqlalchemy.orm.events.InstanceEvents.load:7
#: sqlalchemy.orm.events.InstanceEvents.pickle:6
#: sqlalchemy.orm.events.InstanceEvents.refresh:6
#: sqlalchemy.orm.events.InstanceEvents.refresh_flush:6
#: sqlalchemy.orm.events.InstanceEvents.unpickle:6
#: sqlalchemy.orm.events.InstrumentationEvents.attribute_instrument:3
#: sqlalchemy.orm.events.InstrumentationEvents.class_instrument:5
#: sqlalchemy.orm.events.InstrumentationEvents.class_uninstrument:5
#: sqlalchemy.orm.events.MapperEvents.after_configured:5
#: sqlalchemy.orm.events.MapperEvents.after_delete:6
#: sqlalchemy.orm.events.MapperEvents.after_insert:6
#: sqlalchemy.orm.events.MapperEvents.after_update:6
#: sqlalchemy.orm.events.MapperEvents.before_configured:5
#: sqlalchemy.orm.events.MapperEvents.before_delete:6
#: sqlalchemy.orm.events.MapperEvents.before_insert:6
#: sqlalchemy.orm.events.MapperEvents.before_update:6
#: sqlalchemy.orm.events.MapperEvents.instrument_class:6
#: sqlalchemy.orm.events.MapperEvents.mapper_configured:6
#: sqlalchemy.orm.events.QueryEvents.before_compile:6
#: sqlalchemy.orm.events.SessionEvents.after_attach:5
#: sqlalchemy.orm.events.SessionEvents.after_begin:5
#: sqlalchemy.orm.events.SessionEvents.after_bulk_delete:5
#: sqlalchemy.orm.events.SessionEvents.after_bulk_update:5
#: sqlalchemy.orm.events.SessionEvents.after_commit:5
#: sqlalchemy.orm.events.SessionEvents.after_flush:6
#: sqlalchemy.orm.events.SessionEvents.after_flush_postexec:6
#: sqlalchemy.orm.events.SessionEvents.after_rollback:5
#: sqlalchemy.orm.events.SessionEvents.after_soft_rollback:6
#: sqlalchemy.orm.events.SessionEvents.after_transaction_create:5
#: sqlalchemy.orm.events.SessionEvents.after_transaction_end:5
#: sqlalchemy.orm.events.SessionEvents.before_attach:5
#: sqlalchemy.orm.events.SessionEvents.before_commit:5
#: sqlalchemy.orm.events.SessionEvents.before_flush:5
#: sqlalchemy.orm.events.SessionEvents.deleted_to_detached:5
#: sqlalchemy.orm.events.SessionEvents.deleted_to_persistent:5
#: sqlalchemy.orm.events.SessionEvents.detached_to_persistent:5
#: sqlalchemy.orm.events.SessionEvents.loaded_as_persistent:5
#: sqlalchemy.orm.events.SessionEvents.pending_to_persistent:5
#: sqlalchemy.orm.events.SessionEvents.pending_to_transient:5
#: sqlalchemy.orm.events.SessionEvents.persistent_to_deleted:5
#: sqlalchemy.orm.events.SessionEvents.persistent_to_detached:5
#: sqlalchemy.orm.events.SessionEvents.persistent_to_transient:5
#: sqlalchemy.orm.events.SessionEvents.transient_to_pending:5
msgid "Example argument forms::"
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.append:17
msgid ""
"The append event is invoked for each element as it is appended to the "
"collection.  This occurs for single-item appends as well as for a \"bulk "
"replace\" operation."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.append:21
#: sqlalchemy.orm.events.AttributeEvents.bulk_replace:52
#: sqlalchemy.orm.events.AttributeEvents.init_collection:32
#: sqlalchemy.orm.events.AttributeEvents.init_scalar:106
#: sqlalchemy.orm.events.AttributeEvents.modified:23
#: sqlalchemy.orm.events.AttributeEvents.remove:17
#: sqlalchemy.orm.events.AttributeEvents.set:26
msgid ""
"the object instance receiving the event. If the listener is registered "
"with ``raw=True``, this will be the :class:`.InstanceState` object."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.append:24
msgid ""
"the value being appended.  If this listener is registered with "
"``retval=True``, the listener function must return this value, or a new "
"value which replaces it."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.append:28
msgid ""
"An instance of :class:`.attributes.Event` representing the initiation of "
"the event.  May be modified from its original value by backref handlers "
"in order to control chained event propagation, as well as be inspected "
"for information about the source of the event."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.append
#: sqlalchemy.orm.events.AttributeEvents.remove
#: sqlalchemy.orm.events.AttributeEvents.set
#: sqlalchemy.orm.events.MapperEvents.after_delete
#: sqlalchemy.orm.events.MapperEvents.after_insert
#: sqlalchemy.orm.events.MapperEvents.after_update
#: sqlalchemy.orm.events.MapperEvents.before_delete
#: sqlalchemy.orm.events.MapperEvents.before_insert
#: sqlalchemy.orm.events.MapperEvents.before_update
msgid "Returns"
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.append:33
#: sqlalchemy.orm.events.AttributeEvents.set:49
msgid ""
"if the event was registered with ``retval=True``, the given value, or a "
"new effective value, should be returned."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.append:38
msgid ":meth:`.AttributeEvents.bulk_replace`"
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.bulk_replace:1
msgid "Receive a collection 'bulk replace' event."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.bulk_replace:17
msgid ""
"This event is invoked for a sequence of values as they are incoming to a "
"bulk collection set operation, which can be modified in place before the "
"values are treated as ORM objects. This is an \"early hook\" that runs "
"before the bulk replace routine attempts to reconcile which objects are "
"already present in the collection and which are being removed by the net "
"replace operation."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.bulk_replace:24
msgid ""
"It is typical that this method be combined with use of the "
":meth:`.AttributeEvents.append` event.    When using both of these "
"events, note that a bulk replace operation will invoke the "
":meth:`.AttributeEvents.append` event for all new items, even after "
":meth:`.AttributeEvents.bulk_replace` has been invoked for the collection"
" as a whole.  In order to determine if an :meth:`.AttributeEvents.append`"
" event is part of a bulk replace, use the symbol "
":attr:`~.attributes.OP_BULK_REPLACE` to test the incoming initiator::"
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.bulk_replace:55
msgid ""
"a sequence (e.g. a list) of the values being set.  The handler can modify"
" this list in place."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.bulk_replace:57
#: sqlalchemy.orm.events.AttributeEvents.modified:27
msgid ""
"An instance of :class:`.attributes.Event` representing the initiation of "
"the event."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.dispose_collection:1
msgid "Receive a 'collection dispose' event."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.dispose_collection:17
msgid ""
"This event is triggered for a collection-based attribute when a "
"collection is replaced, that is::"
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.dispose_collection:24
msgid "The old collection received will contain its previous contents."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.dispose_collection:26
msgid ""
"The collection passed to :meth:`.AttributeEvents.dispose_collection` will"
" now have its contents before the dispose intact; previously, the "
"collection would be empty."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.dispose_collection:31
#: sqlalchemy.orm.events.AttributeEvents.init_collection:42
msgid ""
"the :meth:`.AttributeEvents.init_collection` and "
":meth:`.AttributeEvents.dispose_collection` events supersede the "
":class:`.collection.linker` hook."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.init_collection:1
msgid "Receive a 'collection init' event."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.init_collection:17
msgid ""
"This event is triggered for a collection-based attribute, when the "
"initial \"empty collection\" is first generated for a blank attribute, as"
" well as for when the collection is replaced with a new one, such as via "
"a set event."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.init_collection:22
msgid ""
"E.g., given that ``User.addresses`` is a relationship-based collection, "
"the event is triggered here::"
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.init_collection:28
msgid "and also during replace operations::"
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.init_collection:35
msgid ""
"the new collection.  This will always be generated from what was "
"specified as :paramref:`.RelationshipProperty.collection_class`, and will"
" always be empty."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.init_collection:39
msgid ""
"the :class:`.CollectionAdapter` that will mediate internal access to the "
"collection."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.init_scalar:1
msgid "Receive a scalar \"init\" event."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.init_scalar:17
msgid ""
"This event is invoked when an uninitialized, unpersisted scalar attribute"
" is accessed, e.g. read::"
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.init_scalar:23
msgid ""
"The ORM's default behavior when this occurs for an un-initialized "
"attribute is to return the value ``None``; note this differs from "
"Python's usual behavior of raising ``AttributeError``.    The event here "
"can be used to customize what value is actually returned, with the "
"assumption that the event listener would be mirroring a default generator"
" that is configured on the Core :class:`.Column` object as well."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.init_scalar:31
msgid ""
"Since a default generator on a :class:`.Column` might also produce a "
"changing value such as a timestamp, the "
":meth:`.AttributeEvents.init_scalar` event handler can also be used to "
"**set** the newly returned value, so that a Core-level default generation"
" function effecively fires off only once, but at the moment the attribute"
" is accessed on the non-persisted object.   Normally, no change to the "
"object's state is made when an uninitialized attribute is accessed (much "
"older SQLAlchemy versions did in fact change the object's state)."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.init_scalar:41
msgid ""
"If a default generator on a column returned a particular constant, a "
"handler might be used as follows::"
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.init_scalar:58
msgid ""
"Above, we initialize the attribute ``MyClass.some_attribute`` to the "
"value of ``SOME_CONSTANT``.   The above code includes the following "
"features:"
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.init_scalar:62
msgid ""
"By setting the value ``SOME_CONSTANT`` in the given ``dict_``, we "
"indicate that this value is to be persisted to the database. This "
"supersedes the use of ``SOME_CONSTANT`` in the default generator for the "
":class:`.Column`.  The ``active_column_defaults.py`` example given at "
":ref:`examples_instrumentation` illustrates using the same approach for a"
" changing default, e.g. a timestamp generator.    In this particular "
"example, it is not strictly necessary to do this since ``SOME_CONSTANT`` "
"would be part of the INSERT statement in either case."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.init_scalar:72
msgid ""
"By establishing the ``retval=True`` flag, the value we return from the "
"function will be returned by the attribute getter. Without this flag, the"
" event is assumed to be a passive observer and the return value of our "
"function is ignored."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.init_scalar:77
msgid ""
"The ``propagate=True`` flag is significant if the mapped class includes "
"inheriting subclasses, which would also make use of this event listener."
"  Without this flag, an inheriting subclass will not use our event "
"handler."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.init_scalar:82
msgid ""
"In the above example, the attribute set event "
":meth:`.AttributeEvents.set` as well as the related validation feature "
"provided by :obj:`.orm.validates` is **not** invoked when we apply our "
"value to the given ``dict_``.  To have these events to invoke in response"
" to our newly generated value, apply the value to the given object as a "
"normal attribute set operation::"
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.init_scalar:99
msgid ""
"When multiple listeners are set up, the generation of the value is "
"\"chained\" from one listener to the next by passing the value returned "
"by the previous listener that specifies ``retval=True`` as the ``value`` "
"argument of the next listener."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.init_scalar:109
msgid ""
"the value that is to be returned before this event listener were invoked."
"  This value begins as the value ``None``, however will be the return "
"value of the previous event handler function if multiple listeners are "
"present."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.init_scalar:113
msgid ""
"the attribute dictionary of this mapped object. This is normally the "
"``__dict__`` of the object, but in all cases represents the destination "
"that the attribute system uses to get at the actual value of this "
"attribute.  Placing the value in this dictionary has the effect that the "
"value will be used in the INSERT statement generated by the unit of work."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.init_scalar:123
msgid ""
":ref:`examples_instrumentation` - see the ``active_column_defaults.py`` "
"example."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.modified:1
msgid "Receive a 'modified' event."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.modified:17
msgid ""
"This event is triggered when the :func:`.attributes.flag_modified` "
"function is used to trigger a modify event on an attribute without any "
"specific value being set."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.remove:1
msgid "Receive a collection remove event."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.remove:20
msgid "the value being removed."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.remove:21
#: sqlalchemy.orm.events.AttributeEvents.set:39
msgid ""
"An instance of :class:`.attributes.Event` representing the initiation of "
"the event.  May be modified from its original value by backref handlers "
"in order to control chained event propagation.  .. versionchanged:: 0.9.0"
" the ``initiator`` argument is now    passed as a "
":class:`.attributes.Event` object, and may be    modified by backref "
"handlers within a chain of backref-linked    events."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.remove:21
#: sqlalchemy.orm.events.AttributeEvents.set:39
msgid ""
"An instance of :class:`.attributes.Event` representing the initiation of "
"the event.  May be modified from its original value by backref handlers "
"in order to control chained event propagation."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.remove:26
#: sqlalchemy.orm.events.AttributeEvents.set:44
msgid ""
"the ``initiator`` argument is now passed as a :class:`.attributes.Event` "
"object, and may be modified by backref handlers within a chain of "
"backref-linked events."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.remove:31
msgid "No return value is defined for this event."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.set:1
msgid "Receive a scalar set event."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.set:29
msgid ""
"the value being set.  If this listener is registered with "
"``retval=True``, the listener function must return this value, or a new "
"value which replaces it."
msgstr ""

#: of sqlalchemy.orm.events.AttributeEvents.set:33
msgid ""
"the previous value being replaced.  This may also be the symbol "
"``NEVER_SET`` or ``NO_VALUE``. If the listener is registered with "
"``active_history=True``, the previous value of the attribute will be "
"loaded from the database if the existing value is currently unloaded or "
"expired."
msgstr ""

#: ../../orm/events.rst:20
msgid "Mapper Events"
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents:1
msgid "Define events specific to mappings."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents:12
#: sqlalchemy.orm.events.MapperEvents:19
msgid "Available targets include:"
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents:14
#: sqlalchemy.orm.events.MapperEvents:21
msgid "mapped classes"
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents:15
#: sqlalchemy.orm.events.MapperEvents:22
msgid ""
"unmapped superclasses of mapped or to-be-mapped classes (using the "
"``propagate=True`` flag)"
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents:17
#: sqlalchemy.orm.events.MapperEvents:24
msgid ":class:`.Mapper` objects"
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents:18
#: sqlalchemy.orm.events.MapperEvents:25
msgid ""
"the :class:`.Mapper` class itself and the :func:`.mapper` function "
"indicate listening for all mappers."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents:28
msgid ""
"mapper events can be associated with unmapped superclasses of mapped "
"classes."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents:31
msgid ""
"Mapper events provide hooks into critical sections of the mapper, "
"including those related to object instrumentation, object loading, and "
"object persistence. In particular, the persistence methods "
":meth:`~.MapperEvents.before_insert`, and "
":meth:`~.MapperEvents.before_update` are popular places to augment the "
"state being persisted - however, these methods operate with several "
"significant restrictions. The user is encouraged to evaluate the "
":meth:`.SessionEvents.before_flush` and "
":meth:`.SessionEvents.after_flush` methods as more flexible and user-"
"friendly hooks in which to apply additional database state during a "
"flush."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents:44
msgid ""
"When using :class:`.MapperEvents`, several modifiers are available to the"
" :func:`.event.listen` function."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents:47
msgid ""
"When True, the event listener should be applied to all inheriting mappers"
" and/or the mappers of inheriting classes, as well as any mapper which is"
" the target of this listener."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents:34
#: sqlalchemy.orm.events.MapperEvents:51
msgid ""
"When True, the \"target\" argument passed to applicable event listener "
"functions will be the instance's :class:`.InstanceState` management "
"object, rather than the mapped instance itself."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents:55
msgid ""
"when True, the user-defined event function must have a return value, the "
"purpose of which is either to control subsequent event propagation, or to"
" otherwise alter the operation in progress by the mapper.   Possible "
"return values are:  * ``sqlalchemy.orm.interfaces.EXT_CONTINUE`` - "
"continue event   processing normally. * "
"``sqlalchemy.orm.interfaces.EXT_STOP`` - cancel all subsequent   event "
"handlers in the chain. * other values - the return value specified by "
"specific listeners."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents:55
msgid ""
"when True, the user-defined event function must have a return value, the "
"purpose of which is either to control subsequent event propagation, or to"
" otherwise alter the operation in progress by the mapper.   Possible "
"return values are:"
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents:61
msgid ""
"``sqlalchemy.orm.interfaces.EXT_CONTINUE`` - continue event processing "
"normally."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents:63
msgid ""
"``sqlalchemy.orm.interfaces.EXT_STOP`` - cancel all subsequent event "
"handlers in the chain."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents:65
msgid "other values - the return value specified by specific listeners."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_configured:1
msgid "Called after a series of mappers have been configured."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_configured:17
msgid ""
"The :meth:`.MapperEvents.after_configured` event is invoked each time the"
" :func:`.orm.configure_mappers` function is invoked, after the function "
"has completed its work. :func:`.orm.configure_mappers` is typically "
"invoked automatically as mappings are first used, as well as each time "
"new mappers have been made available and new mapper use is detected."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_configured:25
msgid ""
"Contrast this event to the :meth:`.MapperEvents.mapper_configured` event,"
" which is called on a per-mapper basis while the configuration operation "
"proceeds; unlike that event, when this event is invoked, all cross-"
"configurations (e.g. backrefs) will also have been made available for any"
" mappers that were pending. Also contrast to "
":meth:`.MapperEvents.before_configured`, which is invoked before the "
"series of mappers has been configured."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_configured:33
#: sqlalchemy.orm.events.MapperEvents.before_configured:25
msgid ""
"This event can **only** be applied to the :class:`.Mapper` class or "
":func:`.mapper` function, and not to individual mappings or mapped "
"classes.  It is only invoked for all mappings as a whole::"
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_configured:43
msgid ""
"Theoretically this event is called once per application, but is actually "
"called any time new mappers have been affected by a "
":func:`.orm.configure_mappers` call.   If new mappings are constructed "
"after existing ones have already been used, this event will likely be "
"called again.  To ensure that a particular event is only called once and "
"no further, the ``once=True`` argument (new in 0.9.4) can be applied::"
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_configured:59
#: sqlalchemy.orm.events.MapperEvents.before_configured:60
msgid ":meth:`.MapperEvents.mapper_configured`"
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_configured:61
#: sqlalchemy.orm.events.MapperEvents.mapper_configured:59
msgid ":meth:`.MapperEvents.before_configured`"
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_delete:1
msgid ""
"Receive an object instance after a DELETE statement has been emitted "
"corresponding to that instance."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_delete:18
#: sqlalchemy.orm.events.MapperEvents.before_delete:18
msgid ""
"This event is used to emit additional SQL statements on the given "
"connection as well as to perform application specific bookkeeping related"
" to a deletion event."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_delete:22
msgid ""
"The event is often called for a batch of objects of the same class after "
"their DELETE statements have been emitted at once in a previous step."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_delete:28
#: sqlalchemy.orm.events.MapperEvents.after_insert:34
#: sqlalchemy.orm.events.MapperEvents.after_update:52
#: sqlalchemy.orm.events.MapperEvents.before_delete:28
#: sqlalchemy.orm.events.MapperEvents.before_insert:34
#: sqlalchemy.orm.events.MapperEvents.before_update:53
msgid ""
"Mapper-level flush events only allow **very limited operations**, on "
"attributes local to the row being operated upon only, as well as allowing"
" any SQL to be emitted on the given :class:`.Connection`.  **Please read "
"fully** the notes at :ref:`session_persistence_mapper` for guidelines on "
"using these methods; generally, the :meth:`.SessionEvents.before_flush` "
"method should be preferred for general on-flush changes."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_delete:36
#: sqlalchemy.orm.events.MapperEvents.after_insert:42
#: sqlalchemy.orm.events.MapperEvents.after_update:60
#: sqlalchemy.orm.events.MapperEvents.before_delete:36
#: sqlalchemy.orm.events.MapperEvents.before_insert:42
#: sqlalchemy.orm.events.MapperEvents.before_update:61
#: sqlalchemy.orm.events.MapperEvents.instrument_class:31
#: sqlalchemy.orm.events.MapperEvents.mapper_configured:53
msgid "the :class:`.Mapper` which is the target of this event."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_delete:38
#: sqlalchemy.orm.events.MapperEvents.before_delete:38
msgid ""
"the :class:`.Connection` being used to emit DELETE statements for this "
"instance.  This provides a handle into the current transaction on the "
"target database specific to this instance."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_delete:42
#: sqlalchemy.orm.events.MapperEvents.before_delete:42
msgid ""
"the mapped instance being deleted.  If the event is configured with "
"``raw=True``, this will instead be the :class:`.InstanceState` state-"
"management object associated with the instance."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_delete:46
#: sqlalchemy.orm.events.MapperEvents.after_insert:52
#: sqlalchemy.orm.events.MapperEvents.after_update:70
#: sqlalchemy.orm.events.MapperEvents.before_delete:46
#: sqlalchemy.orm.events.MapperEvents.before_insert:52
#: sqlalchemy.orm.events.MapperEvents.before_update:71
msgid "No return value is supported by this event."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_delete:50
#: sqlalchemy.orm.events.MapperEvents.after_insert:56
#: sqlalchemy.orm.events.MapperEvents.after_update:74
#: sqlalchemy.orm.events.MapperEvents.before_delete:50
#: sqlalchemy.orm.events.MapperEvents.before_insert:56
#: sqlalchemy.orm.events.MapperEvents.before_update:75
#: sqlalchemy.orm.events.SessionEvents.after_flush:32
#: sqlalchemy.orm.events.SessionEvents.after_flush_postexec:34
#: sqlalchemy.orm.events.SessionEvents.before_flush:30
msgid ":ref:`session_persistence_events`"
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_insert:1
msgid ""
"Receive an object instance after an INSERT statement is emitted "
"corresponding to that instance."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_insert:18
msgid ""
"This event is used to modify in-Python-only state on the instance after "
"an INSERT occurs, as well as to emit additional SQL statements on the "
"given connection."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_insert:23
msgid ""
"The event is often called for a batch of objects of the same class after "
"their INSERT statements have been emitted at once in a previous step. In "
"the extremely rare case that this is not desirable, the :func:`.mapper` "
"can be configured with ``batch=False``, which will cause batches of "
"instances to be broken up into individual (and more poorly performing) "
"event->persist->event steps."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_insert:44
#: sqlalchemy.orm.events.MapperEvents.before_insert:44
msgid ""
"the :class:`.Connection` being used to emit INSERT statements for this "
"instance.  This provides a handle into the current transaction on the "
"target database specific to this instance."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_insert:48
#: sqlalchemy.orm.events.MapperEvents.after_update:66
#: sqlalchemy.orm.events.MapperEvents.before_insert:48
#: sqlalchemy.orm.events.MapperEvents.before_update:67
msgid ""
"the mapped instance being persisted.  If the event is configured with "
"``raw=True``, this will instead be the :class:`.InstanceState` state-"
"management object associated with the instance."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_update:1
msgid ""
"Receive an object instance after an UPDATE statement is emitted "
"corresponding to that instance."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_update:18
msgid ""
"This event is used to modify in-Python-only state on the instance after "
"an UPDATE occurs, as well as to emit additional SQL statements on the "
"given connection."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_update:23
msgid ""
"This method is called for all instances that are marked as \"dirty\", "
"*even those which have no net changes to their column-based attributes*, "
"and for which no UPDATE statement has proceeded. An object is marked as "
"dirty when any of its column-based attributes have a \"set attribute\" "
"operation called or when any of its collections are modified. If, at "
"update time, no column-based attributes have any net changes, no UPDATE "
"statement will be issued. This means that an instance being sent to "
":meth:`~.MapperEvents.after_update` is *not* a guarantee that an UPDATE "
"statement has been issued."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_update:36
msgid ""
"To detect if the column-based attributes on the object have net changes, "
"and therefore resulted in an UPDATE statement, use "
"``object_session(instance).is_modified(instance, "
"include_collections=False)``."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_update:41
msgid ""
"The event is often called for a batch of objects of the same class after "
"their UPDATE statements have been emitted at once in a previous step. In "
"the extremely rare case that this is not desirable, the :func:`.mapper` "
"can be configured with ``batch=False``, which will cause batches of "
"instances to be broken up into individual (and more poorly performing) "
"event->persist->event steps."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.after_update:62
#: sqlalchemy.orm.events.MapperEvents.before_update:63
msgid ""
"the :class:`.Connection` being used to emit UPDATE statements for this "
"instance.  This provides a handle into the current transaction on the "
"target database specific to this instance."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.before_configured:1
msgid "Called before a series of mappers have been configured."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.before_configured:17
msgid ""
"The :meth:`.MapperEvents.before_configured` event is invoked each time "
"the :func:`.orm.configure_mappers` function is invoked, before the "
"function has done any of its work. :func:`.orm.configure_mappers` is "
"typically invoked automatically as mappings are first used, as well as "
"each time new mappers have been made available and new mapper use is "
"detected."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.before_configured:35
msgid ""
"Contrast this event to :meth:`.MapperEvents.after_configured`, which is "
"invoked after the series of mappers has been configured, as well as "
":meth:`.MapperEvents.mapper_configured`, which is invoked on a per-mapper"
" basis as each one is configured to the extent possible."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.before_configured:40
msgid ""
"Theoretically this event is called once per application, but is actually "
"called any time new mappers are to be affected by a "
":func:`.orm.configure_mappers` call.   If new mappings are constructed "
"after existing ones have already been used, this event will likely be "
"called again.  To ensure that a particular event is only called once and "
"no further, the ``once=True`` argument (new in 0.9.4) can be applied::"
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.before_configured:62
#: sqlalchemy.orm.events.MapperEvents.mapper_configured:61
msgid ":meth:`.MapperEvents.after_configured`"
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.before_delete:1
msgid ""
"Receive an object instance before a DELETE statement is emitted "
"corresponding to that instance."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.before_delete:22
msgid ""
"The event is often called for a batch of objects of the same class before"
" their DELETE statements are emitted at once in a later step."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.before_insert:1
msgid ""
"Receive an object instance before an INSERT statement is emitted "
"corresponding to that instance."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.before_insert:18
msgid ""
"This event is used to modify local, non-object related attributes on the "
"instance before an INSERT occurs, as well as to emit additional SQL "
"statements on the given connection."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.before_insert:23
msgid ""
"The event is often called for a batch of objects of the same class before"
" their INSERT statements are emitted at once in a later step. In the "
"extremely rare case that this is not desirable, the :func:`.mapper` can "
"be configured with ``batch=False``, which will cause batches of instances"
" to be broken up into individual (and more poorly performing) "
"event->persist->event steps."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.before_update:1
msgid ""
"Receive an object instance before an UPDATE statement is emitted "
"corresponding to that instance."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.before_update:18
msgid ""
"This event is used to modify local, non-object related attributes on the "
"instance before an UPDATE occurs, as well as to emit additional SQL "
"statements on the given connection."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.before_update:23
msgid ""
"This method is called for all instances that are marked as \"dirty\", "
"*even those which have no net changes to their column-based attributes*. "
"An object is marked as dirty when any of its column-based attributes have"
" a \"set attribute\" operation called or when any of its collections are "
"modified. If, at update time, no column-based attributes have any net "
"changes, no UPDATE statement will be issued. This means that an instance "
"being sent to :meth:`~.MapperEvents.before_update` is *not* a guarantee "
"that an UPDATE statement will be issued, although you can affect the "
"outcome here by modifying attributes so that a net change in value does "
"exist."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.before_update:37
msgid ""
"To detect if the column-based attributes on the object have net changes, "
"and will therefore generate an UPDATE statement, use "
"``object_session(instance).is_modified(instance, "
"include_collections=False)``."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.before_update:42
msgid ""
"The event is often called for a batch of objects of the same class before"
" their UPDATE statements are emitted at once in a later step. In the "
"extremely rare case that this is not desirable, the :func:`.mapper` can "
"be configured with ``batch=False``, which will cause batches of instances"
" to be broken up into individual (and more poorly performing) "
"event->persist->event steps."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.instrument_class:1
msgid ""
"Receive a class when the mapper is first constructed, before "
"instrumentation is applied to the mapped class."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.instrument_class:18
msgid ""
"This event is the earliest phase of mapper construction. Most attributes "
"of the mapper are not yet initialized."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.instrument_class:21
msgid ""
"This listener can either be applied to the :class:`.Mapper` class "
"overall, or to any un-mapped class which serves as a base for classes "
"that will be mapped (using the ``propagate=True`` flag)::"
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.instrument_class:33
#: sqlalchemy.orm.events.MapperEvents.mapper_configured:55
msgid "the mapped class."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.mapper_configured:1
msgid ""
"Called when a specific mapper has completed its own configuration within "
"the scope of the :func:`.configure_mappers` call."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.mapper_configured:18
msgid ""
"The :meth:`.MapperEvents.mapper_configured` event is invoked for each "
"mapper that is encountered when the :func:`.orm.configure_mappers` "
"function proceeds through the current list of not-yet-configured mappers."
" :func:`.orm.configure_mappers` is typically invoked automatically as "
"mappings are first used, as well as each time new mappers have been made "
"available and new mapper use is detected."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.mapper_configured:27
msgid ""
"When the event is called, the mapper should be in its final state, but "
"**not including backrefs** that may be invoked from other mappers; they "
"might still be pending within the configuration operation.    "
"Bidirectional relationships that are instead configured via the "
":paramref:`.orm.relationship.back_populates` argument *will* be fully "
"available, since this style of relationship does not rely upon other "
"possibly-not-configured mappers to know that they exist."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.mapper_configured:37
msgid ""
"For an event that is guaranteed to have **all** mappers ready to go "
"including backrefs that are defined only on other mappings, use the "
":meth:`.MapperEvents.after_configured` event; this event invokes only "
"after all known mappings have been fully configured."
msgstr ""

#: of sqlalchemy.orm.events.MapperEvents.mapper_configured:43
msgid ""
"The :meth:`.MapperEvents.mapper_configured` event, unlike "
":meth:`.MapperEvents.before_configured` or "
":meth:`.MapperEvents.after_configured`, is called for each mapper/class "
"individually, and the mapper is passed to the event itself.  It also is "
"called exactly once for a particular mapper.  The event is therefore "
"useful for configurational steps that benefit from being invoked just "
"once on a specific mapper basis, which don't require that \"backref\" "
"configurations are necessarily ready yet."
msgstr ""

#: ../../orm/events.rst:26
msgid "Instance Events"
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents:1
msgid "Define events specific to object lifecycle."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents:21
msgid ""
"instance events can be associated with unmapped superclasses of mapped "
"classes."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents:24
msgid ""
"Instance events are closely related to mapper events, but are more "
"specific to the instance and its instrumentation, rather than its system "
"of persistence."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents:28
msgid ""
"When using :class:`.InstanceEvents`, several modifiers are available to "
"the :func:`.event.listen` function."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents:31
msgid ""
"When True, the event listener should be applied to all inheriting classes"
" as well as the class which is the target of this listener."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.expire:1
msgid ""
"Receive an object instance after its attributes or some subset have been "
"expired."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.expire:18
msgid ""
"'keys' is a list of attribute names.  If None, the entire state was "
"expired."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.expire:21
#: sqlalchemy.orm.events.InstanceEvents.init:28
#: sqlalchemy.orm.events.InstanceEvents.init_failure:30
#: sqlalchemy.orm.events.InstanceEvents.load:31
#: sqlalchemy.orm.events.InstanceEvents.pickle:18
#: sqlalchemy.orm.events.InstanceEvents.refresh:21
#: sqlalchemy.orm.events.InstanceEvents.refresh_flush:26
#: sqlalchemy.orm.events.InstanceEvents.unpickle:18
msgid ""
"the mapped instance.  If the event is configured with ``raw=True``, this "
"will instead be the :class:`.InstanceState` state-management object "
"associated with the instance."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.expire:25
msgid ""
"sequence of attribute names which were expired, or None if all attributes"
" were expired."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.first_init:1
msgid "Called when the first instance of a particular mapping is called."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.first_init:17
msgid ""
"This event is called when the ``__init__`` method of a class is called "
"the first time for that particular class.    The event invokes before "
"``__init__`` actually proceeds as well as before the "
":meth:`.InstanceEvents.init` event is invoked."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.init:1
msgid "Receive an instance when its constructor is called."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.init:17
msgid ""
"This method is only called during a userland construction of an object, "
"in conjunction with the object's constructor, e.g. its ``__init__`` "
"method.  It is not called when an object is loaded from the database; see"
" the :meth:`.InstanceEvents.load` event in order to intercept a database "
"load."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.init:23
msgid ""
"The event is called before the actual ``__init__`` constructor of the "
"object is called.  The ``kwargs`` dictionary may be modified in-place in "
"order to affect what is passed to ``__init__``."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.init:32
msgid ""
"positional arguments passed to the ``__init__`` method. This is passed as"
" a tuple and is currently immutable."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.init:34
msgid ""
"keyword arguments passed to the ``__init__`` method. This structure *can*"
" be altered in place."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.init:39
msgid ":meth:`.InstanceEvents.init_failure`"
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.init:41
#: sqlalchemy.orm.events.InstanceEvents.init_failure:43
#: sqlalchemy.orm.events.InstanceEvents.refresh:33
msgid ":meth:`.InstanceEvents.load`"
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.init_failure:1
msgid ""
"Receive an instance when its constructor has been called, and raised an "
"exception."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.init_failure:18
msgid ""
"This method is only called during a userland construction of an object, "
"in conjunction with the object's constructor, e.g. its ``__init__`` "
"method. It is not called when an object is loaded from the database."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.init_failure:23
msgid ""
"The event is invoked after an exception raised by the ``__init__`` method"
" is caught.  After the event is invoked, the original exception is re-"
"raised outwards, so that the construction of the object still raises an "
"exception.   The actual exception and stack trace raised should be "
"present in ``sys.exc_info()``."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.init_failure:34
msgid "positional arguments that were passed to the ``__init__`` method."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.init_failure:36
msgid "keyword arguments that were passed to the ``__init__`` method."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.init_failure:41
#: sqlalchemy.orm.events.InstanceEvents.load:42
msgid ":meth:`.InstanceEvents.init`"
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.load:1
msgid ""
"Receive an object instance after it has been created via ``__new__``, and"
" after initial attribute population has occurred."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.load:19
msgid ""
"This typically occurs when the instance is created based on incoming "
"result rows, and is only called once for that instance's lifetime."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.load:23
msgid ""
"Note that during a result-row load, this method is called upon the first "
"row received for this instance.  Note that some attributes and "
"collections may or may not be loaded or even initialized, depending on "
"what's present in the result rows."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.load:28
msgid ""
"The :meth:`.InstanceEvents.load` event is also available in a class-"
"method decorator format called :func:`.orm.reconstructor`."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.load:35
msgid ""
"the :class:`.QueryContext` corresponding to the current :class:`.Query` "
"in progress.  This argument may be ``None`` if the load does not "
"correspond to a :class:`.Query`, such as during :meth:`.Session.merge`."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.load:44
msgid ":meth:`.InstanceEvents.refresh`"
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.load:46
msgid ":meth:`.SessionEvents.loaded_as_persistent`"
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.load:48
msgid ":ref:`mapping_constructors`"
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.pickle:1
msgid "Receive an object instance when its associated state is being pickled."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.pickle:22
msgid ""
"the dictionary returned by :class:`.InstanceState.__getstate__`, "
"containing the state to be pickled."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.refresh:1
msgid ""
"Receive an object instance after one or more attributes have been "
"refreshed from a query."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.refresh:18
msgid ""
"Contrast this to the :meth:`.InstanceEvents.load` method, which is "
"invoked when the object is first loaded from a query."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.refresh:25
msgid ""
"the :class:`.QueryContext` corresponding to the current :class:`.Query` "
"in progress."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.refresh:27
msgid ""
"sequence of attribute names which were populated, or None if all column-"
"mapped, non-deferred attributes were populated."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.refresh_flush:1
msgid ""
"Receive an object instance after one or more attributes have been "
"refreshed within the persistence of the object."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.refresh_flush:18
msgid ""
"This event is the same as :meth:`.InstanceEvents.refresh` except it is "
"invoked within the unit of work flush process, and the values here "
"typically come from the process of handling an INSERT or UPDATE, such as "
"via the RETURNING clause or from Python-side default values."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.refresh_flush:30
#: sqlalchemy.orm.events.SessionEvents.after_flush:23
#: sqlalchemy.orm.events.SessionEvents.after_flush_postexec:24
#: sqlalchemy.orm.events.SessionEvents.before_flush:18
msgid ""
"Internal :class:`.UOWTransaction` object which handles the details of the"
" flush."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.refresh_flush:32
msgid "sequence of attribute names which were populated."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.unpickle:1
msgid "Receive an object instance after its associated state has been unpickled."
msgstr ""

#: of sqlalchemy.orm.events.InstanceEvents.unpickle:22
msgid ""
"the dictionary sent to :class:`.InstanceState.__setstate__`, containing "
"the state dictionary which was pickled."
msgstr ""

#: ../../orm/events.rst:32
msgid "Session Events"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents:1
msgid "Define events specific to :class:`.Session` lifecycle."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents:15
msgid ""
"The :func:`~.event.listen` function will accept :class:`.Session` objects"
" as well as the return result of :class:`~.sessionmaker()` and "
":class:`~.scoped_session()`."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents:19
msgid ""
"Additionally, it accepts the :class:`.Session` class which will apply "
"listeners to all :class:`.Session` instances globally."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_attach:1
msgid "Execute after an instance is attached to a session."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_attach:17
msgid "This is called after an add, delete or merge."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_attach:21
msgid ""
"As of 0.8, this event fires off *after* the item has been fully "
"associated with the session, which is different than previous releases.  "
"For event handlers that require the object not yet be part of session "
"state (such as handlers which may autoflush while the target object is "
"not yet complete) consider the new :meth:`.before_attach` event."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_attach:32
msgid ":meth:`~.SessionEvents.before_attach`"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_attach:34
#: sqlalchemy.orm.events.SessionEvents.before_attach:29
#: sqlalchemy.orm.events.SessionEvents.deleted_to_detached:32
#: sqlalchemy.orm.events.SessionEvents.deleted_to_persistent:26
#: sqlalchemy.orm.events.SessionEvents.detached_to_persistent:45
#: sqlalchemy.orm.events.SessionEvents.loaded_as_persistent:34
#: sqlalchemy.orm.events.SessionEvents.pending_to_persistent:31
#: sqlalchemy.orm.events.SessionEvents.pending_to_transient:30
#: sqlalchemy.orm.events.SessionEvents.persistent_to_deleted:41
#: sqlalchemy.orm.events.SessionEvents.persistent_to_detached:40
#: sqlalchemy.orm.events.SessionEvents.persistent_to_transient:29
#: sqlalchemy.orm.events.SessionEvents.transient_to_pending:30
msgid ":ref:`session_lifecycle_events`"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_begin:1
msgid "Execute after a transaction is begun on a connection"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_begin:17
#: sqlalchemy.orm.events.SessionEvents.after_commit:36
#: sqlalchemy.orm.events.SessionEvents.after_flush:22
#: sqlalchemy.orm.events.SessionEvents.after_flush_postexec:23
#: sqlalchemy.orm.events.SessionEvents.after_rollback:28
#: sqlalchemy.orm.events.SessionEvents.after_soft_rollback:32
#: sqlalchemy.orm.events.SessionEvents.before_commit:28
#: sqlalchemy.orm.events.SessionEvents.before_flush:17
msgid "The target :class:`.Session`."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_begin:18
msgid "The :class:`.SessionTransaction`."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_begin:19
msgid ""
"The :class:`~.engine.Connection` object which will be used for SQL "
"statements."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_begin:24
#: sqlalchemy.orm.events.SessionEvents.after_commit:40
msgid ":meth:`~.SessionEvents.before_commit`"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_begin:26
#: sqlalchemy.orm.events.SessionEvents.before_commit:32
msgid ":meth:`~.SessionEvents.after_commit`"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_begin:28
#: sqlalchemy.orm.events.SessionEvents.after_commit:44
#: sqlalchemy.orm.events.SessionEvents.after_transaction_end:49
#: sqlalchemy.orm.events.SessionEvents.before_commit:36
msgid ":meth:`~.SessionEvents.after_transaction_create`"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_begin:30
#: sqlalchemy.orm.events.SessionEvents.after_commit:46
#: sqlalchemy.orm.events.SessionEvents.after_transaction_create:52
#: sqlalchemy.orm.events.SessionEvents.before_commit:38
msgid ":meth:`~.SessionEvents.after_transaction_end`"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_bulk_delete:1
msgid "Execute after a bulk delete operation to the session."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_bulk_delete:23
msgid ""
"The ``after_bulk_delete`` event now accepts the  arguments "
"``delete_context``. Listener functions which accept the previous argument"
"  signature(s) listed above will be automatically  adapted to the new "
"signature."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_bulk_delete:30
msgid "This is called as a result of the :meth:`.Query.delete` method."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_bulk_delete:32
msgid ""
"a \"delete context\" object which contains details about the update, "
"including these attributes:     * ``session`` - the :class:`.Session` "
"involved    * ``query`` -the :class:`.Query` object that this update "
"operation      was called upon.    * ``context`` The "
":class:`.QueryContext` object, corresponding      to the invocation of an"
" ORM query.    * ``result`` the :class:`.ResultProxy` returned as a "
"result of the      bulk DELETE operation."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_bulk_delete:32
msgid ""
"a \"delete context\" object which contains details about the update, "
"including these attributes:"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_bulk_delete:35
#: sqlalchemy.orm.events.SessionEvents.after_bulk_update:35
msgid "``session`` - the :class:`.Session` involved"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_bulk_delete:36
#: sqlalchemy.orm.events.SessionEvents.after_bulk_update:36
msgid ""
"``query`` -the :class:`.Query` object that this update operation was "
"called upon."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_bulk_delete:38
#: sqlalchemy.orm.events.SessionEvents.after_bulk_update:38
msgid ""
"``context`` The :class:`.QueryContext` object, corresponding to the "
"invocation of an ORM query."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_bulk_delete:40
msgid ""
"``result`` the :class:`.ResultProxy` returned as a result of the bulk "
"DELETE operation."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_bulk_update:1
msgid "Execute after a bulk update operation to the session."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_bulk_update:23
msgid ""
"The ``after_bulk_update`` event now accepts the  arguments "
"``update_context``. Listener functions which accept the previous argument"
"  signature(s) listed above will be automatically  adapted to the new "
"signature."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_bulk_update:30
msgid "This is called as a result of the :meth:`.Query.update` method."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_bulk_update:32
msgid ""
"an \"update context\" object which contains details about the update, "
"including these attributes:     * ``session`` - the :class:`.Session` "
"involved    * ``query`` -the :class:`.Query` object that this update "
"operation      was called upon.    * ``context`` The "
":class:`.QueryContext` object, corresponding      to the invocation of an"
" ORM query.    * ``result`` the :class:`.ResultProxy` returned as a "
"result of the      bulk UPDATE operation."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_bulk_update:32
msgid ""
"an \"update context\" object which contains details about the update, "
"including these attributes:"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_bulk_update:40
msgid ""
"``result`` the :class:`.ResultProxy` returned as a result of the bulk "
"UPDATE operation."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_commit:1
msgid "Execute after a commit has occurred."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_commit:19
msgid ""
"The :meth:`~.SessionEvents.after_commit` hook is *not* per-flush, that "
"is, the :class:`.Session` can emit SQL to the database many times within "
"the scope of a transaction. For interception of these events, use the "
":meth:`~.SessionEvents.before_flush`, "
":meth:`~.SessionEvents.after_flush`, or "
":meth:`~.SessionEvents.after_flush_postexec` events."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_commit:30
msgid ""
"The :class:`.Session` is not in an active transaction when the "
":meth:`~.SessionEvents.after_commit` event is invoked, and therefore can "
"not emit SQL.  To emit SQL corresponding to every transaction, use the "
":meth:`~.SessionEvents.before_commit` event."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_commit:42
#: sqlalchemy.orm.events.SessionEvents.before_commit:34
msgid ":meth:`~.SessionEvents.after_begin`"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_flush:1
msgid "Execute after flush has completed, but before commit has been called."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_flush:18
msgid ""
"Note that the session's state is still in pre-flush, i.e. 'new', 'dirty',"
" and 'deleted' lists still show pre-flush state as well as the history "
"settings on instance attributes."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_flush:28
#: sqlalchemy.orm.events.SessionEvents.after_flush_postexec:30
msgid ":meth:`~.SessionEvents.before_flush`"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_flush:30
#: sqlalchemy.orm.events.SessionEvents.before_flush:28
msgid ":meth:`~.SessionEvents.after_flush_postexec`"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_flush_postexec:1
msgid "Execute after flush has completed, and after the post-exec state occurs."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_flush_postexec:18
msgid ""
"This will be when the 'new', 'dirty', and 'deleted' lists are in their "
"final state.  An actual commit() may or may not have occurred, depending "
"on whether or not the flush started its own transaction or participated "
"in a larger transaction."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_flush_postexec:32
#: sqlalchemy.orm.events.SessionEvents.before_flush:26
msgid ":meth:`~.SessionEvents.after_flush`"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_rollback:1
msgid "Execute after a real DBAPI rollback has occurred."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_rollback:17
msgid ""
"Note that this event only fires when the *actual* rollback against the "
"database occurs - it does *not* fire each time the "
":meth:`.Session.rollback` method is called, if the underlying DBAPI "
"transaction has already been rolled back.  In many cases, the "
":class:`.Session` will not be in an \"active\" state during this event, "
"as the current transaction is not valid.   To acquire a :class:`.Session`"
" which is active after the outermost rollback has proceeded, use the "
":meth:`.SessionEvents.after_soft_rollback` event, checking the "
":attr:`.Session.is_active` flag."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_soft_rollback:1
msgid ""
"Execute after any rollback has occurred, including \"soft\" rollbacks "
"that don't actually emit at the DBAPI level."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_soft_rollback:18
msgid ""
"This corresponds to both nested and outer rollbacks, i.e. the innermost "
"rollback that calls the DBAPI's rollback() method, as well as the "
"enclosing rollback calls that only pop themselves from the transaction "
"stack."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_soft_rollback:23
msgid ""
"The given :class:`.Session` can be used to invoke SQL and "
":meth:`.Session.query` operations after an outermost rollback by first "
"checking the :attr:`.Session.is_active` flag::"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_soft_rollback:33
msgid ""
"The :class:`.SessionTransaction` transactional marker object which was "
"just closed.   The current :class:`.SessionTransaction` for the given "
":class:`.Session` is available via the :attr:`.Session.transaction` "
"attribute."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_transaction_create:1
msgid "Execute when a new :class:`.SessionTransaction` is created."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_transaction_create:17
msgid ""
"This event differs from :meth:`~.SessionEvents.after_begin` in that it "
"occurs for each :class:`.SessionTransaction` overall, as opposed to when "
"transactions are begun on individual database connections.  It is also "
"invoked for nested transactions and subtransactions, and is always "
"matched by a corresponding :meth:`~.SessionEvents.after_transaction_end` "
"event (assuming normal operation of the :class:`.Session`)."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_transaction_create:26
#: sqlalchemy.orm.events.SessionEvents.after_transaction_end:23
msgid "the target :class:`.Session`."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_transaction_create:27
msgid ""
"the target :class:`.SessionTransaction`.  To detect if this is the "
"outermost :class:`.SessionTransaction`, as opposed to a "
"\"subtransaction\" or a SAVEPOINT, test that the "
":attr:`.SessionTransaction.parent` attribute is ``None``::         "
"@event.listens_for(session, \"after_transaction_create\")        def "
"after_transaction_create(session, transaction):            if "
"transaction.parent is None:                # work with top-level "
"transaction  To detect if the :class:`.SessionTransaction` is a "
"SAVEPOINT, use the :attr:`.SessionTransaction.nested` attribute::"
"         @event.listens_for(session, \"after_transaction_create\")"
"        def after_transaction_create(session, transaction):            if"
" transaction.nested:                # work with SAVEPOINT transaction"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_transaction_create:27
#: sqlalchemy.orm.events.SessionEvents.after_transaction_end:24
msgid "the target :class:`.SessionTransaction`."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_transaction_create:29
#: sqlalchemy.orm.events.SessionEvents.after_transaction_end:26
msgid ""
"To detect if this is the outermost :class:`.SessionTransaction`, as "
"opposed to a \"subtransaction\" or a SAVEPOINT, test that the "
":attr:`.SessionTransaction.parent` attribute is ``None``::"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_transaction_create:39
#: sqlalchemy.orm.events.SessionEvents.after_transaction_end:36
msgid ""
"To detect if the :class:`.SessionTransaction` is a SAVEPOINT, use the "
":attr:`.SessionTransaction.nested` attribute::"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_transaction_create:50
#: sqlalchemy.orm.events.SessionEvents.after_transaction_end:47
msgid ":class:`.SessionTransaction`"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_transaction_end:1
msgid "Execute when the span of a :class:`.SessionTransaction` ends."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_transaction_end:17
msgid ""
"This event differs from :meth:`~.SessionEvents.after_commit` in that it "
"corresponds to all :class:`.SessionTransaction` objects in use, including"
" those for nested transactions and subtransactions, and is always matched"
" by a corresponding :meth:`~.SessionEvents.after_transaction_create` "
"event."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.after_transaction_end:24
msgid ""
"the target :class:`.SessionTransaction`.  To detect if this is the "
"outermost :class:`.SessionTransaction`, as opposed to a "
"\"subtransaction\" or a SAVEPOINT, test that the "
":attr:`.SessionTransaction.parent` attribute is ``None``::         "
"@event.listens_for(session, \"after_transaction_create\")        def "
"after_transaction_end(session, transaction):            if "
"transaction.parent is None:                # work with top-level "
"transaction  To detect if the :class:`.SessionTransaction` is a "
"SAVEPOINT, use the :attr:`.SessionTransaction.nested` attribute::"
"         @event.listens_for(session, \"after_transaction_create\")"
"        def after_transaction_end(session, transaction):            if "
"transaction.nested:                # work with SAVEPOINT transaction"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.before_attach:1
msgid "Execute before an instance is attached to a session."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.before_attach:17
msgid ""
"This is called before an add, delete or merge causes the object to be "
"part of the session."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.before_attach:20
msgid ""
"Note that :meth:`~.SessionEvents.after_attach` now fires off after the "
"item is part of the session. :meth:`.before_attach` is provided for those"
" cases where the item should not yet be part of the session state."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.before_attach:27
msgid ":meth:`~.SessionEvents.after_attach`"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.before_commit:1
msgid "Execute before commit is called."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.before_commit:19
msgid ""
"The :meth:`~.SessionEvents.before_commit` hook is *not* per-flush, that "
"is, the :class:`.Session` can emit SQL to the database many times within "
"the scope of a transaction. For interception of these events, use the "
":meth:`~.SessionEvents.before_flush`, "
":meth:`~.SessionEvents.after_flush`, or "
":meth:`~.SessionEvents.after_flush_postexec` events."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.before_flush:1
msgid "Execute before flush process has started."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.before_flush:20
msgid ""
"Usually ``None``, this is the collection of objects which can be passed "
"to the :meth:`.Session.flush` method (note this usage is deprecated)."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.deleted_to_detached:1
msgid "Intercept the \"deleted to detached\" transition for a specific object."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.deleted_to_detached:17
msgid ""
"This event is invoked when a deleted object is evicted from the session."
"   The typical case when this occurs is when the transaction for a "
":class:`.Session` in which the object was deleted is committed; the "
"object moves from the deleted state to the detached state."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.deleted_to_detached:23
msgid ""
"It is also invoked for objects that were deleted in a flush when the "
":meth:`.Session.expunge_all` or :meth:`.Session.close` events are called,"
" as well as if the object is individually expunged from its deleted state"
" via :meth:`.Session.expunge`."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.deleted_to_persistent:1
msgid "Intercept the \"deleted to persistent\" transition for a specific object."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.deleted_to_persistent:17
msgid ""
"This transition occurs only when an object that's been deleted "
"successfully in a flush is restored due to a call to "
":meth:`.Session.rollback`.   The event is not called under any other "
"circumstances."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.detached_to_persistent:1
msgid "Intercept the \"detached to persistent\" transition for a specific object."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.detached_to_persistent:17
msgid ""
"This event is a specialization of the :meth:`.SessionEvents.after_attach`"
" event which is only invoked for this specific transition.  It is invoked"
" typically during the :meth:`.Session.add` call, as well as during the "
":meth:`.Session.delete` call if the object was not previously associated "
"with the :class:`.Session` (note that an object marked as \"deleted\" "
"remains in the \"persistent\" state until the flush proceeds)."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.detached_to_persistent:28
msgid ""
"If the object becomes persistent as part of a call to "
":meth:`.Session.delete`, the object is **not** yet marked as deleted when"
" this event is called.  To detect deleted objects, check the ``deleted`` "
"flag sent to the :meth:`.SessionEvents.persistent_to_detached` to event "
"after the flush proceeds, or check the :attr:`.Session.deleted` "
"collection within the :meth:`.SessionEvents.before_flush` event if "
"deleted objects need to be intercepted before the flush."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.detached_to_persistent:37
#: sqlalchemy.orm.events.SessionEvents.loaded_as_persistent:26
#: sqlalchemy.orm.events.SessionEvents.pending_to_persistent:23
#: sqlalchemy.orm.events.SessionEvents.pending_to_transient:22
#: sqlalchemy.orm.events.SessionEvents.persistent_to_detached:28
#: sqlalchemy.orm.events.SessionEvents.persistent_to_transient:21
#: sqlalchemy.orm.events.SessionEvents.transient_to_pending:22
msgid "target :class:`.Session`"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.detached_to_persistent:39
#: sqlalchemy.orm.events.SessionEvents.loaded_as_persistent:28
#: sqlalchemy.orm.events.SessionEvents.pending_to_persistent:25
#: sqlalchemy.orm.events.SessionEvents.pending_to_transient:24
#: sqlalchemy.orm.events.SessionEvents.persistent_to_detached:30
#: sqlalchemy.orm.events.SessionEvents.persistent_to_transient:23
#: sqlalchemy.orm.events.SessionEvents.transient_to_pending:24
msgid "the ORM-mapped instance being operated upon."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.loaded_as_persistent:1
msgid "Intercept the \"loaded as persistent\" transition for a specific object."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.loaded_as_persistent:17
msgid ""
"This event is invoked within the ORM loading process, and is invoked very"
" similarly to the :meth:`.InstanceEvents.load` event.  However, the event"
" here is linkable to a :class:`.Session` class or instance, rather than "
"to a mapper or class hierarchy, and integrates with the other session "
"lifecycle events smoothly.  The object is guaranteed to be present in the"
" session's identity map when this event is called."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.pending_to_persistent:1
msgid ""
"Intercept the \"pending to persistent\"\" transition for a specific "
"object."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.pending_to_persistent:17
msgid ""
"This event is invoked within the flush process, and is similar to "
"scanning the :attr:`.Session.new` collection within the "
":meth:`.SessionEvents.after_flush` event.  However, in this case the "
"object has already been moved to the persistent state when the event is "
"called."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.pending_to_transient:1
msgid "Intercept the \"pending to transient\" transition for a specific object."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.pending_to_transient:17
msgid ""
"This less common transition occurs when an pending object that has not "
"been flushed is evicted from the session; this can occur when the "
":meth:`.Session.rollback` method rolls back the transaction, or when the "
":meth:`.Session.expunge` method is used."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.persistent_to_deleted:1
msgid "Intercept the \"persistent to deleted\" transition for a specific object."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.persistent_to_deleted:17
msgid ""
"This event is invoked when a persistent object's identity is deleted from"
" the database within a flush, however the object still remains associated"
" with the :class:`.Session` until the transaction completes."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.persistent_to_deleted:22
msgid ""
"If the transaction is rolled back, the object moves again to the "
"persistent state, and the :meth:`.SessionEvents.deleted_to_persistent` "
"event is called. If the transaction is committed, the object becomes "
"detached, which will emit the :meth:`.SessionEvents.deleted_to_detached` "
"event."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.persistent_to_deleted:29
msgid ""
"Note that while the :meth:`.Session.delete` method is the primary public "
"interface to mark an object as deleted, many objects get deleted due to "
"cascade rules, which are not always determined until flush time.  "
"Therefore, there's no way to catch every object that will be deleted "
"until the flush has proceeded. the "
":meth:`.SessionEvents.persistent_to_deleted` event is therefore invoked "
"at the end of a flush."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.persistent_to_detached:1
msgid "Intercept the \"persistent to detached\" transition for a specific object."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.persistent_to_detached:17
msgid ""
"This event is invoked when a persistent object is evicted from the "
"session.  There are many conditions that cause this to happen, including:"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.persistent_to_detached:21
msgid "using a method such as :meth:`.Session.expunge` or :meth:`.Session.close`"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.persistent_to_detached:24
msgid ""
"Calling the :meth:`.Session.rollback` method, when the object was part of"
" an INSERT statement for that session's transaction"
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.persistent_to_detached:32
msgid ""
"boolean.  If True, indicates this object moved to the detached state "
"because it was marked as deleted and flushed."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.persistent_to_transient:1
msgid ""
"Intercept the \"persistent to transient\" transition for a specific "
"object."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.persistent_to_transient:17
msgid ""
"This less common transition occurs when an pending object that has has "
"been flushed is evicted from the session; this can occur when the "
":meth:`.Session.rollback` method rolls back the transaction."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.transient_to_pending:1
msgid "Intercept the \"transient to pending\" transition for a specific object."
msgstr ""

#: of sqlalchemy.orm.events.SessionEvents.transient_to_pending:17
msgid ""
"This event is a specialization of the :meth:`.SessionEvents.after_attach`"
" event which is only invoked for this specific transition.  It is invoked"
" typically during the :meth:`.Session.add` call."
msgstr ""

#: ../../orm/events.rst:38
msgid "Query Events"
msgstr ""

#: of sqlalchemy.orm.events.QueryEvents:1
msgid "Represent events within the construction of a :class:`.Query` object."
msgstr ""

#: of sqlalchemy.orm.events.QueryEvents:3
msgid ""
"The events here are intended to be used with an as-yet-unreleased "
"inspection system for :class:`.Query`.   Some very basic operations are "
"possible now, however the inspection system is intended to allow complex "
"query manipulations to be automated."
msgstr ""

#: of sqlalchemy.orm.events.QueryEvents.before_compile:1
msgid ""
"Receive the :class:`.Query` object before it is composed into a core "
":class:`.Select` object."
msgstr ""

#: of sqlalchemy.orm.events.QueryEvents.before_compile:18
msgid "This event is intended to allow changes to the query given::"
msgstr ""

#: of sqlalchemy.orm.events.QueryEvents.before_compile:28
msgid ""
"The event should normally be listened with the ``retval=True`` parameter "
"set, so that the modified query may be returned."
msgstr ""

#: ../../orm/events.rst:44
msgid "Instrumentation Events"
msgstr ""

#: of sqlalchemy.orm.instrumentation:1
msgid "Defines SQLAlchemy's system of class instrumentation."
msgstr ""

#: of sqlalchemy.orm.instrumentation:3
msgid ""
"This module is usually not directly visible to user applications, but "
"defines a large part of the ORM's interactivity."
msgstr ""

#: of sqlalchemy.orm.instrumentation:6
msgid ""
"instrumentation.py deals with registration of end-user classes for state "
"tracking.   It interacts closely with state.py and attributes.py which "
"establish per-instance and per-class-attribute instrumentation, "
"respectively."
msgstr ""

#: of sqlalchemy.orm.instrumentation:11
msgid ""
"The class instrumentation system can be customized on a per-class or "
"global basis using the :mod:`sqlalchemy.ext.instrumentation` module, "
"which provides the means to build and specify alternate instrumentation "
"forms."
msgstr ""

#: of sqlalchemy.orm.events.InstrumentationEvents:1
msgid "Events related to class instrumentation events."
msgstr ""

#: of sqlalchemy.orm.events.InstrumentationEvents:3
msgid ""
"The listeners here support being established against any new style class,"
" that is any object that is a subclass of 'type'.  Events will then be "
"fired off for events against that class.  If the \"propagate=True\" flag "
"is passed to event.listen(), the event will fire off for subclasses of "
"that class as well."
msgstr ""

#: of sqlalchemy.orm.events.InstrumentationEvents:10
msgid ""
"The Python ``type`` builtin is also accepted as a target, which when used"
" has the effect of events being emitted for all classes."
msgstr ""

#: of sqlalchemy.orm.events.InstrumentationEvents:14
msgid ""
"Note the \"propagate\" flag here is defaulted to ``True``, unlike the "
"other class level events where it defaults to ``False``.  This means that"
" new subclasses will also be the subject of these events, when a listener"
" is established on a superclass."
msgstr ""

#: of sqlalchemy.orm.events.InstrumentationEvents:20
msgid ""
"- events here will emit based on comparing the incoming class to the type"
" of class passed to :func:`.event.listen`.  Previously, the event would "
"fire for any class unconditionally regardless of what class was sent for "
"listening, despite documentation which stated the contrary."
msgstr ""

#: of sqlalchemy.orm.events.InstrumentationEvents.attribute_instrument:14
msgid "Called when an attribute is instrumented."
msgstr ""

#: of sqlalchemy.orm.events.InstrumentationEvents.class_instrument:1
msgid "Called after the given class is instrumented."
msgstr ""

#: of sqlalchemy.orm.events.InstrumentationEvents.class_instrument:17
#: sqlalchemy.orm.events.InstrumentationEvents.class_uninstrument:17
msgid "To get at the :class:`.ClassManager`, use :func:`.manager_of_class`."
msgstr ""

#: of sqlalchemy.orm.events.InstrumentationEvents.class_uninstrument:1
msgid "Called before the given class is uninstrumented."
msgstr ""

