# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: SQLAlchemy 1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-02-21 14:32+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../orm/basic_relationships.rst:4
msgid "Basic Relationship Patterns"
msgstr ""

#: ../../orm/basic_relationships.rst:6
msgid "A quick walkthrough of the basic relational patterns."
msgstr ""

#: ../../orm/basic_relationships.rst:8
msgid "The imports used for each of the following sections is as follows::"
msgstr ""

#: ../../orm/basic_relationships.rst:18
msgid "One To Many"
msgstr ""

#: ../../orm/basic_relationships.rst:20
msgid ""
"A one to many relationship places a foreign key on the child table "
"referencing the parent.  :func:`.relationship` is then specified on the "
"parent, as referencing a collection of items represented by the child::"
msgstr ""

#: ../../orm/basic_relationships.rst:34
msgid ""
"To establish a bidirectional relationship in one-to-many, where the "
"\"reverse\" side is a many to one, specify an additional "
":func:`.relationship` and connect the two using the "
":paramref:`.relationship.back_populates` parameter::"
msgstr ""

#: ../../orm/basic_relationships.rst:49
msgid "``Child`` will get a ``parent`` attribute with many-to-one semantics."
msgstr ""

#: ../../orm/basic_relationships.rst:51
msgid ""
"Alternatively, the :paramref:`~.relationship.backref` option may be used "
"on a single :func:`.relationship` instead of using "
":paramref:`~.relationship.back_populates`::"
msgstr ""

#: ../../orm/basic_relationships.rst:62
msgid "Many To One"
msgstr ""

#: ../../orm/basic_relationships.rst:64
msgid ""
"Many to one places a foreign key in the parent table referencing the "
"child. :func:`.relationship` is declared on the parent, where a new "
"scalar-holding attribute will be created::"
msgstr ""

#: ../../orm/basic_relationships.rst:78
msgid ""
"Bidirectional behavior is achieved by adding a second "
":func:`.relationship` and applying the "
":paramref:`.relationship.back_populates` parameter in both directions::"
msgstr ""

#: ../../orm/basic_relationships.rst:93
msgid ""
"Alternatively, the :paramref:`~.relationship.backref` parameter may be "
"applied to a single :func:`.relationship`, such as ``Parent.child``::"
msgstr ""

#: ../../orm/basic_relationships.rst:105
msgid "One To One"
msgstr ""

#: ../../orm/basic_relationships.rst:107
msgid ""
"One To One is essentially a bidirectional relationship with a scalar "
"attribute on both sides. To achieve this, the "
":paramref:`~.relationship.uselist` flag indicates the placement of a "
"scalar attribute instead of a collection on the \"many\" side of the "
"relationship. To convert one-to-many into one-to-one::"
msgstr ""

#: ../../orm/basic_relationships.rst:123
msgid "Or for many-to-one::"
msgstr ""

#: ../../orm/basic_relationships.rst:136
msgid ""
"As always, the :paramref:`.relationship.backref` and :func:`.backref` "
"functions may be used in lieu of the "
":paramref:`.relationship.back_populates` approach; to specify ``uselist``"
" on a backref, use the :func:`.backref` function::"
msgstr ""

#: ../../orm/basic_relationships.rst:152
msgid "Many To Many"
msgstr ""

#: ../../orm/basic_relationships.rst:154
msgid ""
"Many to Many adds an association table between two classes. The "
"association table is indicated by the "
":paramref:`~.relationship.secondary` argument to :func:`.relationship`.  "
"Usually, the :class:`.Table` uses the :class:`.MetaData` object "
"associated with the declarative base class, so that the "
":class:`.ForeignKey` directives can locate the remote tables with which "
"to link::"
msgstr ""

#: ../../orm/basic_relationships.rst:175
msgid ""
"For a bidirectional relationship, both sides of the relationship contain "
"a collection.  Specify using :paramref:`.relationship.back_populates`, "
"and for each :func:`.relationship` specify the common association table::"
msgstr ""

#: ../../orm/basic_relationships.rst:200
msgid ""
"When using the :paramref:`~.relationship.backref` parameter instead of "
":paramref:`.relationship.back_populates`, the backref will automatically "
"use the same :paramref:`~.relationship.secondary` argument for the "
"reverse relationship::"
msgstr ""

#: ../../orm/basic_relationships.rst:220
msgid ""
"The :paramref:`~.relationship.secondary` argument of "
":func:`.relationship` also accepts a callable that returns the ultimate "
"argument, which is evaluated only when mappers are first used.   Using "
"this, we can define the ``association_table`` at a later point, as long "
"as it's available to the callable after all module initialization is "
"complete::"
msgstr ""

#: ../../orm/basic_relationships.rst:233
msgid ""
"With the declarative extension in use, the traditional \"string name of "
"the table\" is accepted as well, matching the name of the table as stored"
" in ``Base.metadata.tables``::"
msgstr ""

#: ../../orm/basic_relationships.rst:246
msgid "Deleting Rows from the Many to Many Table"
msgstr ""

#: ../../orm/basic_relationships.rst:248
msgid ""
"A behavior which is unique to the :paramref:`~.relationship.secondary` "
"argument to :func:`.relationship` is that the :class:`.Table` which is "
"specified here is automatically subject to INSERT and DELETE statements, "
"as objects are added or removed from the collection. There is **no need "
"to delete from this table manually**.   The act of removing a record from"
" the collection will have the effect of the row being deleted on flush::"
msgstr ""

#: ../../orm/basic_relationships.rst:258
msgid ""
"A question which often arises is how the row in the \"secondary\" table "
"can be deleted when the child object is handed directly to "
":meth:`.Session.delete`::"
msgstr ""

#: ../../orm/basic_relationships.rst:263
msgid "There are several possibilities here:"
msgstr ""

#: ../../orm/basic_relationships.rst:265
msgid ""
"If there is a :func:`.relationship` from ``Parent`` to ``Child``, but "
"there is **not** a reverse-relationship that links a particular ``Child``"
" to each ``Parent``, SQLAlchemy will not have any awareness that when "
"deleting this particular ``Child`` object, it needs to maintain the "
"\"secondary\" table that links it to the ``Parent``.  No delete of the "
"\"secondary\" table will occur."
msgstr ""

#: ../../orm/basic_relationships.rst:270
msgid ""
"If there is a relationship that links a particular ``Child`` to each "
"``Parent``, suppose it's called ``Child.parents``, SQLAlchemy by default "
"will load in the ``Child.parents`` collection to locate all ``Parent`` "
"objects, and remove each row from the \"secondary\" table which "
"establishes this link.  Note that this relationship does not need to be "
"bidrectional; SQLAlchemy is strictly looking at every "
":func:`.relationship` associated with the ``Child`` object being deleted."
msgstr ""

#: ../../orm/basic_relationships.rst:277
msgid ""
"A higher performing option here is to use ON DELETE CASCADE directives "
"with the foreign keys used by the database.   Assuming the database "
"supports this feature, the database itself can be made to automatically "
"delete rows in the \"secondary\" table as referencing rows in \"child\" "
"are deleted.   SQLAlchemy can be instructed to forego actively loading in"
" the ``Child.parents`` collection in this case using the "
":paramref:`~.relationship.passive_deletes` directive on "
":func:`.relationship`; see :ref:`passive_deletes` for more details on "
"this."
msgstr ""

#: ../../orm/basic_relationships.rst:286
msgid ""
"Note again, these behaviors are *only* relevant to the "
":paramref:`~.relationship.secondary` option used with "
":func:`.relationship`.   If dealing with association tables that are "
"mapped explicitly and are *not* present in the "
":paramref:`~.relationship.secondary` option of a relevant "
":func:`.relationship`, cascade rules can be used instead to automatically"
" delete entities in reaction to a related entity being deleted - see "
":ref:`unitofwork_cascades` for information on this feature."
msgstr ""

#: ../../orm/basic_relationships.rst:297
msgid "Association Object"
msgstr ""

#: ../../orm/basic_relationships.rst:299
msgid ""
"The association object pattern is a variant on many-to-many: it's used "
"when your association table contains additional columns beyond those "
"which are foreign keys to the left and right tables. Instead of using the"
" :paramref:`~.relationship.secondary` argument, you map a new class "
"directly to the association table. The left side of the relationship "
"references the association object via one-to-many, and the association "
"class references the right side via many-to-one.  Below we illustrate an "
"association table mapped to the ``Association`` class which includes a "
"column called ``extra_data``, which is a string value that is stored "
"along with each association between ``Parent`` and ``Child``::"
msgstr ""

#: ../../orm/basic_relationships.rst:327
msgid ""
"As always, the bidirectional version makes use of "
":paramref:`.relationship.back_populates` or "
":paramref:`.relationship.backref`::"
msgstr ""

#: ../../orm/basic_relationships.rst:348
msgid ""
"Working with the association pattern in its direct form requires that "
"child objects are associated with an association instance before being "
"appended to the parent; similarly, access from parent to child goes "
"through the association object::"
msgstr ""

#: ../../orm/basic_relationships.rst:365
msgid ""
"To enhance the association object pattern such that direct access to the "
"``Association`` object is optional, SQLAlchemy provides the "
":ref:`associationproxy_toplevel` extension. This extension allows the "
"configuration of attributes which will access two \"hops\" with a single "
"access, one \"hop\" to the associated object, and a second to a target "
"attribute."
msgstr ""

#: ../../orm/basic_relationships.rst:374
msgid ""
"The association object pattern **does not coordinate changes with a "
"separate relationship that maps the association table as \"secondary\"**."
msgstr ""

#: ../../orm/basic_relationships.rst:377
msgid ""
"Below, changes made to ``Parent.children`` will not be coordinated with "
"changes made to ``Parent.child_associations`` or "
"``Child.parent_associations`` in Python; while all of these relationships"
" will continue to function normally by themselves, changes on one will "
"not show up in another until the :class:`.Session` is expired, which "
"normally occurs automatically after :meth:`.Session.commit`::"
msgstr ""

#: ../../orm/basic_relationships.rst:404
msgid ""
"Additionally, just as changes to one relationship aren't reflected in the"
" others automatically, writing the same data to both relationships will "
"cause conflicting INSERT or DELETE statements as well, such as below "
"where we establish the same relationship between a ``Parent`` and "
"``Child`` object twice::"
msgstr ""

#: ../../orm/basic_relationships.rst:417
msgid ""
"It's fine to use a mapping like the above if you know what you're doing, "
"though it may be a good idea to apply the ``viewonly=True`` parameter to "
"the \"secondary\" relationship to avoid the issue of redundant changes "
"being logged.  However, to get a foolproof pattern that allows a simple "
"two-object ``Parent->Child`` relationship while still using the "
"association object pattern, use the association proxy extension as "
"documented at :ref:`associationproxy_toplevel`."
msgstr ""

