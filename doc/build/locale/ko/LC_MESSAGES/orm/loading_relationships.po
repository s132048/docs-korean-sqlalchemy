# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: SQLAlchemy 1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-02-21 14:32+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../orm/loading_relationships.rst:6
msgid "Relationship Loading Techniques"
msgstr ""

#: ../../orm/loading_relationships.rst:8
msgid ""
"A big part of SQLAlchemy is providing a wide range of control over how "
"related objects get loaded when querying.   By \"related objects\" we "
"refer to collections or scalar associations configured on a mapper using "
":func:`.relationship`. This behavior can be configured at mapper "
"construction time using the :paramref:`.relationship.lazy` parameter to "
"the :func:`.relationship` function, as well as by using options with the "
":class:`.Query` object."
msgstr ""

#: ../../orm/loading_relationships.rst:15
msgid ""
"The loading of relationships falls into three categories; **lazy** "
"loading, **eager** loading, and **no** loading. Lazy loading refers to "
"objects are returned from a query without the related objects loaded at "
"first.  When the given collection or reference is first accessed on a "
"particular object, an additional SELECT statement is emitted such that "
"the requested collection is loaded."
msgstr ""

#: ../../orm/loading_relationships.rst:22
msgid ""
"Eager loading refers to objects returned from a query with the related "
"collection or scalar reference already loaded up front.  The "
":class:`.Query` achieves this either by augmenting the SELECT statement "
"it would normally emit with a JOIN to load in related rows "
"simultaneously, or by emitting additional SELECT statements after the "
"primary one to load collections or scalar references at once."
msgstr ""

#: ../../orm/loading_relationships.rst:29
msgid ""
"\"No\" loading refers to the disabling of loading on a given "
"relationship, either that the attribute is empty and is just never "
"loaded, or that it raises an error when it is accessed, in order to guard"
" against unwanted lazy loads."
msgstr ""

#: ../../orm/loading_relationships.rst:33
msgid "The primary forms of relationship loading are:"
msgstr ""

#: ../../orm/loading_relationships.rst:35
msgid ""
"**lazy loading** - available via ``lazy='select'`` or the "
":func:`.lazyload` option, this is the form of loading that emits a SELECT"
" statement at attribute access time to lazily load a related reference on"
" a single object at a time.  Lazy loading is detailed at "
":ref:`lazy_loading`."
msgstr ""

#: ../../orm/loading_relationships.rst:40
msgid ""
"**joined loading** - available via ``lazy='joined'`` or the "
":func:`.joinedload` option, this form of loading applies a JOIN to the "
"given SELECT statement so that related rows are loaded in the same result"
" set.   Joined eager loading is detailed at :ref:`joined_eager_loading`."
msgstr ""

#: ../../orm/loading_relationships.rst:45
msgid ""
"**subquery loading** - available via ``lazy='subquery'`` or the "
":func:`.subqueryload` option, this form of loading emits a second SELECT "
"statement which re-states the original query embedded inside of a "
"subquery, then JOINs that subquery to the related table to be loaded to "
"load all members of related collections / scalar references at once.  "
"Subquery eager loading is detailed at :ref:`subquery_eager_loading`."
msgstr ""

#: ../../orm/loading_relationships.rst:51
msgid ""
"**select IN loading** - available via ``lazy='selectin'`` or the "
":func:`.selectinload` option, this form of loading emits a second (or "
"more) SELECT statement which assembles the primary key identifiers of the"
" parent objects into an IN clause, so that all members of related "
"collections / scalar references are loaded at once by primary key.  "
"Select IN loading is detailed at :ref:`selectin_eager_loading`."
msgstr ""

#: ../../orm/loading_relationships.rst:57
msgid ""
"**raise loading** - available via ``lazy='raise'``, "
"``lazy='raise_on_sql'``, or the :func:`.raiseload` option, this form of "
"loading is triggered at the same time a lazy load would normally occur, "
"except it raises an ORM exception in order to guard against the "
"application making unwanted lazy loads. An introduction to raise loading "
"is at :ref:`prevent_lazy_with_raiseload`."
msgstr ""

#: ../../orm/loading_relationships.rst:63
msgid ""
"**no loading** - available via ``lazy='noload'``, or the :func:`.noload` "
"option; this loading style turns the attribute into an empty attribute "
"that will never load or have any loading effect.  \"noload\" is a fairly "
"uncommon loader option."
msgstr ""

#: ../../orm/loading_relationships.rst:71
msgid "Configuring Loader Strategies at Mapping Time"
msgstr ""

#: ../../orm/loading_relationships.rst:73
msgid ""
"The loader strategy for a particular relationship can be configured at "
"mapping time to take place in all cases where an object of the mapped "
"type is loaded, in the absense of any query-level options that modify it."
" This is configured using the :paramref:`.relationship.lazy` parameter to"
" :func:`.relationship`; common values for this parameter include "
"``select``, ``joined``, ``subquery`` and ``selectin``."
msgstr ""

#: ../../orm/loading_relationships.rst:80
msgid ""
"For example, to configure a relationship to use joined eager loading when"
" the parent object is queried::"
msgstr ""

#: ../../orm/loading_relationships.rst:89
msgid ""
"Above, whenever a collection of ``Parent`` objects are loaded, each "
"``Parent`` will also have its ``children`` collection populated, using "
"rows fetched by adding a JOIN to the query for ``Parent`` objects. See "
":ref:`joined_eager_loading` for background on this style of loading."
msgstr ""

#: ../../orm/loading_relationships.rst:94
msgid ""
"The default value of the :paramref:`.relationship.lazy` argument is "
"``\"select\"``, which indicates lazy loading.  See :ref:`lazy_loading` "
"for further background."
msgstr ""

#: ../../orm/loading_relationships.rst:101
msgid "Controlling Loading via Options"
msgstr ""

#: ../../orm/loading_relationships.rst:103
msgid ""
"The other, and possibly more common way to configure loading strategies "
"is to set them up on a per-query basis against specific attributes.  Very"
" detailed control over relationship loading is available using loader "
"options; the most common are :func:`~sqlalchemy.orm.joinedload`, "
":func:`~sqlalchemy.orm.subqueryload`, "
":func:`~sqlalchemy.orm.selectinload` and "
":func:`~sqlalchemy.orm.lazyload`.   The option accepts either the string "
"name of an attribute against a parent, or for greater specificity can "
"accommodate a class-bound attribute directly::"
msgstr ""

#: ../../orm/loading_relationships.rst:122
msgid ""
"The loader options can also be \"chained\" using **method chaining** to "
"specify how loading should occur further levels deep::"
msgstr ""

#: ../../orm/loading_relationships.rst:129
msgid ""
"Chained loader options can be applied against a \"lazy\" loaded "
"collection. This means that when a collection or association is lazily "
"loaded upon access, the specified option will then take effect::"
msgstr ""

#: ../../orm/loading_relationships.rst:137
msgid ""
"Above, the query will return ``Parent`` objects without the ``children`` "
"collections loaded.  When the ``children`` collection on a particular "
"``Parent`` object is first accessed, it will lazy load the related "
"objects, but additionally apply eager loading to the ``subelements`` "
"collection on each member of ``children``."
msgstr ""

#: ../../orm/loading_relationships.rst:143
msgid ""
"Using method chaining, the loader style of each link in the path is "
"explicitly stated.  To navigate along a path without changing the "
"existing loader style of a particular attribute, the :func:`.defaultload`"
" method/function may be used::"
msgstr ""

#: ../../orm/loading_relationships.rst:151
msgid ""
"The loader options applied to an object's lazy-loaded collections are "
"**\"sticky\"** to specific object instances, meaning they will persist "
"upon collections loaded by that specific object for as long as it exists "
"in memory.  For example, given the previous example::"
msgstr ""

#: ../../orm/loading_relationships.rst:160
msgid ""
"if the ``children`` collection on a particular ``Parent`` object loaded "
"by the above query is expired (such as when a :class:`.Session` object's "
"transaction is committed or rolled back, or :meth:`.Session.expire_all` "
"is used), when the ``Parent.children`` collection is next accessed in "
"order to re-load it, the ``Child.subelements`` collection will again be "
"loaded using subquery eager loading.This stays the case even if the above"
" ``Parent`` object is accessed from a subsequent query that specifies a "
"different set of options.To change the options on an existing object "
"without expunging it and re-loading, they must be set explicitly in "
"conjunction with the :meth:`.Query.populate_existing` method::"
msgstr ""

#: ../../orm/loading_relationships.rst:176
msgid ""
"If the objects loaded above are fully cleared from the :class:`.Session`,"
" such as due to garbage collection or that :meth:`.Session.expunge_all` "
"were used, the \"sticky\" options will also be gone and the newly created"
" objects will make use of new options if loaded again."
msgstr ""

#: ../../orm/loading_relationships.rst:181
msgid ""
"A future SQLAlchemy release may add more alternatives to manipulating the"
" loader options on already-loaded objects."
msgstr ""

#: ../../orm/loading_relationships.rst:188
msgid "Lazy Loading"
msgstr ""

#: ../../orm/loading_relationships.rst:190
msgid ""
"By default, all inter-object relationships are **lazy loading**. The "
"scalar or collection attribute associated with a "
":func:`~sqlalchemy.orm.relationship` contains a trigger which fires the "
"first time the attribute is accessed.  This trigger typically issues a "
"SQL call at the point of access in order to load the related object or "
"objects:"
msgstr ""

#: ../../orm/loading_relationships.rst:208
msgid ""
"The one case where SQL is not emitted is for a simple many-to-one "
"relationship, when the related object can be identified by its primary "
"key alone and that object is already present in the current "
":class:`.Session`.  For this reason, while lazy loading can be expensive "
"for related collections, in the case that one is loading lots of objects "
"with simple many-to-ones against a relatively small set of possible "
"target objects, lazy loading may be able to refer to these objects "
"locally without emitting as many SELECT statements as there are parent "
"objects."
msgstr ""

#: ../../orm/loading_relationships.rst:216
msgid ""
"This default behavior of \"load upon attribute access\" is known as "
"\"lazy\" or \"select\" loading - the name \"select\" because a \"SELECT\""
" statement is typically emitted when the attribute is first accessed."
msgstr ""

#: ../../orm/loading_relationships.rst:220
msgid ""
"Lazy loading can be enabled for a given attribute that is normally "
"configured in some other way using the :func:`.lazyload` loader option::"
msgstr ""

#: ../../orm/loading_relationships.rst:232
msgid "Preventing unwanted lazy loads using raiseload"
msgstr ""

#: ../../orm/loading_relationships.rst:234
msgid ""
"The :func:`.lazyload` strategy produces an effect that is one of the most"
" common issues referred to in object relational mapping; the :term:`N "
"plus one problem`, which states that for any N objects loaded, accessing "
"their lazy-loaded attributes means there will be N+1 SELECT statements "
"emitted.  In SQLAlchemy, the usual mitigation for the N+1 problem is to "
"make use of its very capable eager load system.  However, eager loading "
"requires that the attributes which are to be loaded be specified with the"
" :class:`.Query` up front.  The problem of code that may access other "
"attributes that were not eagerly loaded, where lazy loading is not "
"desired, may be addressed using the :func:`.raiseload` strategy; this "
"loader strategy replaces the behavior of lazy loading with an informative"
" error being raised::"
msgstr ""

#: ../../orm/loading_relationships.rst:250
msgid ""
"Above, a ``User`` object loaded from the above query will not have the "
"``.addresses`` collection loaded; if some code later on attempts to "
"access this attribute, an ORM exception is raised."
msgstr ""

#: ../../orm/loading_relationships.rst:254
msgid ""
":func:`.raiseload` may be used with a so-called \"wildcard\" specifier to"
" indicate that all relationships should use this strategy.  For example, "
"to set up only one attribute as eager loading, and all the rest as "
"raise::"
msgstr ""

#: ../../orm/loading_relationships.rst:261
msgid ""
"The above wildcard will apply to **all** relationships not just on "
"``Order`` besides ``items``, but all those on the ``Item`` objects as "
"well.  To set up :func:`.raiseload` for only the ``Order`` objects, "
"specify a full path with :class:`.orm.Load`::"
msgstr ""

#: ../../orm/loading_relationships.rst:271
msgid "Conversely, to set up the raise for just the ``Item`` objects::"
msgstr ""

#: ../../orm/loading_relationships.rst:278
msgid ":ref:`wildcard_loader_strategies`"
msgstr ""

#: ../../orm/loading_relationships.rst:283
msgid "Joined Eager Loading"
msgstr ""

#: ../../orm/loading_relationships.rst:285
msgid ""
"Joined eager loading is the most fundamental style of eager loading in "
"the ORM.  It works by connecting a JOIN (by default a LEFT OUTER join) to"
" the SELECT statement emitted by a :class:`.Query` and populates the "
"target scalar/collection from the same result set as that of the parent."
msgstr ""

#: ../../orm/loading_relationships.rst:291
msgid "At the mapping level, this looks like::"
msgstr ""

#: ../../orm/loading_relationships.rst:298
msgid ""
"Joined eager loading is usually applied as an option to a query, rather "
"than as a default loading option on the mapping, in particular when used "
"for collections rather than many-to-one-references.   This is achieved "
"using the :func:`.joinedload` loader option:"
msgstr ""

#: ../../orm/loading_relationships.rst:322
msgid ""
"The JOIN emitted by default is a LEFT OUTER JOIN, to allow for a lead "
"object that does not refer to a related row.  For an attribute that is "
"guaranteed to have an element, such as a many-to-one reference to a "
"related object where the referencing foreign key is NOT NULL, the query "
"can be made more efficient by using an inner join; this is available at "
"the mapping level via the :paramref:`.relationship.innerjoin` flag::"
msgstr ""

#: ../../orm/loading_relationships.rst:335
msgid ""
"At the query option level, via the :paramref:`.joinedload.innerjoin` "
"flag::"
msgstr ""

#: ../../orm/loading_relationships.rst:340
msgid ""
"The JOIN will right-nest itself when applied in a chain that includes an "
"OUTER JOIN:"
msgstr ""

#: ../../orm/loading_relationships.rst:363
msgid ""
"On older versions of SQLite, the above nested right JOIN may be re-"
"rendered as a nested subquery.  Older versions of SQLAlchemy would "
"convert right-nested joins into subuqeries in all cases."
msgstr ""

#: ../../orm/loading_relationships.rst:368
msgid "Joined eager loading and result set batching"
msgstr ""

#: ../../orm/loading_relationships.rst:370
msgid ""
"A central concept of joined eager loading when applied to collections is "
"that the :class:`.Query` object must de-duplicate rows against the "
"leading entity being queried.  Such as above, if the ``User`` object we "
"loaded referred to three ``Address`` objects, the result of the SQL "
"statement would have had three rows; yet the :class:`.Query` returns only"
" one ``User`` object.  As additional rows are received for a ``User`` "
"object just loaded in a previous row, the additional columns that refer "
"to new ``Address`` objects are directed into additional results within "
"the ``User.addresses`` collection of that particular object."
msgstr ""

#: ../../orm/loading_relationships.rst:380
msgid ""
"This process is very transparent, however does imply that joined eager "
"loading is incompatible with \"batched\" query results, provided by the "
":meth:`.Query.yield_per` method, when used for collection loading.  "
"Joined eager loading used for scalar references is however compatible "
"with :meth:`.Query.yield_per`.  The :meth:`.Query.yield_per` method will "
"result in an exception thrown if a collection based joined eager loader "
"is in play."
msgstr ""

#: ../../orm/loading_relationships.rst:388
msgid ""
"To \"batch\" queries with arbitrarily large sets of result data while "
"maintaining compatibility with collection-based joined eager loading, "
"emit multiple SELECT statements, each referring to a subset of rows using"
" the WHERE clause, e.g. windowing.   Alternatively, consider using "
"\"select IN\" eager loading which is **potentially** compatible with "
":meth:`.Query.yield_per`, provided that the database driver in use "
"supports multiple, simultaneous cursors (SQLite, Postgresql drivers, not "
"MySQL drivers or SQL Server ODBC drivers)."
msgstr ""

#: ../../orm/loading_relationships.rst:400
msgid "The Zen of Joined Eager Loading"
msgstr ""

#: ../../orm/loading_relationships.rst:402
msgid ""
"Since joined eager loading seems to have many resemblances to the use of "
":meth:`.Query.join`, it often produces confusion as to when and how it "
"should be used.   It is critical to understand the distinction that while"
" :meth:`.Query.join` is used to alter the results of a query, "
":func:`.joinedload` goes through great lengths to **not** alter the "
"results of the query, and instead hide the effects of the rendered join "
"to only allow for related objects to be present."
msgstr ""

#: ../../orm/loading_relationships.rst:410
msgid ""
"The philosophy behind loader strategies is that any set of loading "
"schemes can be applied to a particular query, and *the results don't "
"change* - only the number of SQL statements required to fully load "
"related objects and collections changes. A particular query might start "
"out using all lazy loads.   After using it in context, it might be "
"revealed that particular attributes or collections are always accessed, "
"and that it would be more efficient to change the loader strategy for "
"these.   The strategy can be changed with no other modifications to the "
"query, the results will remain identical, but fewer SQL statements would "
"be emitted. In theory (and pretty much in practice), nothing you can do "
"to the :class:`.Query` would make it load a different set of primary or "
"related objects based on a change in loader strategy."
msgstr ""

#: ../../orm/loading_relationships.rst:422
msgid ""
"How :func:`joinedload` in particular achieves this result of not "
"impacting entity rows returned in any way is that it creates an anonymous"
" alias of the joins it adds to your query, so that they can't be "
"referenced by other parts of the query.   For example, the query below "
"uses :func:`.joinedload` to create a LEFT OUTER JOIN from ``users`` to "
"``addresses``, however the ``ORDER BY`` added against "
"``Address.email_address`` is not valid - the ``Address`` entity is not "
"named in the query:"
msgstr ""

#: ../../orm/loading_relationships.rst:451
msgid ""
"Above, ``ORDER BY addresses.email_address`` is not valid since "
"``addresses`` is not in the FROM list.   The correct way to load the "
"``User`` records and order by email address is to use "
":meth:`.Query.join`:"
msgstr ""

#: ../../orm/loading_relationships.rst:473
msgid ""
"The statement above is of course not the same as the previous one, in "
"that the columns from ``addresses`` are not included in the result at "
"all.   We can add :func:`.joinedload` back in, so that there are two "
"joins - one is that which we are ordering on, the other is used "
"anonymously to load the contents of the ``User.addresses`` collection:"
msgstr ""

#: ../../orm/loading_relationships.rst:501
msgid ""
"What we see above is that our usage of :meth:`.Query.join` is to supply "
"JOIN clauses we'd like to use in subsequent query criterion, whereas our "
"usage of :func:`.joinedload` only concerns itself with the loading of the"
" ``User.addresses`` collection, for each ``User`` in the result. In this "
"case, the two joins most probably appear redundant - which they are.  If "
"we wanted to use just one JOIN for collection loading as well as "
"ordering, we use the :func:`.contains_eager` option, described in "
":ref:`contains_eager` below.   But to see why :func:`joinedload` does "
"what it does, consider if we were **filtering** on a particular "
"``Address``:"
msgstr ""

#: ../../orm/loading_relationships.rst:533
msgid ""
"Above, we can see that the two JOINs have very different roles.  One will"
" match exactly one row, that of the join of ``User`` and ``Address`` "
"where ``Address.email_address=='someaddress@foo.com'``. The other LEFT "
"OUTER JOIN will match *all* ``Address`` rows related to ``User``, and is "
"only used to populate the ``User.addresses`` collection, for those "
"``User`` objects that are returned."
msgstr ""

#: ../../orm/loading_relationships.rst:540
msgid ""
"By changing the usage of :func:`.joinedload` to another style of loading,"
" we can change how the collection is loaded completely independently of "
"SQL used to retrieve the actual ``User`` rows we want.  Below we change "
":func:`.joinedload` into :func:`.subqueryload`:"
msgstr ""

#: ../../orm/loading_relationships.rst:568
msgid ""
"When using joined eager loading, if the query contains a modifier that "
"impacts the rows returned externally to the joins, such as when using "
"DISTINCT, LIMIT, OFFSET or equivalent, the completed statement is first "
"wrapped inside a subquery, and the joins used specifically for joined "
"eager loading are applied to the subquery.   SQLAlchemy's joined eager "
"loading goes the extra mile, and then ten miles further, to absolutely "
"ensure that it does not affect the end result of the query, only the way "
"collections and related objects are loaded, no matter what the format of "
"the query is."
msgstr ""

#: ../../orm/loading_relationships.rst:579
msgid ":ref:`contains_eager` - using :func:`.contains_eager`"
msgstr ""

#: ../../orm/loading_relationships.rst:584
msgid "Subquery Eager Loading"
msgstr ""

#: ../../orm/loading_relationships.rst:586
msgid ""
"Subqueryload eager loading is configured in the same manner as that of "
"joined eager loading;  for the :paramref:`.relationship.lazy` parameter, "
"we would specify ``\"subquery\"`` rather than ``\"joined\"``, and for the"
" option we use the :func:`.subqueryload` option rather than the "
":func:`.joinedload` option."
msgstr ""

#: ../../orm/loading_relationships.rst:592
msgid ""
"The operation of subquery eager loading is to emit a second SELECT "
"statement for each relationship to be loaded, across all result objects "
"at once. This SELECT statement refers to the original SELECT statement, "
"wrapped inside of a subquery, so that we retrieve the same list of "
"primary keys for the primary object being returned, then link that to the"
" sum of all the collection members to load them at once:"
msgstr ""

#: ../../orm/loading_relationships.rst:625
msgid ""
"The subqueryload strategy has many advantages over joined eager loading "
"in the area of loading collections.   First, it allows the original query"
" to proceed without changing it at all, not introducing in particular a "
"LEFT OUTER JOIN that may make it less efficient.  Secondly, it allows for"
" many collections to be eagerly loaded without producing a single query "
"that has many JOINs in it, which can be even less efficient; each "
"relationship is loaded in a fully separate query.  Finally, because the "
"additional query only needs to load the collection items and not the lead"
" object, it can use an inner JOIN in all cases for greater query "
"efficiency."
msgstr ""

#: ../../orm/loading_relationships.rst:635
msgid ""
"Disadvantages of subqueryload include that the complexity of the original"
" query is transferred to the relationship queries, which when combined "
"with the use of a subquery, can on some backends in some cases (notably "
"MySQL) produce significantly slow queries.   Additionally, the "
"subqueryload strategy can only load the full contents of all collections "
"at once, is therefore incompatible with \"batched\" loading supplied by "
":meth:`.Query.yield_per`, both for collection and scalar relationships."
msgstr ""

#: ../../orm/loading_relationships.rst:643
msgid ""
"The newer style of loading provided by :func:`.selectinload` solves these"
" limitations of :func:`.subqueryload`."
msgstr ""

#: ../../orm/loading_relationships.rst:648 of sqlalchemy.orm.immediateload:15
#: sqlalchemy.orm.selectinload:27
msgid ":ref:`selectin_eager_loading`"
msgstr ""

#: ../../orm/loading_relationships.rst:654
msgid "The Importance of Ordering"
msgstr ""

#: ../../orm/loading_relationships.rst:656
msgid ""
"A query which makes use of :func:`.subqueryload` in conjunction with a "
"limiting modifier such as :meth:`.Query.first`, :meth:`.Query.limit`, or "
":meth:`.Query.offset` should **always** include :meth:`.Query.order_by` "
"against unique column(s) such as the primary key, so that the additional "
"queries emitted by :func:`.subqueryload` include the same ordering as "
"used by the parent query.  Without it, there is a chance that the inner "
"query could return the wrong rows::"
msgstr ""

#: ../../orm/loading_relationships.rst:680
msgid ":ref:`faq_subqueryload_limit_sort` - detailed example"
msgstr ""

#: ../../orm/loading_relationships.rst:685
msgid "Select IN loading"
msgstr ""

#: ../../orm/loading_relationships.rst:687
msgid ""
"Select IN loading is similar in operation to subquery eager loading, "
"however the SELECT statement which is emitted has a much simpler "
"structure than that of subquery eager loading.  Additionally, select IN "
"loading applies itself to subsets of the load result at a time, so unlike"
" joined and subquery eager loading, is compatible with batching of "
"results using :meth:`.Query.yield_per`, provided the database driver "
"supports simultaneous cursors."
msgstr ""

#: ../../orm/loading_relationships.rst:695
msgid ""
"Overall, especially as of the 1.3 series of SQLAlchemy, selectin loading "
"is the most simple and efficient way to eagerly load collections of "
"objects in most cases.  The only scenario in which selectin eager loading"
" is not feasible is when the model is using composite primary keys, and "
"the backend database does not support tuples with IN, which includes "
"SQLite, Oracle and SQL Server."
msgstr ""

#: ../../orm/loading_relationships.rst:704
msgid ""
"\"Select IN\" eager loading is provided using the ``\"selectin\"`` "
"argument to :paramref:`.relationship.lazy` or by using the "
":func:`.selectinload` loader option.   This style of loading emits a "
"SELECT that refers to the primary key values of the parent object inside "
"of an IN clause, in order to load related associations:"
msgstr ""

#: ../../orm/loading_relationships.rst:732
msgid ""
"Above, the second SELECT refers to ``addresses.user_id IN (5, 7)``, where"
" the \"5\" and \"7\" are the primary key values for the previous two "
"``User`` objects loaded; after a batch of objects are completely loaded, "
"their primary key values are injected into the ``IN`` clause for the "
"second SELECT. Because the relatonship between ``User`` and ``Address`` "
"provides that the primary key values for ``User`` can be derived from "
"``Address.user_id``, the statement has no joins or subqueries at all."
msgstr ""

#: ../../orm/loading_relationships.rst:740
msgid "selectin loading can omit the JOIN for a simple one-to-many collection."
msgstr ""

#: ../../orm/loading_relationships.rst:743
msgid ""
"In the case where the primary key of the parent object isn't present in "
"the related row, \"selectin\" loading will also JOIN to the parent table "
"so that the parent primary key values are present:"
msgstr ""

#: ../../orm/loading_relationships.rst:768
msgid ""
"\"Select IN\" loading is the newest form of eager loading added to "
"SQLAlchemy as of the 1.2 series.   Things to know about this kind of "
"loading include:"
msgstr ""

#: ../../orm/loading_relationships.rst:771
msgid ""
"The SELECT statement emitted by the \"selectin\" loader strategy, unlike "
"that of \"subquery\", does not require a subquery nor does it inherit any"
" of the performance limitations of the original query; the lookup is a "
"simple primary key lookup and should have high performance."
msgstr ""

#: ../../orm/loading_relationships.rst:777
msgid ""
"The special ordering requirements of subqueryload described at "
":ref:`subqueryload_ordering` also don't apply to selectin loading; "
"selectin is always linking directly to a parent primary key and can't "
"really return the wrong result."
msgstr ""

#: ../../orm/loading_relationships.rst:782
msgid ""
"\"selectin\" loading, unlike joined or subquery eager loading, always "
"emits its SELECT in terms of the immediate parent objects just loaded, "
"and not the original type of object at the top of the chain.  So if eager"
" loading many levels deep, \"selectin\" loading still uses no more than "
"one JOIN, and usually no JOINs, in the statement.   In comparison, joined"
" and subquery eager loading always refer to multiple JOINs up to the "
"original parent."
msgstr ""

#: ../../orm/loading_relationships.rst:790
msgid ""
"\"selectin\" loading produces a SELECT statement of a predictable "
"structure, independent of that of the original query.  As such, taking "
"advantage of a new feature with :meth:`.ColumnOperators.in_` that allows "
"it to work with cached queries, the selectin loader makes full use of the"
" :mod:`sqlalchemy.ext.baked` extension to cache generated SQL and greatly"
" cut down on internal function call overhead."
msgstr ""

#: ../../orm/loading_relationships.rst:797
msgid ""
"The strategy will only query for at most 500 parent primary key values at"
" a time, as the primary keys are rendered into a large IN expression in "
"the SQL statement.   Some databases like Oracle have a hard limit on how "
"large an IN expression can be, and overall the size of the SQL string "
"shouldn't be arbitrarily large.   So for large result sets, \"selectin\" "
"loading will emit a SELECT per 500 parent rows returned.   These SELECT "
"statements emit with minimal Python overhead due to the \"baked\" queries"
" and also minimal SQL overhead as they query against primary key "
"directly."
msgstr ""

#: ../../orm/loading_relationships.rst:806
msgid ""
"\"selectin\" loading is the only eager loading that can work in "
"conjunction with the \"batching\" feature provided by "
":meth:`.Query.yield_per`, provided the database driver supports "
"simultaneous cursors.   As it only queries for related items against "
"specific result objects, \"selectin\" loading allows for eagerly loaded "
"collections against arbitrarily large result sets with a top limit on "
"memory use when used with :meth:`.Query.yield_per`."
msgstr ""

#: ../../orm/loading_relationships.rst:813
msgid ""
"Current database drivers that support simultaneous cursors include "
"SQLite, Postgresql.   The MySQL drivers mysqlclient and pymysql currently"
" **do not** support simultaneous cursors, nor do the ODBC drivers for SQL"
" Server."
msgstr ""

#: ../../orm/loading_relationships.rst:818
msgid ""
"As \"selectin\" loading relies upon IN, for a mapping with composite "
"primary keys, it must use the \"tuple\" form of IN, which looks like "
"``WHERE (table.column_a, table.column_b) IN ((?, ?), (?, ?), (?, ?))``. "
"This syntax is not supported on every database; currently it is known to "
"be only supported by modern Postgresql and MySQL versions.  Therefore "
"**selectin loading is not platform-agnostic for composite primary keys**."
" There is no special logic in SQLAlchemy to check ahead of time which "
"platforms support this syntax or not; if run against a non-supporting "
"platform (such as SQLite), the database will return an error immediately."
"   An advantage to SQLAlchemy just running the SQL out for it to fail is "
"that if a database like SQLite does start supporting this syntax, it will"
" work without any changes to SQLAlchemy."
msgstr ""

#: ../../orm/loading_relationships.rst:831
msgid ""
"In general, \"selectin\" loading is probably superior to \"subquery\" "
"eager loading in most ways, save for the syntax requirement with "
"composite primary keys and possibly that it may emit many SELECT "
"statements for larger result sets. As always, developers should spend "
"time looking at the statements and results generated by their "
"applications in development to check that things are working efficiently."
msgstr ""

#: ../../orm/loading_relationships.rst:841
msgid "What Kind of Loading to Use ?"
msgstr ""

#: ../../orm/loading_relationships.rst:843
msgid ""
"Which type of loading to use typically comes down to optimizing the "
"tradeoff between number of SQL executions, complexity of SQL emitted, and"
" amount of data fetched. Lets take two examples, a "
":func:`~sqlalchemy.orm.relationship` which references a collection, and a"
" :func:`~sqlalchemy.orm.relationship` that references a scalar many-to-"
"one reference."
msgstr ""

#: ../../orm/loading_relationships.rst:849
msgid "One to Many Collection"
msgstr ""

#: ../../orm/loading_relationships.rst:851
msgid ""
"When using the default lazy loading, if you load 100 objects, and then "
"access a collection on each of them, a total of 101 SQL statements will "
"be emitted, although each statement will typically be a simple SELECT "
"without any joins."
msgstr ""

#: ../../orm/loading_relationships.rst:855
msgid ""
"When using joined loading, the load of 100 objects and their collections "
"will emit only one SQL statement.  However, the total number of rows "
"fetched will be equal to the sum of the size of all the collections, plus"
" one extra row for each parent object that has an empty collection.  Each"
" row will also contain the full set of columns represented by the "
"parents, repeated for each collection item - SQLAlchemy does not re-fetch"
" these columns other than those of the primary key, however most DBAPIs "
"(with some exceptions) will transmit the full data of each parent over "
"the wire to the client connection in any case.  Therefore joined eager "
"loading only makes sense when the size of the collections are relatively "
"small.  The LEFT OUTER JOIN can also be performance intensive compared to"
" an INNER join."
msgstr ""

#: ../../orm/loading_relationships.rst:865
msgid ""
"When using subquery loading, the load of 100 objects will emit two SQL "
"statements.  The second statement will fetch a total number of rows equal"
" to the sum of the size of all collections.  An INNER JOIN is used, and a"
" minimum of parent columns are requested, only the primary keys. So a "
"subquery load makes sense when the collections are larger."
msgstr ""

#: ../../orm/loading_relationships.rst:871
msgid ""
"When multiple levels of depth are used with joined or subquery loading, "
"loading collections-within- collections will multiply the total number of"
" rows fetched in a cartesian fashion.  Both joined and subquery eager "
"loading always join from the original parent class; if loading a "
"collection four levels deep, there will be four JOINs out to the parent."
"  selectin loading on the other hand will always have exactly one JOIN to"
" the immediate parent table."
msgstr ""

#: ../../orm/loading_relationships.rst:878
msgid ""
"Using selectin loading, the load of 100 objects will also emit two SQL "
"statements, the second of which refers to the 100 primary keys of the "
"objects loaded.   selectin loading will however render at most 500 "
"primary key values into a single SELECT statement; so for a lead "
"collection larger than 500, there will be a SELECT statement emitted for "
"each batch of 500 objects selected."
msgstr ""

#: ../../orm/loading_relationships.rst:885
msgid ""
"Using multiple levels of depth with selectin loading does not incur the "
"\"cartesian\" issue that joined and subquery eager loading have; the "
"queries for selectin loading have the best performance characteristics "
"and the fewest number of rows.  The only caveat is that there might be "
"more than one SELECT emitted depending on the size of the lead result."
msgstr ""

#: ../../orm/loading_relationships.rst:891
msgid ""
"selectin loading, unlike joined (when using collections) and subquery "
"eager loading (all kinds of relationships), is potentially compatible "
"with result set batching provided by :meth:`.Query.yield_per` assuming an"
" appropriate database driver, so may be able to allow batching for large "
"result sets."
msgstr ""

#: ../../orm/loading_relationships.rst:896
msgid "Many to One Reference"
msgstr ""

#: ../../orm/loading_relationships.rst:898
msgid ""
"When using the default lazy loading, a load of 100 objects will like in "
"the case of the collection emit as many as 101 SQL statements.  However -"
" there is a significant exception to this, in that if the many-to-one "
"reference is a simple foreign key reference to the target's primary key, "
"each reference will be checked first in the current identity map using "
":meth:`.Query.get`.  So here, if the collection of objects references a "
"relatively small set of target objects, or the full set of possible "
"target objects have already been loaded into the session and are strongly"
" referenced, using the default of `lazy='select'` is by far the most "
"efficient way to go."
msgstr ""

#: ../../orm/loading_relationships.rst:906
msgid ""
"When using joined loading, the load of 100 objects will emit only one SQL"
" statement.   The join will be a LEFT OUTER JOIN, and the total number of"
" rows will be equal to 100 in all cases. If you know that each parent "
"definitely has a child (i.e. the foreign key reference is NOT NULL), the "
"joined load can be configured with :paramref:`~.relationship.innerjoin` "
"set to ``True``, which is usually specified within the "
":func:`~sqlalchemy.orm.relationship`.   For a load of objects where there"
" are many possible target references which may have not been loaded "
"already, joined loading with an INNER JOIN is extremely efficient."
msgstr ""

#: ../../orm/loading_relationships.rst:915
msgid ""
"Subquery loading will issue a second load for all the child objects, so "
"for a load of 100 objects there would be two SQL statements emitted.  "
"There's probably not much advantage here over joined loading, however, "
"except perhaps that subquery loading can use an INNER JOIN in all cases "
"whereas joined loading requires that the foreign key is NOT NULL."
msgstr ""

#: ../../orm/loading_relationships.rst:920
msgid ""
"Selectin loading will also issue a second load for all the child objects "
"(and as stated before, for larger results it will emit a SELECT per 500 "
"rows), so for a load of 100 objects there would be two SQL statements "
"emitted.  The query itself still has to JOIN to the parent table, so "
"again there's not too much advantage to selectin loading for many-to-one "
"vs. joined eager loading save for the use of INNER JOIN in all cases."
msgstr ""

#: ../../orm/loading_relationships.rst:928
msgid "Polymorphic Eager Loading"
msgstr ""

#: ../../orm/loading_relationships.rst:930
msgid ""
"Specification of polymorpic options on a per-eager-load basis is "
"supported. See the section :ref:`eagerloading_polymorphic_subtypes` for "
"examples of the :meth:`.PropComparator.of_type` method in conjunction "
"with the :func:`.orm.with_polymorphic` function."
msgstr ""

#: ../../orm/loading_relationships.rst:938
msgid "Wildcard Loading Strategies"
msgstr ""

#: ../../orm/loading_relationships.rst:940
msgid ""
"Each of :func:`.joinedload`, :func:`.subqueryload`, :func:`.lazyload`, "
":func:`.selectinload`, :func:`.noload`, and :func:`.raiseload` can be "
"used to set the default style of :func:`.relationship` loading for a "
"particular query, affecting all :func:`.relationship` -mapped attributes "
"not otherwise specified in the :class:`.Query`.   This feature is "
"available by passing the string ``'*'`` as the argument to any of these "
"options::"
msgstr ""

#: ../../orm/loading_relationships.rst:951
msgid ""
"Above, the ``lazyload('*')`` option will supersede the ``lazy`` setting "
"of all :func:`.relationship` constructs in use for that query, except for"
" those which use the ``'dynamic'`` style of loading. If some "
"relationships specify ``lazy='joined'`` or ``lazy='subquery'``, for "
"example, using ``lazyload('*')`` will unilaterally cause all those "
"relationships to use ``'select'`` loading, e.g. emit a SELECT statement "
"when each attribute is accessed."
msgstr ""

#: ../../orm/loading_relationships.rst:960
msgid ""
"The option does not supersede loader options stated in the query, such as"
" :func:`.eagerload`, :func:`.subqueryload`, etc.  The query below will "
"still use joined loading for the ``widget`` relationship::"
msgstr ""

#: ../../orm/loading_relationships.rst:970
msgid ""
"If multiple ``'*'`` options are passed, the last one overrides those "
"previously passed."
msgstr ""

#: ../../orm/loading_relationships.rst:974
msgid "Per-Entity Wildcard Loading Strategies"
msgstr ""

#: ../../orm/loading_relationships.rst:976
msgid ""
"A variant of the wildcard loader strategy is the ability to set the "
"strategy on a per-entity basis.  For example, if querying for ``User`` "
"and ``Address``, we can instruct all relationships on ``Address`` only to"
" use lazy loading by first applying the :class:`.Load` object, then "
"specifying the ``*`` as a chained option::"
msgstr ""

#: ../../orm/loading_relationships.rst:985
msgid "Above, all relationships on ``Address`` will be set to a lazy load."
msgstr ""

#: ../../orm/loading_relationships.rst:992
msgid "Routing Explicit Joins/Statements into Eagerly Loaded Collections"
msgstr ""

#: ../../orm/loading_relationships.rst:994
msgid ""
"The behavior of :func:`~sqlalchemy.orm.joinedload()` is such that joins "
"are created automatically, using anonymous aliases as targets, the "
"results of which are routed into collections and scalar references on "
"loaded objects. It is often the case that a query already includes the "
"necessary joins which represent a particular collection or scalar "
"reference, and the joins added by the joinedload feature are redundant - "
"yet you'd still like the collections/references to be populated."
msgstr ""

#: ../../orm/loading_relationships.rst:1002
msgid ""
"For this SQLAlchemy supplies the :func:`~sqlalchemy.orm.contains_eager()`"
" option. This option is used in the same manner as the "
":func:`~sqlalchemy.orm.joinedload()` option except it is assumed that the"
" :class:`~sqlalchemy.orm.query.Query` will specify the appropriate joins "
"explicitly. Below, we specify a join between ``User`` and ``Address`` and"
" additionally establish this as the basis for eager loading of "
"``User.addresses``::"
msgstr ""

#: ../../orm/loading_relationships.rst:1023
msgid ""
"If the \"eager\" portion of the statement is \"aliased\", the ``alias`` "
"keyword argument to :func:`~sqlalchemy.orm.contains_eager` may be used to"
" indicate it. This is sent as a reference to an :func:`.aliased` or "
":class:`.Alias` construct:"
msgstr ""

#: ../../orm/loading_relationships.rst:1051
msgid ""
"The path given as the argument to :func:`.contains_eager` needs to be a "
"full path from the starting entity. For example if we were loading "
"``Users->orders->Order->items->Item``, the string version would look "
"like::"
msgstr ""

#: ../../orm/loading_relationships.rst:1059
msgid "Or using the class-bound descriptor::"
msgstr ""

#: ../../orm/loading_relationships.rst:1066
msgid "Using contains_eager() to load a custom-filtered collection result"
msgstr ""

#: ../../orm/loading_relationships.rst:1068
msgid ""
"When we use :func:`.contains_eager`, *we* are constructing ourselves the "
"SQL that will be used to populate collections.  From this, it naturally "
"follows that we can opt to **modify** what values the collection is "
"intended to store, by writing our SQL to load a subset of elements for "
"collections or scalar attributes."
msgstr ""

#: ../../orm/loading_relationships.rst:1074
msgid ""
"As an example, we can load a ``User`` object and eagerly load only "
"particular addresses into its ``.addresses`` collection just by "
"filtering::"
msgstr ""

#: ../../orm/loading_relationships.rst:1081
msgid ""
"The above query will load only ``User`` objects which contain at least "
"``Address`` object that contains the substring ``'ed'`` in its ``email`` "
"field; the ``User.addresses`` collection will contain **only** these "
"``Address`` entries, and *not* any other ``Address`` entries that are in "
"fact associated with the collection."
msgstr ""

#: ../../orm/loading_relationships.rst:1089
msgid ""
"Keep in mind that when we load only a subset of objects into a "
"collection, that collection no longer represents what's actually in the "
"database.  If we attempted to add entries to this collection, we might "
"find ourselves conflicting with entries that are already in the database "
"but not locally loaded."
msgstr ""

#: ../../orm/loading_relationships.rst:1095
msgid ""
"In addition, the **collection will fully reload normally** once the "
"object or attribute is expired.  This expiration occurs whenever the "
":meth:`.Session.commit`, :meth:`.Session.rollback` methods are used "
"assuming default session settings, or the :meth:`.Session.expire_all` or "
":meth:`.Session.expire` methods are used."
msgstr ""

#: ../../orm/loading_relationships.rst:1101
msgid ""
"For these reasons, prefer returning separate fields in a tuple rather "
"than artificially altering a collection, when an object plus a custom set"
" of related objects is desired::"
msgstr ""

#: ../../orm/loading_relationships.rst:1110
msgid "Advanced Usage with Arbitrary Statements"
msgstr ""

#: ../../orm/loading_relationships.rst:1112
msgid ""
"The ``alias`` argument can be more creatively used, in that it can be "
"made to represent any set of arbitrary names to match up into a "
"statement. Below it is linked to a :func:`.select` which links a set of "
"column objects to a string SQL statement::"
msgstr ""

#: ../../orm/loading_relationships.rst:1135
msgid "Creating Custom Load Rules"
msgstr ""

#: ../../orm/loading_relationships.rst:1137
msgid "This is an advanced technique!   Great care and testing should be applied."
msgstr ""

#: ../../orm/loading_relationships.rst:1140
msgid ""
"The ORM has various edge cases where the value of an attribute is locally"
" available, however the ORM itself doesn't have awareness of this.   "
"There are also cases when a user-defined system of loading attributes is "
"desirable. To support the use case of user-defined loading systems, a key"
" function :func:`.attributes.set_committed_value` is provided.   This "
"function is basically equivalent to Python's own ``setattr()`` function, "
"except that when applied to a target object, SQLAlchemy's \"attribute "
"history\" system which is used to determine flush-time changes is "
"bypassed; the attribute is assigned in the same way as if the ORM loaded "
"it that way from the database."
msgstr ""

#: ../../orm/loading_relationships.rst:1150
msgid ""
"The use of :func:`.attributes.set_committed_value` can be combined with "
"another key event known as :meth:`.InstanceEvents.load` to produce "
"attribute-population behaviors when an object is loaded.   One such "
"example is the bi-directional \"one-to-one\" case, where loading the "
"\"many-to-one\" side of a one-to-one should also imply the value of the "
"\"one-to-many\" side.  The SQLAlchemy ORM does not consider backrefs when"
" loading related objects, and it views a \"one-to-one\" as just another "
"\"one-to-many\", that just happens to be one row."
msgstr ""

#: ../../orm/loading_relationships.rst:1159
msgid "Given the following mapping::"
msgstr ""

#: ../../orm/loading_relationships.rst:1183
msgid ""
"If we query for an ``A`` row, and then ask it for ``a.b.a``, we will get "
"an extra SELECT::"
msgstr ""

#: ../../orm/loading_relationships.rst:1191
msgid ""
"This SELECT is redundant because ``b.a`` is the same value as ``a1``.  We"
" can create an on-load rule to populate this for us::"
msgstr ""

#: ../../orm/loading_relationships.rst:1202
msgid ""
"Now when we query for ``A``, we will get ``A.b`` from the joined eager "
"load, and ``A.b.a`` from our event:"
msgstr ""

#: ../../orm/loading_relationships.rst:1220
msgid "Relationship Loader API"
msgstr ""

#: of sqlalchemy.orm.contains_alias:1
msgid ""
"Return a :class:`.MapperOption` that will indicate to the :class:`.Query`"
" that the main table has been aliased."
msgstr ""

#: of sqlalchemy.orm.contains_alias:4
msgid ""
"This is a seldom-used option to suit the very rare case that "
":func:`.contains_eager` is being used in conjunction with a user-defined "
"SELECT statement that aliases the parent table.  E.g.::"
msgstr ""

#: of sqlalchemy.orm.contains_alias sqlalchemy.orm.joinedload
#: sqlalchemy.orm.raiseload
msgid "Parameters"
msgstr ""

#: of sqlalchemy.orm.contains_alias:28
msgid ""
"is the string name of an alias, or a :class:`~.sql.expression.Alias` "
"object representing the alias."
msgstr ""

#: of sqlalchemy.orm.contains_eager:1
msgid ""
"Indicate that the given attribute should be eagerly loaded from columns "
"stated manually in the query."
msgstr ""

#: of sqlalchemy.orm.contains_eager:4 sqlalchemy.orm.immediateload:8
#: sqlalchemy.orm.joinedload:4 sqlalchemy.orm.lazyload:4
#: sqlalchemy.orm.noload:3 sqlalchemy.orm.raiseload:16
#: sqlalchemy.orm.selectinload:4 sqlalchemy.orm.subqueryload:4
msgid ""
"This function is part of the :class:`.Load` interface and supports both "
"method-chained and standalone operation."
msgstr ""

#: of sqlalchemy.orm.contains_eager:7
msgid ""
"The option is used in conjunction with an explicit join that loads the "
"desired rows, i.e.::"
msgstr ""

#: of sqlalchemy.orm.contains_eager:14
msgid ""
"The above query would join from the ``Order`` entity to its related "
"``User`` entity, and the returned ``Order`` objects would have the "
"``Order.user`` attribute pre-populated."
msgstr ""

#: of sqlalchemy.orm.contains_eager:18
msgid ""
":func:`.contains_eager` also accepts an `alias` argument, which is the "
"string name of an alias, an :func:`~sqlalchemy.sql.expression.alias` "
"construct, or an :func:`~sqlalchemy.orm.aliased` construct. Use this when"
" the eagerly-loaded rows are to come from an aliased table::"
msgstr ""

#: of sqlalchemy.orm.contains_eager:28
msgid ""
"When using :func:`.contains_eager` in conjunction with inherited "
"subclasses, the :meth:`.RelationshipProperty.of_type` modifier should "
"also be used in order to set up the pathing properly::"
msgstr ""

#: of sqlalchemy.orm.Load:32 sqlalchemy.orm.contains_eager:42
#: sqlalchemy.orm.immediateload:13 sqlalchemy.orm.joinedload:80
#: sqlalchemy.orm.lazyload:9 sqlalchemy.orm.noload:11
#: sqlalchemy.orm.raiseload:25 sqlalchemy.orm.selectinload:25
#: sqlalchemy.orm.subqueryload:24
msgid ":ref:`loading_toplevel`"
msgstr ""

#: of sqlalchemy.orm.contains_eager:44
msgid ":ref:`contains_eager`"
msgstr ""

#: of sqlalchemy.orm.defaultload:1
msgid "Indicate an attribute should load using its default loader style."
msgstr ""

#: of sqlalchemy.orm.defaultload:3
msgid ""
"This method is used to link to other loader options further into a chain "
"of attributes without altering the loader style of the links along the "
"chain.  For example, to set joined eager loading for an element of an "
"element::"
msgstr ""

#: of sqlalchemy.orm.defaultload:13
msgid ""
":func:`.defaultload` is also useful for setting column-level options on a"
" related class, namely that of :func:`.defer` and :func:`.undefer`::"
msgstr ""

#: of sqlalchemy.orm.defaultload:24
msgid ":ref:`relationship_loader_options`"
msgstr ""

#: of sqlalchemy.orm.defaultload:26
msgid ":ref:`deferred_loading_w_multiple`"
msgstr ""

#: of sqlalchemy.orm.eagerload:1
msgid "A synonym for :func:`joinedload()`."
msgstr ""

#: of sqlalchemy.orm.eagerload_all:1
msgid "A synonym for :func:`joinedload_all()`"
msgstr ""

#: of sqlalchemy.orm.immediateload:1
msgid ""
"Indicate that the given attribute should be loaded using an immediate "
"load with a per-attribute SELECT statement."
msgstr ""

#: of sqlalchemy.orm.immediateload:4
msgid ""
"The :func:`.immediateload` option is superseded in general by the "
":func:`.selectinload` option, which performs the same task more "
"efficiently by emitting a SELECT for all loaded objects."
msgstr ""

#: of sqlalchemy.orm.joinedload:1
msgid ""
"Indicate that the given attribute should be loaded using joined eager "
"loading."
msgstr ""

#: of sqlalchemy.orm.joinedload:7 sqlalchemy.orm.selectinload:7
#: sqlalchemy.orm.subqueryload:7
msgid "examples::"
msgstr ""

#: of sqlalchemy.orm.joinedload:21
msgid ""
"if ``True``, indicates that the joined eager load should use an inner "
"join instead of the default of left outer join::     "
"query(Order).options(joinedload(Order.user, innerjoin=True))  In order to"
" chain multiple eager joins together where some may be OUTER and others "
"INNER, right-nested joins are used to link them::     query(A).options("
"        joinedload(A.bs, innerjoin=False).            joinedload(B.cs, "
"innerjoin=True)    )  The above query, linking A.bs via \"outer\" join "
"and B.cs via \"inner\" join would render the joins as \"a LEFT OUTER JOIN"
" (b JOIN c)\".   When using older versions of SQLite (< 3.7.16), this "
"form of JOIN is translated to use full subqueries as this syntax is "
"otherwise not directly supported.  The ``innerjoin`` flag can also be "
"stated with the term ``\"unnested\"``. This indicates that an INNER JOIN "
"should be used, *unless* the join is linked to a LEFT OUTER JOIN to the "
"left, in which case it will render as LEFT OUTER JOIN.  For example, "
"supposing ``A.bs`` is an outerjoin::     query(A).options(        "
"joinedload(A.bs).            joinedload(B.cs, innerjoin=\"unnested\")    "
")  The above join will render as \"a LEFT OUTER JOIN b LEFT OUTER JOIN "
"c\", rather than as \"a LEFT OUTER JOIN (b JOIN c)\".  .. note:: The "
"\"unnested\" flag does **not** affect the JOIN rendered    from a many-"
"to-many association table, e.g. a table configured    as "
":paramref:`.relationship.secondary`, to the target table; for    "
"correctness of results, these joins are always INNER and are    therefore"
" right-nested if linked to an OUTER join.  .. versionchanged:: 1.0.0 "
"``innerjoin=True`` now implies    ``innerjoin=\"nested\"``, whereas in "
"0.9 it implied    ``innerjoin=\"unnested\"``.  In order to achieve the "
"pre-1.0 \"unnested\"    inner join behavior, use the value "
"``innerjoin=\"unnested\"``.    See :ref:`migration_3008`."
msgstr ""

#: of sqlalchemy.orm.joinedload:21
msgid ""
"if ``True``, indicates that the joined eager load should use an inner "
"join instead of the default of left outer join::"
msgstr ""

#: of sqlalchemy.orm.joinedload:26
msgid ""
"In order to chain multiple eager joins together where some may be OUTER "
"and others INNER, right-nested joins are used to link them::"
msgstr ""

#: of sqlalchemy.orm.joinedload:34
msgid ""
"The above query, linking A.bs via \"outer\" join and B.cs via \"inner\" "
"join would render the joins as \"a LEFT OUTER JOIN (b JOIN c)\".   When "
"using older versions of SQLite (< 3.7.16), this form of JOIN is "
"translated to use full subqueries as this syntax is otherwise not "
"directly supported."
msgstr ""

#: of sqlalchemy.orm.joinedload:39
msgid ""
"The ``innerjoin`` flag can also be stated with the term ``\"unnested\"``."
" This indicates that an INNER JOIN should be used, *unless* the join is "
"linked to a LEFT OUTER JOIN to the left, in which case it will render as "
"LEFT OUTER JOIN.  For example, supposing ``A.bs`` is an outerjoin::"
msgstr ""

#: of sqlalchemy.orm.joinedload:50
msgid ""
"The above join will render as \"a LEFT OUTER JOIN b LEFT OUTER JOIN c\", "
"rather than as \"a LEFT OUTER JOIN (b JOIN c)\"."
msgstr ""

#: of sqlalchemy.orm.joinedload:53
msgid ""
"The \"unnested\" flag does **not** affect the JOIN rendered from a many-"
"to-many association table, e.g. a table configured as "
":paramref:`.relationship.secondary`, to the target table; for correctness"
" of results, these joins are always INNER and are therefore right-nested "
"if linked to an OUTER join."
msgstr ""

#: of sqlalchemy.orm.joinedload:59
msgid ""
"``innerjoin=True`` now implies ``innerjoin=\"nested\"``, whereas in 0.9 "
"it implied ``innerjoin=\"unnested\"``.  In order to achieve the pre-1.0 "
"\"unnested\" inner join behavior, use the value "
"``innerjoin=\"unnested\"``. See :ref:`migration_3008`."
msgstr ""

#: of sqlalchemy.orm.joinedload:67
msgid ""
"The joins produced by :func:`.orm.joinedload` are **anonymously "
"aliased**.  The criteria by which the join proceeds cannot be modified, "
"nor can the :class:`.Query` refer to these joins in any way, including "
"ordering.  See :ref:`zen_of_eager_loading` for further detail."
msgstr ""

#: of sqlalchemy.orm.joinedload:73
msgid ""
"To produce a specific SQL JOIN which is explicitly available, use "
":meth:`.Query.join`.   To combine explicit JOINs with eager loading of "
"collections, use :func:`.orm.contains_eager`; see :ref:`contains_eager`."
msgstr ""

#: of sqlalchemy.orm.joinedload:82
msgid ":ref:`joined_eager_loading`"
msgstr ""

#: of sqlalchemy.orm.joinedload_all:1
msgid "Produce a standalone \"all\" option for :func:`.orm.joinedload`."
msgstr ""

#: of sqlalchemy.orm.joinedload_all:5 sqlalchemy.orm.selectinload_all:5
#: sqlalchemy.orm.subqueryload_all:5
msgid "The \"_all()\" style is replaced by method chaining, e.g.::"
msgstr ""

#: of sqlalchemy.orm.lazyload:1
msgid "Indicate that the given attribute should be loaded using \"lazy\" loading."
msgstr ""

#: of sqlalchemy.orm.lazyload:11
msgid ":ref:`lazy_loading`"
msgstr ""

#: of sqlalchemy.orm.Load:1
msgid ""
"Represents loader options which modify the state of a :class:`.Query` in "
"order to affect how various mapped attributes are loaded."
msgstr ""

#: of sqlalchemy.orm.Load:5
msgid ""
"The :class:`.Load` object is in most cases used implicitly behind the "
"scenes when one makes use of a query option like :func:`.joinedload`, "
":func:`.defer`, or similar.   However, the :class:`.Load` object can also"
" be used directly, and in some cases can be useful."
msgstr ""

#: of sqlalchemy.orm.Load:10
msgid ""
"To use :class:`.Load` directly, instantiate it with the target mapped "
"class as the argument.   This style of usage is useful when dealing with "
"a :class:`.Query` that has multiple entities::"
msgstr ""

#: of sqlalchemy.orm.Load:16
msgid ""
"The above ``myopt`` can now be used with :meth:`.Query.options`, where it"
" will only take effect for the ``MyClass`` entity::"
msgstr ""

#: of sqlalchemy.orm.Load:21
msgid ""
"One case where :class:`.Load` is useful as public API is when specifying "
"\"wildcard\" options that only take effect for a certain class::"
msgstr ""

#: of sqlalchemy.orm.Load:26
msgid ""
"Above, all relationships on ``Order`` will be lazy-loaded, but other "
"attributes on those descendant objects will load using their normal "
"loader strategy."
msgstr ""

#: of sqlalchemy.orm.noload:1
msgid "Indicate that the given relationship attribute should remain unloaded."
msgstr ""

#: of sqlalchemy.orm.noload:6
msgid ""
":func:`.orm.noload` applies to :func:`.relationship` attributes; for "
"column-based attributes, see :func:`.orm.defer`."
msgstr ""

#: of sqlalchemy.orm.raiseload:1
msgid "Indicate that the given relationship attribute should disallow lazy loads."
msgstr ""

#: of sqlalchemy.orm.raiseload:3
msgid ""
"A relationship attribute configured with :func:`.orm.raiseload` will "
"raise an :exc:`~sqlalchemy.exc.InvalidRequestError` upon access.   The "
"typical way this is useful is when an application is attempting to ensure"
" that all relationship attributes that are accessed in a particular "
"context would have been already loaded via eager loading.  Instead of "
"having to read through SQL logs to ensure lazy loads aren't occurring, "
"this strategy will cause them to raise immediately."
msgstr ""

#: of sqlalchemy.orm.raiseload:11
msgid ""
"if True, raise only if the lazy load would emit SQL, but not if it is "
"only checking the identity map, or determining that the related value "
"should just be None due to missing keys.  When False, the strategy will "
"raise for all varieties of lazyload."
msgstr ""

#: of sqlalchemy.orm.raiseload:19
msgid ":func:`.orm.raiseload` applies to :func:`.relationship` attributes only."
msgstr ""

#: of sqlalchemy.orm.raiseload:27
msgid ":ref:`prevent_lazy_with_raiseload`"
msgstr ""

#: of sqlalchemy.orm.selectinload:1
msgid ""
"Indicate that the given attribute should be loaded using SELECT IN eager "
"loading."
msgstr ""

#: of sqlalchemy.orm.selectinload_all:1
msgid "Produce a standalone \"all\" option for :func:`.orm.selectinload`."
msgstr ""

#: of sqlalchemy.orm.subqueryload:1
msgid ""
"Indicate that the given attribute should be loaded using subquery eager "
"loading."
msgstr ""

#: of sqlalchemy.orm.subqueryload:26
msgid ":ref:`subquery_eager_loading`"
msgstr ""

#: of sqlalchemy.orm.subqueryload_all:1
msgid "Produce a standalone \"all\" option for :func:`.orm.subqueryload`."
msgstr ""

