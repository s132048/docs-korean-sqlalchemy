# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: SQLAlchemy 1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-02-21 14:32+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../orm/self_referential.rst:4
msgid "Adjacency List Relationships"
msgstr ""

#: ../../orm/self_referential.rst:6
msgid ""
"The **adjacency list** pattern is a common relational pattern whereby a "
"table contains a foreign key reference to itself. This is the most common"
" way to represent hierarchical data in flat tables.  Other methods "
"include **nested sets**, sometimes called \"modified preorder\", as well "
"as **materialized path**.  Despite the appeal that modified preorder has "
"when evaluated for its fluency within SQL queries, the adjacency list "
"model is probably the most appropriate pattern for the large majority of "
"hierarchical storage needs, for reasons of concurrency, reduced "
"complexity, and that modified preorder has little advantage over an "
"application which can fully load subtrees into the application space."
msgstr ""

#: ../../orm/self_referential.rst:17
msgid ""
"In this example, we'll work with a single mapped class called ``Node``, "
"representing a tree structure::"
msgstr ""

#: ../../orm/self_referential.rst:27
msgid "With this structure, a graph such as the following::"
msgstr ""

#: ../../orm/self_referential.rst:34
msgid "Would be represented with data such as::"
msgstr ""

#: ../../orm/self_referential.rst:45
msgid ""
"The :func:`.relationship` configuration here works in the same way as a "
"\"normal\" one-to-many relationship, with the exception that the "
"\"direction\", i.e. whether the relationship is one-to-many or many-to-"
"one, is assumed by default to be one-to-many.   To establish the "
"relationship as many-to-one, an extra directive is added known as "
":paramref:`~.relationship.remote_side`, which is a :class:`.Column` or "
"collection of :class:`.Column` objects that indicate those which should "
"be considered to be \"remote\"::"
msgstr ""

#: ../../orm/self_referential.rst:61
msgid ""
"Where above, the ``id`` column is applied as the "
":paramref:`~.relationship.remote_side` of the ``parent`` "
":func:`.relationship`, thus establishing ``parent_id`` as the \"local\" "
"side, and the relationship then behaves as a many-to-one."
msgstr ""

#: ../../orm/self_referential.rst:66
msgid ""
"As always, both directions can be combined into a bidirectional "
"relationship using the :func:`.backref` function::"
msgstr ""

#: ../../orm/self_referential.rst:78
msgid ""
"There are several examples included with SQLAlchemy illustrating self-"
"referential strategies; these include :ref:`examples_adjacencylist` and "
":ref:`examples_xmlpersistence`."
msgstr ""

#: ../../orm/self_referential.rst:83
msgid "Composite Adjacency Lists"
msgstr ""

#: ../../orm/self_referential.rst:85
msgid ""
"A sub-category of the adjacency list relationship is the rare case where "
"a particular column is present on both the \"local\" and \"remote\" side "
"of the join condition.  An example is the ``Folder`` class below; using a"
" composite primary key, the ``account_id`` column refers to itself, to "
"indicate sub folders which are within the same account as that of the "
"parent; while ``folder_id`` refers to a specific folder within that "
"account::"
msgstr ""

#: ../../orm/self_referential.rst:111
msgid ""
"Above, we pass ``account_id`` into the "
":paramref:`~.relationship.remote_side` list. :func:`.relationship` "
"recognizes that the ``account_id`` column here is on both sides, and "
"aligns the \"remote\" column along with the ``folder_id`` column, which "
"it recognizes as uniquely present on the \"remote\" side."
msgstr ""

#: ../../orm/self_referential.rst:117
msgid ""
"Support for self-referential composite keys in :func:`.relationship` "
"where a column points to itself."
msgstr ""

#: ../../orm/self_referential.rst:122
msgid "Self-Referential Query Strategies"
msgstr ""

#: ../../orm/self_referential.rst:124
msgid "Querying of self-referential structures works like any other query::"
msgstr ""

#: ../../orm/self_referential.rst:129
msgid ""
"However extra care is needed when attempting to join along the foreign "
"key from one level of the tree to the next.  In SQL, a join from a table "
"to itself requires that at least one side of the expression be "
"\"aliased\" so that it can be unambiguously referred to."
msgstr ""

#: ../../orm/self_referential.rst:134
msgid ""
"Recall from :ref:`ormtutorial_aliases` in the ORM tutorial that the "
":func:`.orm.aliased` construct is normally used to provide an \"alias\" "
"of an ORM entity.  Joining from ``Node`` to itself using this technique "
"looks like:"
msgstr ""

#: ../../orm/self_referential.rst:157
msgid ""
":meth:`.Query.join` also includes a feature known as "
":paramref:`.Query.join.aliased` that can shorten the verbosity self- "
"referential joins, at the expense of query flexibility.  This feature "
"performs a similar \"aliasing\" step to that above, without the need for "
"an explicit entity.   Calls to :meth:`.Query.filter` and similar "
"subsequent to the aliased join will **adapt** the ``Node`` entity to be "
"that of the alias:"
msgstr ""

#: ../../orm/self_referential.rst:179
msgid ""
"To add criterion to multiple points along a longer join, add "
":paramref:`.Query.join.from_joinpoint` to the additional "
":meth:`~.Query.join` calls:"
msgstr ""

#: ../../orm/self_referential.rst:205
msgid ""
":meth:`.Query.reset_joinpoint` will also remove the \"aliasing\" from "
"filtering calls::"
msgstr ""

#: ../../orm/self_referential.rst:214
msgid ""
"For an example of using :paramref:`.Query.join.aliased` to arbitrarily "
"join along a chain of self-referential nodes, see "
":ref:`examples_xmlpersistence`."
msgstr ""

#: ../../orm/self_referential.rst:221
msgid "Configuring Self-Referential Eager Loading"
msgstr ""

#: ../../orm/self_referential.rst:223
msgid ""
"Eager loading of relationships occurs using joins or outerjoins from "
"parent to child table during a normal query operation, such that the "
"parent and its immediate child collection or reference can be populated "
"from a single SQL statement, or a second statement for all immediate "
"child collections. SQLAlchemy's joined and subquery eager loading use "
"aliased tables in all cases when joining to related items, so are "
"compatible with self-referential joining. However, to use eager loading "
"with a self-referential relationship, SQLAlchemy needs to be told how "
"many levels deep it should join and/or query; otherwise the eager load "
"will not take place at all. This depth setting is configured via "
":paramref:`~.relationships.join_depth`:"
msgstr ""

