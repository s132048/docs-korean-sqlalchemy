# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: SQLAlchemy 1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-02-21 14:32+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../orm/query.rst:7
msgid "Query API"
msgstr ""

#: ../../orm/query.rst:9
msgid ""
"This section presents the API reference for the ORM :class:`.Query` "
"object.  For a walkthrough of how to use this object, see "
":ref:`ormtutorial_toplevel`."
msgstr ""

#: ../../orm/query.rst:13
msgid "The Query Object"
msgstr ""

#: ../../orm/query.rst:15
msgid ""
":class:`~.Query` is produced in terms of a given :class:`~.Session`, "
"using the :meth:`~.Session.query` method::"
msgstr ""

#: ../../orm/query.rst:19
msgid "Following is the full interface for the :class:`.Query` object."
msgstr ""

#: of sqlalchemy.orm.query.Query:1
msgid "ORM-level SQL construction object."
msgstr ""

#: of sqlalchemy.orm.query.Query:3
msgid ""
":class:`.Query` is the source of all SELECT statements generated by the "
"ORM, both those formulated by end-user query operations as well as by "
"high level internal operations such as related collection loading.  It "
"features a generative interface whereby successive calls return a new "
":class:`.Query` object, a copy of the former with additional criteria and"
" options associated with it."
msgstr ""

#: of sqlalchemy.orm.query.Query:10
msgid ""
":class:`.Query` objects are normally initially generated using the "
":meth:`~.Session.query` method of :class:`.Session`, and in less common "
"cases by instantiating the :class:`.Query` directly and associating with "
"a :class:`.Session` using the :meth:`.Query.with_session` method."
msgstr ""

#: of sqlalchemy.orm.query.Query:16
msgid ""
"For a full walkthrough of :class:`.Query` usage, see the "
":ref:`ormtutorial_toplevel`."
msgstr ""

#: of sqlalchemy.orm.query.Query.add_column:1
msgid "Add a column expression to the list of result columns to be returned."
msgstr ""

#: of sqlalchemy.orm.query.Query.add_column:4
msgid ""
"Pending deprecation: :meth:`.add_column` will be superseded by "
":meth:`.add_columns`."
msgstr ""

#: of sqlalchemy.orm.query.Query.add_columns:1
msgid ""
"Add one or more column expressions to the list of result columns to be "
"returned."
msgstr ""

#: of sqlalchemy.orm.query.Query.add_entity:1
msgid "add a mapped entity to the list of result columns to be returned."
msgstr ""

#: of sqlalchemy.orm.query.Query.all:1
msgid "Return the results represented by this ``Query`` as a list."
msgstr ""

#: of sqlalchemy.orm.query.Query.all:3 sqlalchemy.orm.query.Query.scalar:16
msgid "This results in an execution of the underlying query."
msgstr ""

#: of sqlalchemy.orm.query.Query.as_scalar:1
msgid ""
"Return the full SELECT statement represented by this :class:`.Query`, "
"converted to a scalar subquery."
msgstr ""

#: of sqlalchemy.orm.query.Query.as_scalar:4
msgid "Analogous to :meth:`sqlalchemy.sql.expression.SelectBase.as_scalar`."
msgstr ""

#: of sqlalchemy.orm.query.Query.autoflush:1
msgid "Return a Query with a specific 'autoflush' setting."
msgstr ""

#: of sqlalchemy.orm.query.Query.autoflush:3
msgid ""
"Note that a Session with autoflush=False will not autoflush, even if this"
" flag is set to True at the Query level.  Therefore this flag is usually "
"used only to disable autoflush for a specific Query."
msgstr ""

#: of sqlalchemy.orm.query.Query.column_descriptions:1
msgid ""
"Return metadata about the columns which would be returned by this "
":class:`.Query`."
msgstr ""

#: of sqlalchemy.orm.query.Query.column_descriptions:4
msgid "Format is a list of dictionaries::"
msgstr ""

#: of sqlalchemy.orm.query.Query.correlate:1
msgid ""
"Return a :class:`.Query` construct which will correlate the given FROM "
"clauses to that of an enclosing :class:`.Query` or "
":func:`~.expression.select`."
msgstr ""

#: of sqlalchemy.orm.query.Query.correlate:5
msgid ""
"The method here accepts mapped classes, :func:`.aliased` constructs, and "
":func:`.mapper` constructs as arguments, which are resolved into "
"expression constructs, in addition to appropriate expression constructs."
msgstr ""

#: of sqlalchemy.orm.query.Query.correlate:10
msgid ""
"The correlation arguments are ultimately passed to "
":meth:`.Select.correlate` after coercion to expression constructs."
msgstr ""

#: of sqlalchemy.orm.query.Query.correlate:13
msgid ""
"The correlation arguments take effect in such cases as when "
":meth:`.Query.from_self` is used, or when a subquery as returned by "
":meth:`.Query.subquery` is embedded in another "
":func:`~.expression.select` construct."
msgstr ""

#: of sqlalchemy.orm.query.Query.count:1
msgid "Return a count of rows this Query would return."
msgstr ""

#: of sqlalchemy.orm.query.Query.count:3
msgid "This generates the SQL for this Query as follows::"
msgstr ""

#: of sqlalchemy.orm.query.Query.count:9
msgid "The above scheme is newly refined as of 0.7b3."
msgstr ""

#: of sqlalchemy.orm.query.Query.count:12
msgid ""
"For fine grained control over specific columns to count, to skip the "
"usage of a subquery or otherwise control of the FROM clause, or to use "
"other aggregate functions, use :attr:`~sqlalchemy.sql.expression.func` "
"expressions in conjunction with :meth:`~.Session.query`, i.e.::"
msgstr ""

#: of sqlalchemy.orm.query.Query.cte:1
msgid ""
"Return the full SELECT statement represented by this :class:`.Query` "
"represented as a common table expression (CTE)."
msgstr ""

#: of sqlalchemy.orm.query.Query.cte:4
msgid ""
"Parameters and usage are the same as those of the :meth:`.SelectBase.cte`"
" method; see that method for further details."
msgstr ""

#: of sqlalchemy.orm.query.Query.cte:8
msgid ""
"Here is the `PostgreSQL WITH RECURSIVE example "
"<http://www.postgresql.org/docs/8.4/static/queries-with.html>`_. Note "
"that, in this example, the ``included_parts`` cte and the ``incl_alias`` "
"alias of it are Core selectables, which means the columns are accessed "
"via the ``.c.`` attribute.  The ``parts_alias`` object is an "
":func:`.orm.aliased` instance of the ``Part`` entity, so column-mapped "
"attributes are available directly::"
msgstr ""

#: of sqlalchemy.orm.query.Query.cte:52
msgid ":meth:`.HasCTE.cte`"
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:1
msgid "Perform a bulk delete query."
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:3
msgid "Deletes rows matched by this query from the database."
msgstr ""

#: of sqlalchemy.orm.aliased:4 sqlalchemy.orm.query.Query.delete:5
#: sqlalchemy.orm.query.Query.get:4 sqlalchemy.orm.query.Query.update:5
#: sqlalchemy.orm.query.Query.with_for_update:11
#: sqlalchemy.orm.query.Query.with_transformation:4
#: sqlalchemy.util.KeyedTuple:3
msgid "E.g.::"
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:13
msgid ""
"The :meth:`.Query.delete` method is a \"bulk\" operation, which bypasses "
"ORM unit-of-work automation in favor of greater performance.  **Please "
"read all caveats and warnings below.**"
msgstr ""

#: of sqlalchemy.orm.aliased sqlalchemy.orm.query.Query.delete
#: sqlalchemy.orm.query.Query.distinct sqlalchemy.orm.query.Query.from_self
#: sqlalchemy.orm.query.Query.get sqlalchemy.orm.query.Query.join
#: sqlalchemy.orm.query.Query.prefix_with
#: sqlalchemy.orm.query.Query.select_entity_from
#: sqlalchemy.orm.query.Query.select_from sqlalchemy.orm.query.Query.subquery
#: sqlalchemy.orm.query.Query.suffix_with sqlalchemy.orm.query.Query.update
#: sqlalchemy.orm.query.Query.with_lockmode
#: sqlalchemy.orm.query.Query.with_parent sqlalchemy.orm.with_parent
msgid "Parameters"
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:17
msgid ""
"chooses the strategy for the removal of matched objects from the session."
" Valid values are:  ``False`` - don't synchronize the session. This "
"option is the most efficient and is reliable once the session is expired,"
" which typically occurs after a commit(), or explicitly using "
"expire_all(). Before the expiration, objects may still remain in the "
"session which were in fact deleted which can lead to confusing results if"
" they are accessed via get() or already loaded collections.  ``'fetch'`` "
"- performs a select query before the delete to find objects that are "
"matched by the delete query and need to be removed from the session. "
"Matched objects are removed from the session.  ``'evaluate'`` - Evaluate "
"the query's criteria in Python straight on the objects in the session. If"
" evaluation of the criteria isn't implemented, an error is raised.  The "
"expression evaluator currently doesn't account for differing string "
"collations between the database and Python."
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:17
msgid ""
"chooses the strategy for the removal of matched objects from the session."
" Valid values are:"
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:20
msgid ""
"``False`` - don't synchronize the session. This option is the most "
"efficient and is reliable once the session is expired, which typically "
"occurs after a commit(), or explicitly using expire_all(). Before the "
"expiration, objects may still remain in the session which were in fact "
"deleted which can lead to confusing results if they are accessed via "
"get() or already loaded collections."
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:28
msgid ""
"``'fetch'`` - performs a select query before the delete to find objects "
"that are matched by the delete query and need to be removed from the "
"session. Matched objects are removed from the session."
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:33
msgid ""
"``'evaluate'`` - Evaluate the query's criteria in Python straight on the "
"objects in the session. If evaluation of the criteria isn't implemented, "
"an error is raised."
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:37 sqlalchemy.orm.query.Query.update:51
msgid ""
"The expression evaluator currently doesn't account for differing string "
"collations between the database and Python."
msgstr ""

#: of sqlalchemy.orm.query.Query.delete sqlalchemy.orm.query.Query.get
#: sqlalchemy.orm.query.Query.update
msgid "Returns"
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:40 sqlalchemy.orm.query.Query.update:62
msgid ""
"the count of rows matched as returned by the database's \"row count\" "
"feature."
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:43
msgid "**Additional Caveats for bulk query deletes**"
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:45
msgid ""
"This method does **not work for joined inheritance mappings**, since the "
"**multiple table deletes are not supported by SQL** as well as that the "
"**join condition of an inheritance mapper is not automatically "
"rendered**.  Care must be taken in any multiple-table delete to first "
"accommodate via some other means how the related table will be deleted, "
"as well as to explicitly include the joining condition between those "
"tables, even in mappings where this is normally automatic. E.g. if a "
"class ``Engineer`` subclasses ``Employee``, a DELETE against the "
"``Employee`` table would look like::"
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:63
msgid ""
"However the above SQL will not delete from the Engineer table, unless an "
"ON DELETE CASCADE rule is established in the database to handle it."
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:67
msgid ""
"Short story, **do not use this method for joined inheritance mappings "
"unless you have taken the additional steps to make this feasible**."
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:71
msgid ""
"The polymorphic identity WHERE criteria is **not** included for single- "
"or joined- table updates - this must be added **manually** even for "
"single table inheritance."
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:76
msgid ""
"The method does **not** offer in-Python cascading of relationships - it "
"is assumed that ON DELETE CASCADE/SET NULL/etc. is configured for any "
"foreign key references which require it, otherwise the database may emit "
"an integrity violation if foreign key references are being enforced."
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:83
msgid ""
"After the DELETE, dependent objects in the :class:`.Session` which were "
"impacted by an ON DELETE may not contain the current state, or may have "
"been deleted. This issue is resolved once the :class:`.Session` is "
"expired, which normally occurs upon :meth:`.Session.commit` or can be "
"forced by using :meth:`.Session.expire_all`.  Accessing an expired object"
" whose row has been deleted will invoke a SELECT to locate the row; when "
"the row is not found, an :class:`~sqlalchemy.orm.exc.ObjectDeletedError` "
"is raised."
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:95 sqlalchemy.orm.query.Query.update:80
msgid ""
"The ``'fetch'`` strategy results in an additional SELECT statement "
"emitted and will significantly reduce performance."
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:99 sqlalchemy.orm.query.Query.update:84
msgid ""
"The ``'evaluate'`` strategy performs a scan of all matching objects "
"within the :class:`.Session`; if the contents of the :class:`.Session` "
"are expired, such as via a proceeding :meth:`.Session.commit` call, "
"**this will result in SELECT queries emitted for every matching object**."
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:105
msgid ""
"The :meth:`.MapperEvents.before_delete` and "
":meth:`.MapperEvents.after_delete` events **are not invoked** from this "
"method.  Instead, the :meth:`.SessionEvents.after_bulk_delete` method is "
"provided to act upon a mass DELETE of entity rows."
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:113
msgid ":meth:`.Query.update`"
msgstr ""

#: of sqlalchemy.orm.query.Query.delete:115
#: sqlalchemy.orm.query.Query.update:123
msgid ":ref:`inserts_and_updates` - Core SQL tutorial"
msgstr ""

#: of sqlalchemy.orm.query.Query.distinct:1
msgid ""
"Apply a ``DISTINCT`` to the query and return the newly resulting "
"``Query``."
msgstr ""

#: of sqlalchemy.orm.query.Query.distinct:7
msgid ""
"The :meth:`.distinct` call includes logic that will automatically add "
"columns from the ORDER BY of the query to the columns clause of the "
"SELECT statement, to satisfy the common need of the database backend that"
" ORDER BY columns be part of the SELECT list when DISTINCT is used.   "
"These columns *are not* added to the list of columns actually fetched by "
"the :class:`.Query`, however, so would not affect results. The columns "
"are passed through when using the :attr:`.Query.statement` accessor, "
"however."
msgstr ""

#: of sqlalchemy.orm.query.Query.distinct:17
msgid ""
"optional column expressions.  When present, the PostgreSQL dialect will "
"render a ``DISTINCT ON (<expressions>)`` construct."
msgstr ""

#: of sqlalchemy.orm.query.Query.enable_assertions:1
msgid "Control whether assertions are generated."
msgstr ""

#: of sqlalchemy.orm.query.Query.enable_assertions:3
msgid ""
"When set to False, the returned Query will not assert its state before "
"certain operations, including that LIMIT/OFFSET has not been applied when"
" filter() is called, no criterion exists when get() is called, and no "
"\"from_statement()\" exists when filter()/order_by()/group_by() etc. is "
"called.  This more permissive mode is used by custom Query subclasses to "
"specify criterion or other modifiers outside of the usual usage patterns."
msgstr ""

#: of sqlalchemy.orm.query.Query.enable_assertions:13
msgid ""
"Care should be taken to ensure that the usage pattern is even possible.  "
"A statement applied by from_statement() will override any criterion set "
"by filter() or order_by(), for example."
msgstr ""

#: of sqlalchemy.orm.query.Query.enable_eagerloads:1
msgid "Control whether or not eager joins and subqueries are rendered."
msgstr ""

#: of sqlalchemy.orm.query.Query.enable_eagerloads:4
msgid ""
"When set to False, the returned Query will not render eager joins "
"regardless of :func:`~sqlalchemy.orm.joinedload`, "
":func:`~sqlalchemy.orm.subqueryload` options or mapper-level "
"``lazy='joined'``/``lazy='subquery'`` configurations."
msgstr ""

#: of sqlalchemy.orm.query.Query.enable_eagerloads:10
msgid ""
"This is used primarily when nesting the Query's statement into a subquery"
" or other selectable, or when using :meth:`.Query.yield_per`."
msgstr ""

#: of sqlalchemy.orm.query.Query.except_:1
msgid "Produce an EXCEPT of this Query against one or more queries."
msgstr ""

#: of sqlalchemy.orm.query.Query.except_:3
#: sqlalchemy.orm.query.Query.except_all:3
#: sqlalchemy.orm.query.Query.intersect:3
#: sqlalchemy.orm.query.Query.intersect_all:3
#: sqlalchemy.orm.query.Query.union_all:3
msgid ""
"Works the same way as :meth:`~sqlalchemy.orm.query.Query.union`. See that"
" method for usage examples."
msgstr ""

#: of sqlalchemy.orm.query.Query.except_all:1
msgid "Produce an EXCEPT ALL of this Query against one or more queries."
msgstr ""

#: of sqlalchemy.orm.query.Query.execution_options:1
msgid "Set non-SQL options which take effect during execution."
msgstr ""

#: of sqlalchemy.orm.query.Query.execution_options:3
msgid ""
"The options are the same as those accepted by "
":meth:`.Connection.execution_options`."
msgstr ""

#: of sqlalchemy.orm.query.Query.execution_options:6
msgid ""
"Note that the ``stream_results`` execution option is enabled "
"automatically if the :meth:`~sqlalchemy.orm.query.Query.yield_per()` "
"method is used."
msgstr ""

#: of sqlalchemy.orm.query.Query.exists:1
msgid ""
"A convenience method that turns a query into an EXISTS subquery of the "
"form EXISTS (SELECT 1 FROM ... WHERE ...)."
msgstr ""

#: of sqlalchemy.orm.query.Bundle.columns:3 sqlalchemy.orm.query.Query.exists:4
#: sqlalchemy.orm.query.Query.filter:4 sqlalchemy.orm.query.Query.filter_by:4
#: sqlalchemy.orm.query.Query.instances:4
#: sqlalchemy.orm.query.Query.prefix_with:7 sqlalchemy.orm.query.Query.union:3
#: sqlalchemy.orm.query.Query.with_entities:4
msgid "e.g.::"
msgstr ""

#: of sqlalchemy.orm.query.Query.exists:9 sqlalchemy.orm.query.Query.join:136
msgid "Producing SQL similar to::"
msgstr ""

#: of sqlalchemy.orm.query.Query.exists:15
msgid "The EXISTS construct is usually used in the WHERE clause::"
msgstr ""

#: of sqlalchemy.orm.query.Query.exists:19
msgid ""
"Note that some databases such as SQL Server don't allow an EXISTS "
"expression to be present in the columns clause of a SELECT.    To select "
"a simple boolean value based on the exists as a WHERE, use "
":func:`.literal`::"
msgstr ""

#: of sqlalchemy.orm.query.Query.filter:1
msgid ""
"apply the given filtering criterion to a copy of this :class:`.Query`, "
"using SQL expressions."
msgstr ""

#: of sqlalchemy.orm.query.Query.filter:8
#: sqlalchemy.orm.query.Query.filter_by:8
msgid ""
"Multiple criteria may be specified as comma separated; the effect is that"
" they will be joined together using the :func:`.and_` function::"
msgstr ""

#: of sqlalchemy.orm.query.Query.filter:15
msgid ""
"The criterion is any SQL expression object applicable to the WHERE clause"
" of a select.   String expressions are coerced into SQL expression "
"constructs via the :func:`.text` construct."
msgstr ""

#: of sqlalchemy.orm.query.Query.filter:21
msgid ":meth:`.Query.filter_by` - filter on keyword expressions."
msgstr ""

#: of sqlalchemy.orm.query.Query.filter_by:1
msgid ""
"apply the given filtering criterion to a copy of this :class:`.Query`, "
"using keyword expressions."
msgstr ""

#: of sqlalchemy.orm.query.Query.filter_by:15
msgid ""
"The keyword expressions are extracted from the primary entity of the "
"query, or the last entity that was the target of a call to "
":meth:`.Query.join`."
msgstr ""

#: of sqlalchemy.orm.query.Query.filter_by:21
msgid ":meth:`.Query.filter` - filter on SQL expressions."
msgstr ""

#: of sqlalchemy.orm.query.Query.first:1
msgid ""
"Return the first result of this ``Query`` or None if the result doesn't "
"contain any row."
msgstr ""

#: of sqlalchemy.orm.query.Query.first:4
msgid ""
"first() applies a limit of one within the generated SQL, so that only one"
" primary entity row is generated on the server side (note this may "
"consist of multiple result rows if join-loaded collections are present)."
msgstr ""

#: of sqlalchemy.orm.query.Query.first:9
msgid ""
"Calling :meth:`.Query.first` results in an execution of the underlying "
"query."
msgstr ""

#: of sqlalchemy.orm.query.Query.first:13
#: sqlalchemy.orm.query.Query.one_or_none:20
msgid ":meth:`.Query.one`"
msgstr ""

#: of sqlalchemy.orm.query.Query.first:15 sqlalchemy.orm.query.Query.one:15
msgid ":meth:`.Query.one_or_none`"
msgstr ""

#: of sqlalchemy.orm.query.Query.from_self:1
msgid "return a Query that selects from this Query's SELECT statement."
msgstr ""

#: of sqlalchemy.orm.query.Query.from_self:4
msgid ""
":meth:`.Query.from_self` essentially turns the SELECT statement into a "
"SELECT of itself.  Given a query such as::"
msgstr ""

#: of sqlalchemy.orm.query.Query.from_self:9
msgid "Given the :meth:`.Query.from_self` version::"
msgstr ""

#: of sqlalchemy.orm.query.Query.from_self:13
msgid "This query renders as:"
msgstr ""

#: of sqlalchemy.orm.query.Query.from_self:23
msgid ""
"There are lots of cases where :meth:`.Query.from_self` may be useful. A "
"simple one is where above, we may want to apply a row LIMIT to the set of"
" user objects we query against, and then apply additional joins against "
"that row-limited set::"
msgstr ""

#: of sqlalchemy.orm.query.Query.from_self:32
msgid ""
"The above query joins to the ``Address`` entity but only against the "
"first five results of the ``User`` query:"
msgstr ""

#: of sqlalchemy.orm.query.Query.from_self:46
msgid "**Automatic Aliasing**"
msgstr ""

#: of sqlalchemy.orm.query.Query.from_self:48
msgid ""
"Another key behavior of :meth:`.Query.from_self` is that it applies "
"**automatic aliasing** to the entities inside the subquery, when they are"
" referenced on the outside.  Above, if we continue to refer to the "
"``User`` entity without any additional aliasing applied to it, those "
"references wil be in terms of the subquery::"
msgstr ""

#: of sqlalchemy.orm.query.Query.from_self:59
msgid ""
"The ORDER BY against ``User.name`` is aliased to be in terms of the inner"
" subquery:"
msgstr ""

#: of sqlalchemy.orm.query.Query.from_self:73
msgid ""
"The automatic aliasing feature only works in a **limited** way, for "
"simple filters and orderings.   More ambitious constructions such as "
"referring to the entity in joins should prefer to use explicit subquery "
"objects, typically making use of the :meth:`.Query.subquery` method to "
"produce an explicit subquery object. Always test the structure of queries"
" by viewing the SQL to ensure a particular structure does what's "
"expected!"
msgstr ""

#: of sqlalchemy.orm.query.Query.from_self:81
msgid "**Changing the Entities**"
msgstr ""

#: of sqlalchemy.orm.query.Query.from_self:83
msgid ""
":meth:`.Query.from_self` also includes the ability to modify what columns"
" are being queried.   In our example, we want ``User.id`` to be queried "
"by the inner query, so that we can join to the ``Address`` entity on the "
"outside, but we only wanted the outer query to return the "
"``Address.email`` column::"
msgstr ""

#: of sqlalchemy.orm.query.Query.from_self:93
msgid "yielding:"
msgstr ""

#: of sqlalchemy.orm.query.Query.from_self:105
msgid "**Looking out for Inner / Outer Columns**"
msgstr ""

#: of sqlalchemy.orm.query.Query.from_self:107
msgid ""
"Keep in mind that when referring to columns that originate from inside "
"the subquery, we need to ensure they are present in the columns clause of"
" the subquery itself; this is an ordinary aspect of SQL.  For example, if"
" we wanted to load from a joined entity inside the subquery using "
":func:`.contains_eager`, we need to add those columns.   Below "
"illustrates a join of ``Address`` to ``User``, then a subquery, and then "
"we'd like :func:`.contains_eager` to access the ``User`` columns::"
msgstr ""

#: of sqlalchemy.orm.query.Query.from_self:122
msgid ""
"We use :meth:`.Query.add_entity` above **before** we call "
":meth:`.Query.from_self` so that the ``User`` columns are present in the "
"inner subquery, so that they are available to the :func:`.contains_eager`"
" modifier we are using on the outside, producing:"
msgstr ""

#: of sqlalchemy.orm.query.Query.from_self:144
msgid ""
"If we didn't call ``add_entity(User)``, but still asked "
":func:`.contains_eager` to load the ``User`` entity, it would be forced "
"to add the table on the outside without the correct join criteria - note "
"the ``anon1, \"user\"`` phrase at the end:"
msgstr ""

#: of sqlalchemy.orm.query.Query.from_self:165
msgid "optional list of entities which will replace those being selected."
msgstr ""

#: of sqlalchemy.orm.query.Query.from_statement:1
msgid "Execute the given SELECT statement and return results."
msgstr ""

#: of sqlalchemy.orm.query.Query.from_statement:3
msgid ""
"This method bypasses all internal statement compilation, and the "
"statement is executed without modification."
msgstr ""

#: of sqlalchemy.orm.query.Query.from_statement:6
msgid ""
"The statement is typically either a :func:`~.expression.text` or "
":func:`~.expression.select` construct, and should return the set of "
"columns appropriate to the entity class represented by this "
":class:`.Query`."
msgstr ""

#: of sqlalchemy.orm.query.Query.from_statement:13
msgid ":ref:`orm_tutorial_literal_sql` - usage examples in the ORM tutorial"
msgstr ""

#: of sqlalchemy.orm.query.Query.get:1
msgid ""
"Return an instance based on the given primary key identifier, or ``None``"
" if not found."
msgstr ""

#: of sqlalchemy.orm.query.Query.get:10
msgid ""
":meth:`~.Query.get` is special in that it provides direct access to the "
"identity map of the owning :class:`.Session`. If the given primary key "
"identifier is present in the local identity map, the object is returned "
"directly from this collection and no SQL is emitted, unless the object "
"has been marked fully expired. If not present, a SELECT is performed in "
"order to locate the object."
msgstr ""

#: of sqlalchemy.orm.query.Query.get:19
msgid ""
":meth:`~.Query.get` also will perform a check if the object is present in"
" the identity map and marked as expired - a SELECT is emitted to refresh "
"the object as well as to ensure that the row is still present. If not, "
":class:`~sqlalchemy.orm.exc.ObjectDeletedError` is raised."
msgstr ""

#: of sqlalchemy.orm.query.Query.get:26
msgid ""
":meth:`~.Query.get` is only used to return a single mapped instance, not "
"multiple instances or individual column constructs, and strictly on a "
"single primary key value.  The originating :class:`.Query` must be "
"constructed in this way, i.e. against a single mapped entity, with no "
"additional filtering criterion.  Loading options via "
":meth:`~.Query.options` may be applied however, and will be used if the "
"object is not yet locally present."
msgstr ""

#: of sqlalchemy.orm.query.Query.get:37
msgid ""
"A lazy-loading, many-to-one attribute configured by "
":func:`.relationship`, using a simple foreign-key-to-primary-key "
"criterion, will also use an operation equivalent to :meth:`~.Query.get` "
"in order to retrieve the target value from the local identity map before "
"querying the database.  See :doc:`/orm/loading_relationships` for further"
" details on relationship loading."
msgstr ""

#: of sqlalchemy.orm.query.Query.get:45
msgid ""
"A scalar or tuple value representing the primary key.   For a composite "
"primary key, the order of identifiers corresponds in most cases to that "
"of the mapped :class:`.Table` object's primary key columns.  For a "
":func:`.mapper` that was given the ``primary key`` argument during "
"construction, the order of identifiers corresponds to the elements "
"present in this collection."
msgstr ""

#: of sqlalchemy.orm.query.Query.get:54
msgid "The object instance, or ``None``."
msgstr ""

#: of sqlalchemy.orm.query.Query.group_by:1
msgid ""
"apply one or more GROUP BY criterion to the query and return the newly "
"resulting :class:`.Query`"
msgstr ""

#: of sqlalchemy.orm.query.Query.group_by:4
msgid ""
"All existing GROUP BY settings can be suppressed by passing ``None`` - "
"this will suppress any GROUP BY configured on mappers as well."
msgstr ""

#: of sqlalchemy.orm.query.Query.group_by:8
msgid "GROUP BY can be cancelled by passing None, in the same way as ORDER BY."
msgstr ""

#: of sqlalchemy.orm.query.Query.having:1
msgid ""
"apply a HAVING criterion to the query and return the newly resulting "
":class:`.Query`."
msgstr ""

#: of sqlalchemy.orm.query.Query.having:4
msgid ""
":meth:`~.Query.having` is used in conjunction with "
":meth:`~.Query.group_by`."
msgstr ""

#: of sqlalchemy.orm.query.Query.having:7
msgid ""
"HAVING criterion makes it possible to use filters on aggregate functions "
"like COUNT, SUM, AVG, MAX, and MIN, eg.::"
msgstr ""

#: of sqlalchemy.orm.query.Query.instances:1
msgid ""
"Given a ResultProxy cursor as returned by connection.execute(), return an"
" ORM result as an iterator."
msgstr ""

#: of sqlalchemy.orm.query.Query.intersect:1
msgid "Produce an INTERSECT of this Query against one or more queries."
msgstr ""

#: of sqlalchemy.orm.query.Query.intersect_all:1
msgid "Produce an INTERSECT ALL of this Query against one or more queries."
msgstr ""

#: of sqlalchemy.orm.query.Query.join:1
msgid ""
"Create a SQL JOIN against this :class:`.Query` object's criterion and "
"apply generatively, returning the newly resulting :class:`.Query`."
msgstr ""

#: of sqlalchemy.orm.query.Query.join:4
msgid "**Simple Relationship Joins**"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:6
msgid ""
"Consider a mapping between two classes ``User`` and ``Address``, with a "
"relationship ``User.addresses`` representing a collection of ``Address`` "
"objects associated with each ``User``.   The most common usage of "
":meth:`~.Query.join` is to create a JOIN along this relationship, using "
"the ``User.addresses`` attribute as an indicator for how this should "
"occur::"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:15
msgid ""
"Where above, the call to :meth:`~.Query.join` along ``User.addresses`` "
"will result in SQL equivalent to::"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:20
msgid ""
"In the above example we refer to ``User.addresses`` as passed to "
":meth:`~.Query.join` as the *on clause*, that is, it indicates how the "
"\"ON\" portion of the JOIN should be constructed.  For a single-entity "
"query such as the one above (i.e. we start by selecting only from "
"``User`` and nothing else), the relationship can also be specified by its"
" string name::"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:29
msgid ""
":meth:`~.Query.join` can also accommodate multiple \"on clause\" "
"arguments to produce a chain of joins, such as below where a join across "
"four related entities is constructed::"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:35
msgid ""
"The above would be shorthand for three separate calls to "
":meth:`~.Query.join`, each using an explicit attribute to indicate the "
"source entity::"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:44
msgid "**Joins to a Target Entity or Selectable**"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:46
msgid ""
"A second form of :meth:`~.Query.join` allows any mapped entity or core "
"selectable construct as a target.   In this usage, :meth:`~.Query.join` "
"will attempt to create a JOIN along the natural foreign key relationship "
"between two entities::"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:54
msgid ""
"The above calling form of :meth:`~.Query.join` will raise an error if "
"either there are no foreign keys between the two entities, or if there "
"are multiple foreign key linkages between them.   In the above calling "
"form, :meth:`~.Query.join` is called upon to create the \"on clause\" "
"automatically for us.  The target can be any mapped entity or selectable,"
" such as a :class:`.Table`::"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:63
msgid "**Joins to a Target with an ON Clause**"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:65
msgid ""
"The third calling form allows both the target entity as well as the ON "
"clause to be passed explicitly.   Suppose for example we wanted to join "
"to ``Address`` twice, using an alias the second time.  We use "
":func:`~sqlalchemy.orm.aliased` to create a distinct alias of "
"``Address``, and join to it using the ``target, onclause`` form, so that "
"the alias can be specified explicitly as the target along with the "
"relationship to instruct how the ON clause should proceed::"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:82
msgid "Where above, the generated SQL would be similar to::"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:90
msgid ""
"The two-argument calling form of :meth:`~.Query.join` also allows us to "
"construct arbitrary joins with SQL-oriented \"on clause\" expressions, "
"not relying upon configured relationships at all.  Any SQL expression can"
" be passed as the ON clause when using the two-argument form, which "
"should refer to the target entity in some way as well as an applicable "
"source entity::"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:99
msgid ""
"In SQLAlchemy 0.6 and earlier, the two argument form of "
":meth:`~.Query.join` requires the usage of a tuple: "
"``query(User).join((Address, User.id==Address.user_id))``\\ . This "
"calling form is accepted in 0.7 and further, though is not necessary "
"unless multiple join conditions are passed to a single "
":meth:`~.Query.join` call, which itself is also not generally necessary "
"as it is now equivalent to multiple calls (this wasn't always the case)."
msgstr ""

#: of sqlalchemy.orm.query.Query.join:109
msgid "**Advanced Join Targeting and Adaption**"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:111
msgid ""
"There is a lot of flexibility in what the \"target\" can be when using "
":meth:`~.Query.join`.   As noted previously, it also accepts "
":class:`.Table` constructs and other selectables such as :func:`.alias` "
"and :func:`.select` constructs, with either the one or two-argument "
"forms::"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:124
msgid ""
":meth:`~.Query.join` also features the ability to *adapt* a "
":meth:`~sqlalchemy.orm.relationship` -driven ON clause to the target "
"selectable. Below we construct a JOIN from ``User`` to a subquery against"
" ``Address``, allowing the relationship denoted by ``User.addresses`` to "
"*adapt* itself to the altered target::"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:147
msgid ""
"The above form allows one to fall back onto an explicit ON clause at any "
"time::"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:153
msgid "**Controlling what to Join From**"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:155
msgid ""
"While :meth:`~.Query.join` exclusively deals with the \"right\" side of "
"the JOIN, we can also control the \"left\" side, in those cases where "
"it's needed, using :meth:`~.Query.select_from`. Below we construct a "
"query against ``Address`` but can still make usage of ``User.addresses`` "
"as our ON clause by instructing the :class:`.Query` to select first from "
"the ``User`` entity::"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:167
msgid "Which will produce SQL similar to::"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:173
msgid "**Constructing Aliases Anonymously**"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:175
msgid ""
":meth:`~.Query.join` can construct anonymous aliases using the "
"``aliased=True`` flag.  This feature is useful when a query is being "
"joined algorithmically, such as when querying self-referentially to an "
"arbitrary depth::"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:183
msgid ""
"When ``aliased=True`` is used, the actual \"alias\" construct is not "
"explicitly available.  To work with it, methods such as "
":meth:`.Query.filter` will adapt the incoming entity to the last join "
"point::"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:192
msgid ""
"When using automatic aliasing, the ``from_joinpoint=True`` argument can "
"allow a multi-node join to be broken into multiple calls to "
":meth:`~.Query.join`, so that each path along the way can be further "
"filtered::"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:203
msgid ""
"The filtering aliases above can then be reset back to the original "
"``Node`` entity using :meth:`~.Query.reset_joinpoint`::"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:212
msgid ""
"For an example of ``aliased=True``, see the distribution example "
":ref:`examples_xmlpersistence` which illustrates an XPath-like query "
"system using algorithmic joins."
msgstr ""

#: of sqlalchemy.orm.query.Query.join:216
msgid ""
"A collection of one or more join conditions, each consisting of a "
"relationship-bound attribute or string relationship name representing an "
"\"on clause\", or a single target entity, or a tuple in the form of "
"``(target, onclause)``. A special two-argument calling form of the form "
"``target, onclause`` is also accepted."
msgstr ""

#: of sqlalchemy.orm.query.Query.join:222
msgid ""
"If True, indicate that the JOIN target should be anonymously aliased.  "
"Subsequent calls to :meth:`~.Query.filter` and similar will adapt the "
"incoming criterion to the target alias, until "
":meth:`~.Query.reset_joinpoint` is called."
msgstr ""

#: of sqlalchemy.orm.query.Query.join:226
msgid ""
"If True, the join used will be a left outer join, just as if the "
":meth:`.Query.outerjoin` method were called.  This flag is here to "
"maintain consistency with the same flag as accepted by "
":meth:`.FromClause.join` and other Core constructs.   .. versionadded:: "
"1.0.0"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:226
msgid ""
"If True, the join used will be a left outer join, just as if the "
":meth:`.Query.outerjoin` method were called.  This flag is here to "
"maintain consistency with the same flag as accepted by "
":meth:`.FromClause.join` and other Core constructs."
msgstr ""

#: of sqlalchemy.orm.query.Query.join:234
msgid "render FULL OUTER JOIN; implies ``isouter``.  .. versionadded:: 1.1"
msgstr ""

#: of sqlalchemy.orm.query.Query.join:234
msgid "render FULL OUTER JOIN; implies ``isouter``."
msgstr ""

#: of sqlalchemy.orm.query.Query.join:238
msgid ""
"When using ``aliased=True``, a setting of True here will cause the join "
"to be from the most recent joined target, rather than starting back from "
"the original FROM clauses of the query."
msgstr ""

#: of sqlalchemy.orm.query.Query.join:245
msgid ":ref:`ormtutorial_joins` in the ORM tutorial."
msgstr ""

#: of sqlalchemy.orm.query.Query.join:247
msgid ""
":ref:`inheritance_toplevel` for details on how :meth:`~.Query.join` is "
"used for inheritance relationships."
msgstr ""

#: of sqlalchemy.orm.query.Query.join:250
msgid ""
":func:`.orm.join` - a standalone ORM-level join function, used internally"
" by :meth:`.Query.join`, which in previous SQLAlchemy versions was the "
"primary ORM-level joining interface."
msgstr ""

#: of sqlalchemy.orm.query.Query.label:1
msgid ""
"Return the full SELECT statement represented by this :class:`.Query`, "
"converted to a scalar subquery with a label of the given name."
msgstr ""

#: of sqlalchemy.orm.query.Query.label:5
msgid "Analogous to :meth:`sqlalchemy.sql.expression.SelectBase.label`."
msgstr ""

#: of sqlalchemy.orm.query.Query.lazy_loaded_from:1
msgid ""
"An :class:`.InstanceState` that is using this :class:`.Query` for a lazy "
"load operation."
msgstr ""

#: of sqlalchemy.orm.query.Query.lazy_loaded_from:4
msgid ""
"This can be used for extensions like the horizontal sharding extension as"
" well as event handlers and custom mapper options to determine when a "
"query is being used to lazy load a relationship on an object."
msgstr ""

#: of sqlalchemy.orm.query.Query.limit:1
msgid "Apply a ``LIMIT`` to the query and return the newly resulting ``Query``."
msgstr ""

#: of sqlalchemy.orm.query.Query.merge_result:1
msgid "Merge a result into this :class:`.Query` object's Session."
msgstr ""

#: of sqlalchemy.orm.query.Query.merge_result:3
msgid ""
"Given an iterator returned by a :class:`.Query` of the same structure as "
"this one, return an identical iterator of results, with all mapped "
"instances merged into the session using :meth:`.Session.merge`. This is "
"an optimized method which will merge all mapped instances, preserving the"
" structure of the result rows and unmapped columns with less method "
"overhead than that of calling :meth:`.Session.merge` explicitly for each "
"value."
msgstr ""

#: of sqlalchemy.orm.query.Query.merge_result:11
msgid ""
"The structure of the results is determined based on the column list of "
"this :class:`.Query` - if these do not correspond, unchecked errors will "
"occur."
msgstr ""

#: of sqlalchemy.orm.query.Query.merge_result:15
msgid "The 'load' argument is the same as that of :meth:`.Session.merge`."
msgstr ""

#: of sqlalchemy.orm.query.Query.merge_result:17
msgid ""
"For an example of how :meth:`~.Query.merge_result` is used, see the "
"source code for the example :ref:`examples_caching`, where "
":meth:`~.Query.merge_result` is used to efficiently restore state from a "
"cache back into a target :class:`.Session`."
msgstr ""

#: of sqlalchemy.orm.query.Query.offset:1
msgid "Apply an ``OFFSET`` to the query and return the newly resulting ``Query``."
msgstr ""

#: of sqlalchemy.orm.query.Query.one:1
msgid "Return exactly one result or raise an exception."
msgstr ""

#: of sqlalchemy.orm.query.Query.one:3
msgid ""
"Raises ``sqlalchemy.orm.exc.NoResultFound`` if the query selects no rows."
"  Raises ``sqlalchemy.orm.exc.MultipleResultsFound`` if multiple object "
"identities are returned, or if multiple rows are returned for a query "
"that returns only scalar values as opposed to full identity-mapped "
"entities."
msgstr ""

#: of sqlalchemy.orm.query.Query.one:9
msgid "Calling :meth:`.one` results in an execution of the underlying query."
msgstr ""

#: of sqlalchemy.orm.query.Query.one:13
#: sqlalchemy.orm.query.Query.one_or_none:18
msgid ":meth:`.Query.first`"
msgstr ""

#: of sqlalchemy.orm.query.Query.one_or_none:1
msgid "Return at most one result or raise an exception."
msgstr ""

#: of sqlalchemy.orm.query.Query.one_or_none:3
msgid ""
"Returns ``None`` if the query selects no rows.  Raises "
"``sqlalchemy.orm.exc.MultipleResultsFound`` if multiple object identities"
" are returned, or if multiple rows are returned for a query that returns "
"only scalar values as opposed to full identity-mapped entities."
msgstr ""

#: of sqlalchemy.orm.query.Query.one_or_none:9
msgid ""
"Calling :meth:`.Query.one_or_none` results in an execution of the "
"underlying query."
msgstr ""

#: of sqlalchemy.orm.query.Query.one_or_none:14
msgid "Added :meth:`.Query.one_or_none`"
msgstr ""

#: of sqlalchemy.orm.query.Query.only_return_tuples:2
msgid "When set to True, the query results will always be a tuple,"
msgstr ""

#: of sqlalchemy.orm.query.Query.only_return_tuples:2
msgid "specifically for single element queries. The default is False."
msgstr ""

#: of sqlalchemy.orm.query.Query.only_return_tuples:4
msgid ".   .. versionadded:: 1.2.5"
msgstr ""

#: of sqlalchemy.orm.query.Query.options:1
msgid "Return a new Query object, applying the given list of mapper options."
msgstr ""

#: of sqlalchemy.orm.query.Query.options:4
msgid ""
"Most supplied options regard changing how column- and relationship-mapped"
" attributes are loaded. See the sections :ref:`deferred` and "
":doc:`/orm/loading_relationships` for reference documentation."
msgstr ""

#: of sqlalchemy.orm.query.Query.order_by:1
msgid ""
"apply one or more ORDER BY criterion to the query and return the newly "
"resulting ``Query``"
msgstr ""

#: of sqlalchemy.orm.query.Query.order_by:4
msgid ""
"All existing ORDER BY settings can be suppressed by passing ``None`` - "
"this will suppress any ORDER BY configured on mappers as well."
msgstr ""

#: of sqlalchemy.orm.query.Query.order_by:8
msgid ""
"Alternatively, passing False will reset ORDER BY and additionally re-"
"allow default mapper.order_by to take place.   Note mapper.order_by is "
"deprecated."
msgstr ""

#: of sqlalchemy.orm.query.Query.outerjoin:1
msgid ""
"Create a left outer join against this ``Query`` object's criterion and "
"apply generatively, returning the newly resulting ``Query``."
msgstr ""

#: of sqlalchemy.orm.query.Query.outerjoin:4
msgid "Usage is the same as the ``join()`` method."
msgstr ""

#: of sqlalchemy.orm.query.Query.params:1
msgid "add values for bind parameters which may have been specified in filter()."
msgstr ""

#: of sqlalchemy.orm.query.Query.params:4
msgid ""
"parameters may be specified using \\**kwargs, or optionally a single "
"dictionary as the first positional argument. The reason for both is that "
"\\**kwargs is convenient, however some parameter dictionaries contain "
"unicode keys in which case \\**kwargs cannot be used."
msgstr ""

#: of sqlalchemy.orm.query.Query.populate_existing:1
msgid ""
"Return a :class:`.Query` that will expire and refresh all instances as "
"they are loaded, or reused from the current :class:`.Session`."
msgstr ""

#: of sqlalchemy.orm.query.Query.populate_existing:4
msgid ""
":meth:`.populate_existing` does not improve behavior when the ORM is used"
" normally - the :class:`.Session` object's usual behavior of maintaining "
"a transaction and expiring all attributes after rollback or commit "
"handles object state automatically. This method is not intended for "
"general use."
msgstr ""

#: of sqlalchemy.orm.query.Query.prefix_with:1
msgid "Apply the prefixes to the query and return the newly resulting ``Query``."
msgstr ""

#: of sqlalchemy.orm.query.Query.prefix_with:4
msgid ""
"optional prefixes, typically strings, not using any commas.   In "
"particular is useful for MySQL keywords."
msgstr ""

#: of sqlalchemy.orm.query.Query.prefix_with:13
msgid "Would render::"
msgstr ""

#: of sqlalchemy.orm.query.Query.prefix_with:22
msgid ":meth:`.HasPrefixes.prefix_with`"
msgstr ""

#: of sqlalchemy.orm.query.Query.reset_joinpoint:1
msgid ""
"Return a new :class:`.Query`, where the \"join point\" has been reset "
"back to the base FROM entities of the query."
msgstr ""

#: of sqlalchemy.orm.query.Query.reset_joinpoint:4
msgid ""
"This method is usually used in conjunction with the ``aliased=True`` "
"feature of the :meth:`~.Query.join` method.  See the example in "
":meth:`~.Query.join` for how this is used."
msgstr ""

#: of sqlalchemy.orm.query.Query.scalar:1
msgid ""
"Return the first element of the first result or None if no rows present."
"  If multiple rows are returned, raises MultipleResultsFound."
msgstr ""

#: of sqlalchemy.orm.query.Query.select_entity_from:1
msgid ""
"Set the FROM clause of this :class:`.Query` to a core selectable, "
"applying it as a replacement FROM clause for corresponding mapped "
"entities."
msgstr ""

#: of sqlalchemy.orm.query.Query.select_entity_from:5
msgid ""
"The :meth:`.Query.select_entity_from` method supplies an alternative "
"approach to the use case of applying an :func:`.aliased` construct "
"explicitly throughout a query.  Instead of referring to the "
":func:`.aliased` construct explicitly, :meth:`.Query.select_entity_from` "
"automatically *adapts* all occurences of the entity to the target "
"selectable."
msgstr ""

#: of sqlalchemy.orm.query.Query.select_entity_from:12
msgid ""
"Given a case for :func:`.aliased` such as selecting ``User`` objects from"
" a SELECT statement::"
msgstr ""

#: of sqlalchemy.orm.query.Query.select_entity_from:21
msgid ""
"Above, we apply the ``user_alias`` object explicitly throughout the "
"query.  When it's not feasible for ``user_alias`` to be referenced "
"explicitly in many places, :meth:`.Query.select_entity_from` may be used "
"at the start of the query to adapt the existing ``User`` entity::"
msgstr ""

#: of sqlalchemy.orm.query.Query.select_entity_from:30
msgid ""
"Above, the generated SQL will show that the ``User`` entity is adapted to"
" our statement, even in the case of the WHERE clause:"
msgstr ""

#: of sqlalchemy.orm.query.Query.select_entity_from:41
msgid ""
"The :meth:`.Query.select_entity_from` method is similar to the "
":meth:`.Query.select_from` method, in that it sets the FROM clause of the"
" query.  The difference is that it additionally applies adaptation to the"
" other parts of the query that refer to the primary entity.  If above we "
"had used :meth:`.Query.select_from` instead, the SQL generated would have"
" been:"
msgstr ""

#: of sqlalchemy.orm.query.Query.select_entity_from:57
msgid ""
"To supply textual SQL to the :meth:`.Query.select_entity_from` method, we"
" can make use of the :func:`.text` construct.  However, the :func:`.text`"
" construct needs to be aligned with the columns of our entity, which is "
"achieved by making use of the :meth:`.TextClause.columns` method::"
msgstr ""

#: of sqlalchemy.orm.query.Query.select_entity_from:67
msgid ""
":meth:`.Query.select_entity_from` itself accepts an :func:`.aliased` "
"object, so that the special options of :func:`.aliased` such as "
":paramref:`.aliased.adapt_on_names` may be used within the scope of the "
":meth:`.Query.select_entity_from` method's adaptation services.  Suppose "
"a view ``user_view`` also returns rows from ``user``.    If we reflect "
"this view into a :class:`.Table`, this view has no relationship to the "
":class:`.Table` to which we are mapped, however we can use name matching "
"to select from it::"
msgstr ""

#: of sqlalchemy.orm.query.Query.select_entity_from:85
msgid ""
"The :meth:`.Query.select_entity_from` method now accepts an "
":func:`.aliased` object as an alternative to a :class:`.FromClause` "
"object."
msgstr ""

#: of sqlalchemy.orm.query.Query.select_entity_from:89
msgid ""
"a :class:`.FromClause` object that will replace the FROM clause of this "
":class:`.Query`.  It also may be an instance of :func:`.aliased`."
msgstr ""

#: of sqlalchemy.orm.query.Query.select_entity_from:97
msgid ":meth:`.Query.select_from`"
msgstr ""

#: of sqlalchemy.orm.query.Query.select_from:1
msgid "Set the FROM clause of this :class:`.Query` explicitly."
msgstr ""

#: of sqlalchemy.orm.query.Query.select_from:3
msgid ""
":meth:`.Query.select_from` is often used in conjunction with "
":meth:`.Query.join` in order to control which entity is selected from on "
"the \"left\" side of the join."
msgstr ""

#: of sqlalchemy.orm.query.Query.select_from:7
msgid ""
"The entity or selectable object here effectively replaces the \"left "
"edge\" of any calls to :meth:`~.Query.join`, when no joinpoint is "
"otherwise established - usually, the default \"join point\" is the "
"leftmost entity in the :class:`~.Query` object's list of entities to be "
"selected."
msgstr ""

#: of sqlalchemy.orm.query.Query.select_from:13
msgid "A typical example::"
msgstr ""

#: of sqlalchemy.orm.query.Query.select_from:19
msgid "Which produces SQL equivalent to::"
msgstr ""

#: of sqlalchemy.orm.query.Query.select_from:25
msgid ""
"collection of one or more entities to apply to the FROM clause.  Entities"
" can be mapped classes, :class:`.AliasedClass` objects, :class:`.Mapper` "
"objects as well as core :class:`.FromClause` elements like subqueries."
msgstr ""

#: of sqlalchemy.orm.query.Query.select_from:30
msgid ""
"This method no longer applies the given FROM object to be the selectable "
"from which matching entities select from; the :meth:`.select_entity_from`"
" method now accomplishes this.  See that method for a description of this"
" behavior."
msgstr ""

#: of sqlalchemy.orm.query.Query.select_from:39
msgid ":meth:`~.Query.join`"
msgstr ""

#: of sqlalchemy.orm.query.Query.select_from:41
msgid ":meth:`.Query.select_entity_from`"
msgstr ""

#: of sqlalchemy.orm.query.Query.selectable:1
msgid "Return the :class:`.Select` object emitted by this :class:`.Query`."
msgstr ""

#: of sqlalchemy.orm.query.Query.selectable:3
msgid "Used for :func:`.inspect` compatibility, this is equivalent to::"
msgstr ""

#: of sqlalchemy.orm.query.Query.slice:1
msgid ""
"Computes the \"slice\" of the :class:`.Query` represented by the given "
"indices and returns the resulting :class:`.Query`."
msgstr ""

#: of sqlalchemy.orm.query.Query.slice:4
msgid ""
"The start and stop indices behave like the argument to Python's built-in "
":func:`range` function. This method provides an alternative to using "
"``LIMIT``/``OFFSET`` to get a slice of the query."
msgstr ""

#: of sqlalchemy.orm.query.Query.slice:9
msgid "For example, ::"
msgstr ""

#: of sqlalchemy.orm.query.Query.slice:13
msgid "renders as"
msgstr ""

#: of sqlalchemy.orm.query.Query.slice:25
msgid ":meth:`.Query.limit`"
msgstr ""

#: of sqlalchemy.orm.query.Query.slice:27
msgid ":meth:`.Query.offset`"
msgstr ""

#: of sqlalchemy.orm.query.Query.statement:1
msgid "The full SELECT statement represented by this Query."
msgstr ""

#: of sqlalchemy.orm.query.Query.statement:3
msgid ""
"The statement by default will not have disambiguating labels applied to "
"the construct unless with_labels(True) is called first."
msgstr ""

#: of sqlalchemy.orm.query.Query.subquery:1
msgid ""
"return the full SELECT statement represented by this :class:`.Query`, "
"embedded within an :class:`.Alias`."
msgstr ""

#: of sqlalchemy.orm.query.Query.subquery:4
msgid "Eager JOIN generation within the query is disabled."
msgstr ""

#: of sqlalchemy.orm.query.Query.subquery:6
msgid ""
"string name to be assigned as the alias; this is passed through to "
":meth:`.FromClause.alias`. If ``None``, a name will be deterministically "
"generated at compile time."
msgstr ""

#: of sqlalchemy.orm.query.Query.subquery:11
msgid ""
"if True, :meth:`.with_labels` will be called on the :class:`.Query` first"
" to apply table-qualified labels to all columns."
msgstr ""

#: of sqlalchemy.orm.query.Query.subquery:15
msgid ""
"if True, :meth:`.Select.reduce_columns` will be called on the resulting "
":func:`.select` construct, to remove same-named columns where one also "
"refers to the other via foreign key or WHERE clause equivalence.  .. "
"versionchanged:: 0.8 the ``with_labels`` and ``reduce_columns``    "
"keyword arguments were added."
msgstr ""

#: of sqlalchemy.orm.query.Query.subquery:15
msgid ""
"if True, :meth:`.Select.reduce_columns` will be called on the resulting "
":func:`.select` construct, to remove same-named columns where one also "
"refers to the other via foreign key or WHERE clause equivalence."
msgstr ""

#: of sqlalchemy.orm.query.Query.subquery:20
msgid "the ``with_labels`` and ``reduce_columns`` keyword arguments were added."
msgstr ""

#: of sqlalchemy.orm.query.Query.suffix_with:1
msgid "Apply the suffix to the query and return the newly resulting ``Query``."
msgstr ""

#: of sqlalchemy.orm.query.Query.suffix_with:4
msgid "optional suffixes, typically strings, not using any commas."
msgstr ""

#: of sqlalchemy.orm.query.Query.suffix_with:11
msgid ":meth:`.Query.prefix_with`"
msgstr ""

#: of sqlalchemy.orm.query.Query.suffix_with:13
msgid ":meth:`.HasSuffixes.suffix_with`"
msgstr ""

#: of sqlalchemy.orm.query.Query.union:1
msgid "Produce a UNION of this Query against one or more queries."
msgstr ""

#: of sqlalchemy.orm.query.Query.union:10
msgid ""
"The method accepts multiple Query objects so as to control the level of "
"nesting.  A series of ``union()`` calls such as::"
msgstr ""

#: of sqlalchemy.orm.query.Query.union:15
msgid "will nest on each ``union()``, and produces::"
msgstr ""

#: of sqlalchemy.orm.query.Query.union:20
msgid "Whereas::"
msgstr ""

#: of sqlalchemy.orm.query.Query.union:24
msgid "produces::"
msgstr ""

#: of sqlalchemy.orm.query.Query.union:29
msgid ""
"Note that many database backends do not allow ORDER BY to be rendered on "
"a query called within UNION, EXCEPT, etc. To disable all ORDER BY clauses"
" including those configured on mappers, issue ``query.order_by(None)`` - "
"the resulting :class:`.Query` object will not render ORDER BY within its "
"SELECT statement."
msgstr ""

#: of sqlalchemy.orm.query.Query.union_all:1
msgid "Produce a UNION ALL of this Query against one or more queries."
msgstr ""

#: of sqlalchemy.orm.query.Query.update:1
msgid "Perform a bulk update query."
msgstr ""

#: of sqlalchemy.orm.query.Query.update:3
msgid "Updates rows matched by this query in the database."
msgstr ""

#: of sqlalchemy.orm.query.Query.update:14
msgid ""
"The :meth:`.Query.update` method is a \"bulk\" operation, which bypasses "
"ORM unit-of-work automation in favor of greater performance.  **Please "
"read all caveats and warnings below.**"
msgstr ""

#: of sqlalchemy.orm.query.Query.update:19
msgid ""
"a dictionary with attributes names, or alternatively mapped attributes or"
" SQL expressions, as keys, and literal values or sql expressions as "
"values.   If :ref:`parameter-ordered mode <updates_order_parameters>` is "
"desired, the values can be passed as a list of 2-tuples; this requires "
"that the "
":paramref:`~sqlalchemy.sql.expression.update.preserve_parameter_order` "
"flag is passed to the :paramref:`.Query.update.update_args` dictionary as"
" well.   .. versionchanged:: 1.0.0 - string names in the values "
"dictionary     are now resolved against the mapped entity; previously, "
"these     strings were passed as literal column names with no mapper-"
"level     translation."
msgstr ""

#: of sqlalchemy.orm.query.Query.update:19
msgid ""
"a dictionary with attributes names, or alternatively mapped attributes or"
" SQL expressions, as keys, and literal values or sql expressions as "
"values.   If :ref:`parameter-ordered mode <updates_order_parameters>` is "
"desired, the values can be passed as a list of 2-tuples; this requires "
"that the "
":paramref:`~sqlalchemy.sql.expression.update.preserve_parameter_order` "
"flag is passed to the :paramref:`.Query.update.update_args` dictionary as"
" well."
msgstr ""

#: of sqlalchemy.orm.query.Query.update:28
msgid ""
"- string names in the values dictionary are now resolved against the "
"mapped entity; previously, these strings were passed as literal column "
"names with no mapper-level translation."
msgstr ""

#: of sqlalchemy.orm.query.Query.update:33
msgid ""
"chooses the strategy to update the attributes on objects in the session. "
"Valid values are:     ``False`` - don't synchronize the session. This "
"option is the most    efficient and is reliable once the session is "
"expired, which    typically occurs after a commit(), or explicitly using"
"    expire_all(). Before the expiration, updated objects may still    "
"remain in the session with stale values on their attributes, which    can"
" lead to confusing results.     ``'fetch'`` - performs a select query "
"before the update to find    objects that are matched by the update "
"query. The updated    attributes are expired on matched objects.     "
"``'evaluate'`` - Evaluate the Query's criteria in Python straight    on "
"the objects in the session. If evaluation of the criteria isn't    "
"implemented, an exception is raised.     The expression evaluator "
"currently doesn't account for differing    string collations between the "
"database and Python."
msgstr ""

#: of sqlalchemy.orm.query.Query.update:33
msgid ""
"chooses the strategy to update the attributes on objects in the session. "
"Valid values are:"
msgstr ""

#: of sqlalchemy.orm.query.Query.update:36
msgid ""
"``False`` - don't synchronize the session. This option is the most "
"efficient and is reliable once the session is expired, which typically "
"occurs after a commit(), or explicitly using expire_all(). Before the "
"expiration, updated objects may still remain in the session with stale "
"values on their attributes, which can lead to confusing results."
msgstr ""

#: of sqlalchemy.orm.query.Query.update:43
msgid ""
"``'fetch'`` - performs a select query before the update to find objects "
"that are matched by the update query. The updated attributes are expired "
"on matched objects."
msgstr ""

#: of sqlalchemy.orm.query.Query.update:47
msgid ""
"``'evaluate'`` - Evaluate the Query's criteria in Python straight on the "
"objects in the session. If evaluation of the criteria isn't implemented, "
"an exception is raised."
msgstr ""

#: of sqlalchemy.orm.query.Query.update:54
msgid ""
"Optional dictionary, if present will be passed to the underlying "
":func:`.update` construct as the ``**kw`` for the object.  May be used to"
" pass dialect-specific arguments such as ``mysql_limit``, as well as "
"other special arguments such as "
":paramref:`~sqlalchemy.sql.expression.update.preserve_parameter_order`.  "
".. versionadded:: 1.0.0"
msgstr ""

#: of sqlalchemy.orm.query.Query.update:54
msgid ""
"Optional dictionary, if present will be passed to the underlying "
":func:`.update` construct as the ``**kw`` for the object.  May be used to"
" pass dialect-specific arguments such as ``mysql_limit``, as well as "
"other special arguments such as "
":paramref:`~sqlalchemy.sql.expression.update.preserve_parameter_order`."
msgstr ""

#: of sqlalchemy.orm.query.Query.update:65
msgid "**Additional Caveats for bulk query updates**"
msgstr ""

#: of sqlalchemy.orm.query.Query.update:67
msgid ""
"The method does **not** offer in-Python cascading of relationships - it "
"is assumed that ON UPDATE CASCADE is configured for any foreign key "
"references which require it, otherwise the database may emit an integrity"
" violation if foreign key references are being enforced."
msgstr ""

#: of sqlalchemy.orm.query.Query.update:73
msgid ""
"After the UPDATE, dependent objects in the :class:`.Session` which were "
"impacted by an ON UPDATE CASCADE may not contain the current state; this "
"issue is resolved once the :class:`.Session` is expired, which normally "
"occurs upon :meth:`.Session.commit` or can be forced by using "
":meth:`.Session.expire_all`."
msgstr ""

#: of sqlalchemy.orm.query.Query.update:90
msgid ""
"The method supports multiple table updates, as detailed in "
":ref:`multi_table_updates`, and this behavior does extend to support "
"updates of joined-inheritance and other multiple table mappings.  "
"However, the **join condition of an inheritance mapper is not "
"automatically rendered**. Care must be taken in any multiple-table update"
" to explicitly include the joining condition between those tables, even "
"in mappings where this is normally automatic. E.g. if a class "
"``Engineer`` subclasses ``Employee``, an UPDATE of the ``Engineer`` local"
" table using criteria against the ``Employee`` local table might look "
"like::"
msgstr ""

#: of sqlalchemy.orm.query.Query.update:108
msgid ""
"The polymorphic identity WHERE criteria is **not** included for single- "
"or joined- table updates - this must be added **manually**, even for "
"single table inheritance."
msgstr ""

#: of sqlalchemy.orm.query.Query.update:113
msgid ""
"The :meth:`.MapperEvents.before_update` and "
":meth:`.MapperEvents.after_update` events **are not invoked from this "
"method**.  Instead, the :meth:`.SessionEvents.after_bulk_update` method "
"is provided to act upon a mass UPDATE of entity rows."
msgstr ""

#: of sqlalchemy.orm.query.Query.update:121
msgid ":meth:`.Query.delete`"
msgstr ""

#: of sqlalchemy.orm.query.Query.value:1
msgid "Return a scalar result corresponding to the given column expression."
msgstr ""

#: of sqlalchemy.orm.query.Query.values:1
msgid ""
"Return an iterator yielding result tuples corresponding to the given list"
" of columns"
msgstr ""

#: of sqlalchemy.orm.query.Query.whereclause:1
msgid ""
"A readonly attribute which returns the current WHERE criterion for this "
"Query."
msgstr ""

#: of sqlalchemy.orm.query.Query.whereclause:4
msgid ""
"This returned value is a SQL expression construct, or ``None`` if no "
"criterion has been established."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_entities:1
msgid ""
"Return a new :class:`.Query` replacing the SELECT list with the given "
"entities."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_for_update:1
msgid ""
"return a new :class:`.Query` with the specified options for the ``FOR "
"UPDATE`` clause."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_for_update:4
msgid ""
"The behavior of this method is identical to that of "
":meth:`.SelectBase.with_for_update`.  When called with no arguments, the "
"resulting ``SELECT`` statement will have a ``FOR UPDATE`` clause "
"appended.  When additional arguments are specified, backend-specific "
"options such as ``FOR UPDATE NOWAIT`` or ``LOCK IN SHARE MODE`` can take "
"effect."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_for_update:15
msgid "The above query on a PostgreSQL backend will render like::"
msgstr ""

#: of sqlalchemy.orm.query.Query.with_for_update:19
msgid ""
":meth:`.Query.with_for_update` supersedes the "
":meth:`.Query.with_lockmode` method."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_for_update:24
msgid ""
":meth:`.GenerativeSelect.with_for_update` - Core level method with full "
"argument and behavioral description."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_hint:1
msgid ""
"Add an indexing or other executional context hint for the given entity or"
" selectable to this :class:`.Query`."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_hint:5
msgid ""
"Functionality is passed straight through to "
":meth:`~sqlalchemy.sql.expression.Select.with_hint`, with the addition "
"that ``selectable`` can be a :class:`.Table`, :class:`.Alias`, or ORM "
"entity / mapped class /etc."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_hint:13
msgid ":meth:`.Query.with_statement_hint`"
msgstr ""

#: of sqlalchemy.orm.query.Query.with_labels:1
msgid "Apply column labels to the return value of Query.statement."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_labels:3
msgid ""
"Indicates that this Query's `statement` accessor should return a SELECT "
"statement that applies labels to all columns in the form "
"<tablename>_<columnname>; this is commonly used to disambiguate columns "
"from multiple tables which have the same name."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_labels:9
msgid ""
"When the `Query` actually issues SQL to load rows, it always uses column "
"labeling."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_labels:12
msgid ""
"The :meth:`.Query.with_labels` method *only* applies the output of "
":attr:`.Query.statement`, and *not* to any of the result-row invoking "
"systems of :class:`.Query` itself, e.g. :meth:`.Query.first`, "
":meth:`.Query.all`, etc.   To execute a query using "
":meth:`.Query.with_labels`, invoke the :attr:`.Query.statement` using "
":meth:`.Session.execute`::"
msgstr ""

#: of sqlalchemy.orm.query.Query.with_lockmode:1
msgid ""
"Return a new :class:`.Query` object with the specified \"locking mode\", "
"which essentially refers to the ``FOR UPDATE`` clause."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_lockmode:4
msgid "superseded by :meth:`.Query.with_for_update`."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_lockmode:6
msgid ""
"a string representing the desired locking mode. Valid values are:  * "
"``None`` - translates to no lockmode  * ``'update'`` - translates to "
"``FOR UPDATE``   (standard SQL, supported by most dialects)  * "
"``'update_nowait'`` - translates to ``FOR UPDATE NOWAIT``   (supported by"
" Oracle, PostgreSQL 8.1 upwards)  * ``'read'`` - translates to ``LOCK IN "
"SHARE MODE`` (for MySQL),   and ``FOR SHARE`` (for PostgreSQL)"
msgstr ""

#: of sqlalchemy.orm.query.Query.with_lockmode:6
msgid "a string representing the desired locking mode. Valid values are:"
msgstr ""

#: of sqlalchemy.orm.query.Query.with_lockmode:9
msgid "``None`` - translates to no lockmode"
msgstr ""

#: of sqlalchemy.orm.query.Query.with_lockmode:11
msgid ""
"``'update'`` - translates to ``FOR UPDATE`` (standard SQL, supported by "
"most dialects)"
msgstr ""

#: of sqlalchemy.orm.query.Query.with_lockmode:14
msgid ""
"``'update_nowait'`` - translates to ``FOR UPDATE NOWAIT`` (supported by "
"Oracle, PostgreSQL 8.1 upwards)"
msgstr ""

#: of sqlalchemy.orm.query.Query.with_lockmode:17
msgid ""
"``'read'`` - translates to ``LOCK IN SHARE MODE`` (for MySQL), and ``FOR "
"SHARE`` (for PostgreSQL)"
msgstr ""

#: of sqlalchemy.orm.query.Query.with_lockmode:22
msgid ""
":meth:`.Query.with_for_update` - improved API for specifying the ``FOR "
"UPDATE`` clause."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_parent:1
msgid ""
"Add filtering criterion that relates the given instance to a child object"
" or collection, using its attribute state as well as an established "
":func:`.relationship()` configuration."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_parent:6
msgid ""
"The method uses the :func:`.with_parent` function to generate the clause,"
" the result of which is passed to :meth:`.Query.filter`."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_parent:9
msgid ""
"Parameters are the same as :func:`.with_parent`, with the exception that "
"the given property can be None, in which case a search is performed "
"against this :class:`.Query` object's target mapper."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_parent:13 sqlalchemy.orm.with_parent:11
msgid "An instance which has some :func:`.relationship`."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_parent:16 sqlalchemy.orm.with_parent:14
msgid ""
"String property name, or class-bound attribute, which indicates what "
"relationship from the instance should be used to reconcile the "
"parent/child relationship."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_parent:21 sqlalchemy.orm.with_parent:20
msgid ""
"Entity in which to consider as the left side.  This defaults to the "
"\"zero\" entity of the :class:`.Query` itself."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_polymorphic:1
msgid "Load columns for inheriting classes."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_polymorphic:3
msgid ""
":meth:`.Query.with_polymorphic` applies transformations to the \"main\" "
"mapped class represented by this :class:`.Query`. The \"main\" mapped "
"class here means the :class:`.Query` object's first argument is a full "
"class, i.e. ``session.query(SomeClass)``. These transformations allow "
"additional tables to be present in the FROM clause so that columns for a "
"joined-inheritance subclass are available in the query, both for the "
"purposes of load-time efficiency as well as the ability to use these "
"columns at query time."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_polymorphic:13
msgid ""
"See the documentation section :ref:`with_polymorphic` for details on how "
"this method is used."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_polymorphic:16
msgid ""
"A new and more flexible function :func:`.orm.with_polymorphic` supersedes"
" :meth:`.Query.with_polymorphic`, as it can apply the equivalent "
"functionality to any set of columns or classes in the :class:`.Query`, "
"not just the \"zero mapper\".  See that function for a description of "
"arguments."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_session:1
msgid "Return a :class:`.Query` that will use the given :class:`.Session`."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_session:3
msgid ""
"While the :class:`.Query` object is normally instantiated using the "
":meth:`.Session.query` method, it is legal to build the :class:`.Query` "
"directly without necessarily using a :class:`.Session`.  Such a "
":class:`.Query` object, or any :class:`.Query` already associated with a "
"different :class:`.Session`, can produce a new :class:`.Query` object "
"associated with a target session using this method::"
msgstr ""

#: of sqlalchemy.orm.query.Query.with_statement_hint:1
msgid "add a statement hint to this :class:`.Select`."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_statement_hint:3
msgid ""
"This method is similar to :meth:`.Select.with_hint` except that it does "
"not require an individual table, and instead applies to the statement as "
"a whole."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_statement_hint:7
msgid "This feature calls down into :meth:`.Select.with_statement_hint`."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_statement_hint:13
msgid ":meth:`.Query.with_hint`"
msgstr ""

#: of sqlalchemy.orm.query.Query.with_transformation:1
msgid "Return a new :class:`.Query` object transformed by the given function."
msgstr ""

#: of sqlalchemy.orm.query.Query.with_transformation:13
msgid ""
"This allows ad-hoc recipes to be created for :class:`.Query` objects.  "
"See the example at :ref:`hybrid_transformers`."
msgstr ""

#: of sqlalchemy.orm.query.Query.yield_per:1
msgid "Yield only ``count`` rows at a time."
msgstr ""

#: of sqlalchemy.orm.query.Query.yield_per:3
msgid ""
"The purpose of this method is when fetching very large result sets (> 10K"
" rows), to batch results in sub-collections and yield them out partially,"
" so that the Python interpreter doesn't need to declare very large areas "
"of memory which is both time consuming and leads to excessive memory use."
"   The performance from fetching hundreds of thousands of rows can often "
"double when a suitable yield-per setting (e.g. approximately 1000) is "
"used, even with DBAPIs that buffer rows (which are most)."
msgstr ""

#: of sqlalchemy.orm.query.Query.yield_per:12
msgid ""
"The :meth:`.Query.yield_per` method **is not compatible subqueryload "
"eager loading or joinedload eager loading when using collections**.  It "
"is potentially compatible with \"select in\" eager loading, **provided "
"the databse driver supports multiple, independent cursors** (pysqlite and"
" psycopg2 are known to work, MySQL and SQL Server ODBC drivers do not)."
msgstr ""

#: of sqlalchemy.orm.query.Query.yield_per:19
msgid ""
"Therefore in some cases, it may be helpful to disable eager loads, either"
" unconditionally with :meth:`.Query.enable_eagerloads`::"
msgstr ""

#: of sqlalchemy.orm.query.Query.yield_per:25
msgid ""
"Or more selectively using :func:`.lazyload`; such as with an asterisk to "
"specify the default loader scheme::"
msgstr ""

#: of sqlalchemy.orm.query.Query.yield_per:33
msgid ""
"Use this method with caution; if the same instance is present in more "
"than one batch of rows, end-user changes to attributes will be "
"overwritten."
msgstr ""

#: of sqlalchemy.orm.query.Query.yield_per:37
msgid ""
"In particular, it's usually impossible to use this setting with eagerly "
"loaded collections (i.e. any lazy='joined' or 'subquery') since those "
"collections will be cleared for a new load when encountered in a "
"subsequent result batch. In the case of 'subquery' loading, the full "
"result for all rows is fetched which generally defeats the purpose of "
":meth:`~sqlalchemy.orm.query.Query.yield_per`."
msgstr ""

#: of sqlalchemy.orm.query.Query.yield_per:45
msgid ""
"Also note that while :meth:`~sqlalchemy.orm.query.Query.yield_per` will "
"set the ``stream_results`` execution option to True, currently this is "
"only understood by :mod:`~sqlalchemy.dialects.postgresql.psycopg2`, "
":mod:`~sqlalchemy.dialects.mysql.mysqldb` and "
":mod:`~sqlalchemy.dialects.mysql.pymysql` dialects which will stream "
"results using server side cursors instead of pre-buffer all rows for this"
" query. Other DBAPIs **pre-buffer all rows** before making them "
"available.  The memory use of raw database rows is much less than that of"
" an ORM-mapped object, but should still be taken into consideration when "
"benchmarking."
msgstr ""

#: of sqlalchemy.orm.query.Query.yield_per:61
msgid ":meth:`.Query.enable_eagerloads`"
msgstr ""

#: ../../orm/query.rst:25
msgid "ORM-Specific Query Constructs"
msgstr ""

#: of sqlalchemy.orm.aliased:1
msgid ""
"Produce an alias of the given element, usually an :class:`.AliasedClass` "
"instance."
msgstr ""

#: of sqlalchemy.orm.aliased:10
msgid ""
"The :func:`.aliased` function is used to create an ad-hoc mapping of a "
"mapped class to a new selectable.  By default, a selectable is generated "
"from the normally mapped selectable (typically a :class:`.Table`) using "
"the :meth:`.FromClause.alias` method. However, :func:`.aliased` can also "
"be used to link the class to a new :func:`.select` statement.   Also, the"
" :func:`.with_polymorphic` function is a variant of :func:`.aliased` that"
" is intended to specify a so-called \"polymorphic selectable\", that "
"corresponds to the union of several joined-inheritance subclasses at "
"once."
msgstr ""

#: of sqlalchemy.orm.aliased:20
msgid ""
"For convenience, the :func:`.aliased` function also accepts plain "
":class:`.FromClause` constructs, such as a :class:`.Table` or "
":func:`.select` construct.   In those cases, the "
":meth:`.FromClause.alias` method is called on the object and the new "
":class:`.Alias` object returned.  The returned :class:`.Alias` is not "
"ORM-mapped in this case."
msgstr ""

#: of sqlalchemy.orm.aliased:26
msgid ""
"element to be aliased.  Is normally a mapped class, but for convenience "
"can also be a :class:`.FromClause` element."
msgstr ""

#: of sqlalchemy.orm.aliased:29
msgid ""
"Optional selectable unit to map the element to.  This should normally be "
"a :class:`.Alias` object corresponding to the :class:`.Table` to which "
"the class is mapped, or to a :func:`.select` construct that is compatible"
" with the mapping.   By default, a simple anonymous alias of the mapped "
"table is generated."
msgstr ""

#: of sqlalchemy.orm.aliased:35
msgid ""
"optional string name to use for the alias, if not specified by the "
"``alias`` parameter.  The name, among other things, forms the attribute "
"name that will be accessible via tuples returned by a :class:`.Query` "
"object."
msgstr ""

#: of sqlalchemy.orm.aliased:40
msgid ""
"Boolean, will be passed through to the :meth:`.FromClause.alias` call so "
"that aliases of :class:`.Join` objects don't include an enclosing SELECT."
"  This can lead to more efficient queries in many circumstances.  A JOIN "
"against a nested JOIN will be rewritten as a JOIN against an aliased "
"SELECT subquery on backends that don't support this syntax.  .. "
"versionadded:: 0.9.0  .. seealso:: :meth:`.Join.alias`"
msgstr ""

#: of sqlalchemy.orm.aliased:40
msgid ""
"Boolean, will be passed through to the :meth:`.FromClause.alias` call so "
"that aliases of :class:`.Join` objects don't include an enclosing SELECT."
"  This can lead to more efficient queries in many circumstances.  A JOIN "
"against a nested JOIN will be rewritten as a JOIN against an aliased "
"SELECT subquery on backends that don't support this syntax."
msgstr ""

#: of sqlalchemy.orm.aliased:49
msgid ":meth:`.Join.alias`"
msgstr ""

#: of sqlalchemy.orm.aliased:51
msgid ""
"if True, more liberal \"matching\" will be used when mapping the mapped "
"columns of the ORM entity to those of the given selectable - a name-based"
" match will be performed if the given selectable doesn't otherwise have a"
" column that corresponds to one on the entity.  The use case for this is "
"when associating an entity with some derived selectable such as one that "
"uses aggregate functions::     class UnitPrice(Base):        "
"__tablename__ = 'unit_price'        ...        unit_id = Column(Integer)"
"        price = Column(Numeric)     aggregated_unit_price = "
"Session.query(                                "
"func.sum(UnitPrice.price).label('price')                            "
").group_by(UnitPrice.unit_id).subquery()     aggregated_unit_price = "
"aliased(UnitPrice,                alias=aggregated_unit_price, "
"adapt_on_names=True)  Above, functions on ``aggregated_unit_price`` which"
" refer to ``.price`` will return the "
"``func.sum(UnitPrice.price).label('price')`` column, as it is matched on "
"the name \"price\".  Ordinarily, the \"price\" function wouldn't have any"
" \"column correspondence\" to the actual ``UnitPrice.price`` column as it"
" is not a proxy of the original.  .. versionadded:: 0.7.3"
msgstr ""

#: of sqlalchemy.orm.aliased:51
msgid ""
"if True, more liberal \"matching\" will be used when mapping the mapped "
"columns of the ORM entity to those of the given selectable - a name-based"
" match will be performed if the given selectable doesn't otherwise have a"
" column that corresponds to one on the entity.  The use case for this is "
"when associating an entity with some derived selectable such as one that "
"uses aggregate functions::"
msgstr ""

#: of sqlalchemy.orm.aliased:72
msgid ""
"Above, functions on ``aggregated_unit_price`` which refer to ``.price`` "
"will return the ``func.sum(UnitPrice.price).label('price')`` column, as "
"it is matched on the name \"price\".  Ordinarily, the \"price\" function "
"wouldn't have any \"column correspondence\" to the actual "
"``UnitPrice.price`` column as it is not a proxy of the original."
msgstr ""

#: of sqlalchemy.orm.util.AliasedClass:1
msgid "Represents an \"aliased\" form of a mapped class for usage with Query."
msgstr ""

#: of sqlalchemy.orm.util.AliasedClass:3
msgid ""
"The ORM equivalent of a :func:`sqlalchemy.sql.expression.alias` "
"construct, this object mimics the mapped class using a __getattr__ scheme"
" and maintains a reference to a real "
":class:`~sqlalchemy.sql.expression.Alias` object."
msgstr ""

#: of sqlalchemy.orm.util.AliasedClass:8
msgid ""
"Usage is via the :func:`.orm.aliased` function, or alternatively via the "
":func:`.orm.with_polymorphic` function."
msgstr ""

#: of sqlalchemy.orm.util.AliasedClass:11
msgid "Usage example::"
msgstr ""

#: of sqlalchemy.orm.util.AliasedClass:19
msgid ""
"The resulting object is an instance of :class:`.AliasedClass`. This "
"object implements an attribute scheme which produces the same attribute "
"and method interface as the original mapped class, allowing "
":class:`.AliasedClass` to be compatible with any attribute technique "
"which works on the original class, including hybrid attributes (see "
":ref:`hybrids_toplevel`)."
msgstr ""

#: of sqlalchemy.orm.util.AliasedClass:26
msgid ""
"The :class:`.AliasedClass` can be inspected for its underlying "
":class:`.Mapper`, aliased selectable, and other information using "
":func:`.inspect`::"
msgstr ""

#: of sqlalchemy.orm.util.AliasedClass:34
msgid "The resulting inspection object is an instance of :class:`.AliasedInsp`."
msgstr ""

#: of sqlalchemy.orm.util.AliasedClass:36
msgid ""
"See :func:`.aliased` and :func:`.with_polymorphic` for construction "
"argument descriptions."
msgstr ""

#: of sqlalchemy.orm.util.AliasedInsp:1
msgid "Provide an inspection interface for an :class:`.AliasedClass` object."
msgstr ""

#: of sqlalchemy.orm.util.AliasedInsp:4
msgid ""
"The :class:`.AliasedInsp` object is returned given an "
":class:`.AliasedClass` using the :func:`.inspect` function::"
msgstr ""

#: of sqlalchemy.orm.util.AliasedInsp:14
msgid "Attributes on :class:`.AliasedInsp` include:"
msgstr ""

#: of sqlalchemy.orm.util.AliasedInsp:17
msgid "``entity`` - the :class:`.AliasedClass` represented."
msgstr ""

#: of sqlalchemy.orm.util.AliasedInsp:18
msgid "``mapper`` - the :class:`.Mapper` mapping the underlying class."
msgstr ""

#: of sqlalchemy.orm.util.AliasedInsp:19
msgid ""
"``selectable`` - the :class:`.Alias` construct which ultimately "
"represents an aliased :class:`.Table` or :class:`.Select` construct."
msgstr ""

#: of sqlalchemy.orm.util.AliasedInsp:22
msgid ""
"``name`` - the name of the alias.  Also is used as the attribute name "
"when returned in a result tuple from :class:`.Query`."
msgstr ""

#: of sqlalchemy.orm.util.AliasedInsp:24
msgid ""
"``with_polymorphic_mappers`` - collection of :class:`.Mapper` objects "
"indicating all those mappers expressed in the select construct for the "
":class:`.AliasedClass`."
msgstr ""

#: of sqlalchemy.orm.util.AliasedInsp:27
msgid ""
"``polymorphic_on`` - an alternate column or SQL expression which will be "
"used as the \"discriminator\" for a polymorphic load."
msgstr ""

#: of sqlalchemy.orm.util.AliasedInsp:32
msgid ":ref:`inspection_toplevel`"
msgstr ""

#: of sqlalchemy.orm.query.Bundle:1
msgid ""
"A grouping of SQL expressions that are returned by a :class:`.Query` "
"under one namespace."
msgstr ""

#: of sqlalchemy.orm.query.Bundle:4
msgid ""
"The :class:`.Bundle` essentially allows nesting of the tuple-based "
"results returned by a column-oriented :class:`.Query` object.  It also is"
" extensible via simple subclassing, where the primary capability to "
"override is that of how the set of expressions should be returned, "
"allowing post-processing as well as custom return types, without "
"involving ORM identity-mapped classes."
msgstr ""

#: of sqlalchemy.orm.query.Bundle:15
msgid ":ref:`bundles`"
msgstr ""

#: of sqlalchemy.orm.query.Bundle.c:1
msgid "An alias for :attr:`.Bundle.columns`."
msgstr ""

#: of sqlalchemy.orm.query.Bundle.columns:1
msgid "A namespace of SQL expressions referred to by this :class:`.Bundle`."
msgstr ""

#: of sqlalchemy.orm.query.Bundle.columns:9
msgid "Nesting of bundles is also supported::"
msgstr ""

#: of sqlalchemy.orm.query.Bundle.columns:21
msgid ":attr:`.Bundle.c`"
msgstr ""

#: of sqlalchemy.orm.query.Bundle.create_row_processor:1
msgid "Produce the \"row processing\" function for this :class:`.Bundle`."
msgstr ""

#: of sqlalchemy.orm.query.Bundle.create_row_processor:3
msgid "May be overridden by subclasses."
msgstr ""

#: of sqlalchemy.orm.query.Bundle.create_row_processor:7
msgid ":ref:`bundles` - includes an example of subclassing."
msgstr ""

#: of sqlalchemy.orm.query.Bundle.label:1
msgid "Provide a copy of this :class:`.Bundle` passing a new label."
msgstr ""

#: of sqlalchemy.orm.query.Bundle.single_entity:1
msgid ""
"If True, queries for a single Bundle will be returned as a single entity,"
" rather than an element within a keyed tuple."
msgstr ""

#: of sqlalchemy.util.KeyedTuple:1
msgid "``tuple`` subclass that adds labeled names."
msgstr ""

#: of sqlalchemy.util.KeyedTuple:11
msgid ""
"Result rows returned by :class:`.Query` that contain multiple ORM "
"entities and/or column expressions make use of this class to return rows."
msgstr ""

#: of sqlalchemy.util.KeyedTuple:15
msgid ""
"The :class:`.KeyedTuple` exhibits similar behavior to the "
"``collections.namedtuple()`` construct provided in the Python standard "
"library, however is architected very differently. Unlike "
"``collections.namedtuple()``, :class:`.KeyedTuple` is does not rely on "
"creation of custom subtypes in order to represent a new series of keys, "
"instead each :class:`.KeyedTuple` instance receives its list of keys in "
"place.   The subtype approach of ``collections.namedtuple()`` introduces "
"significant complexity and performance overhead, which is not necessary "
"for the :class:`.Query` object's use case."
msgstr ""

#: of sqlalchemy.util.KeyedTuple:26
msgid ""
"Compatibility methods with ``collections.namedtuple()`` have been added "
"including :attr:`.KeyedTuple._fields` and :meth:`.KeyedTuple._asdict`."
msgstr ""

#: of sqlalchemy.util.KeyedTuple:33
msgid ":ref:`ormtutorial_querying`"
msgstr ""

#: of sqlalchemy.util.KeyedTuple._asdict:1
msgid "Return the contents of this :class:`.KeyedTuple` as a dictionary."
msgstr ""

#: of sqlalchemy.util.KeyedTuple._asdict:3
msgid ""
"This method provides compatibility with ``collections.namedtuple()``, "
"with the exception that the dictionary returned is **not** ordered."
msgstr ""

#: of sqlalchemy.util.KeyedTuple._fields:1
msgid "Return a tuple of string key names for this :class:`.KeyedTuple`."
msgstr ""

#: of sqlalchemy.util.KeyedTuple._fields:3
msgid "This method provides compatibility with ``collections.namedtuple()``."
msgstr ""

#: of sqlalchemy.util.KeyedTuple._fields:9
msgid ":meth:`.KeyedTuple.keys`"
msgstr ""

#: of sqlalchemy.util.KeyedTuple.keys:1
msgid "Return a list of string key names for this :class:`.KeyedTuple`."
msgstr ""

#: of sqlalchemy.util.KeyedTuple.keys:5
msgid ":attr:`.KeyedTuple._fields`"
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load:1
msgid ""
"Represents loader options which modify the state of a :class:`.Query` in "
"order to affect how various mapped attributes are loaded."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load:5
msgid ""
"The :class:`.Load` object is in most cases used implicitly behind the "
"scenes when one makes use of a query option like :func:`.joinedload`, "
":func:`.defer`, or similar.   However, the :class:`.Load` object can also"
" be used directly, and in some cases can be useful."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load:10
msgid ""
"To use :class:`.Load` directly, instantiate it with the target mapped "
"class as the argument.   This style of usage is useful when dealing with "
"a :class:`.Query` that has multiple entities::"
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load:16
msgid ""
"The above ``myopt`` can now be used with :meth:`.Query.options`, where it"
" will only take effect for the ``MyClass`` entity::"
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load:21
msgid ""
"One case where :class:`.Load` is useful as public API is when specifying "
"\"wildcard\" options that only take effect for a certain class::"
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load:26
msgid ""
"Above, all relationships on ``Order`` will be lazy-loaded, but other "
"attributes on those descendant objects will load using their normal "
"loader strategy."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load:32
msgid ":ref:`loading_toplevel`"
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.baked_lazyload:1
msgid ""
"Produce a new :class:`.Load` object with the :func:`.orm.baked_lazyload` "
"option applied."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.baked_lazyload:4
msgid "See :func:`.orm.baked_lazyload` for usage examples."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.contains_eager:1
msgid ""
"Produce a new :class:`.Load` object with the :func:`.orm.contains_eager` "
"option applied."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.contains_eager:4
msgid "See :func:`.orm.contains_eager` for usage examples."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.defaultload:1
msgid ""
"Produce a new :class:`.Load` object with the :func:`.orm.defaultload` "
"option applied."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.defaultload:4
msgid "See :func:`.orm.defaultload` for usage examples."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.defer:1
msgid ""
"Produce a new :class:`.Load` object with the :func:`.orm.defer` option "
"applied."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.defer:4
msgid "See :func:`.orm.defer` for usage examples."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.immediateload:1
msgid ""
"Produce a new :class:`.Load` object with the :func:`.orm.immediateload` "
"option applied."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.immediateload:4
msgid "See :func:`.orm.immediateload` for usage examples."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.joinedload:1
msgid ""
"Produce a new :class:`.Load` object with the :func:`.orm.joinedload` "
"option applied."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.joinedload:4
msgid "See :func:`.orm.joinedload` for usage examples."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.lazyload:1
msgid ""
"Produce a new :class:`.Load` object with the :func:`.orm.lazyload` option"
" applied."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.lazyload:4
msgid "See :func:`.orm.lazyload` for usage examples."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.load_only:1
msgid ""
"Produce a new :class:`.Load` object with the :func:`.orm.load_only` "
"option applied."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.load_only:4
msgid "See :func:`.orm.load_only` for usage examples."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.noload:1
msgid ""
"Produce a new :class:`.Load` object with the :func:`.orm.noload` option "
"applied."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.noload:4
msgid "See :func:`.orm.noload` for usage examples."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.process_query:1
msgid "Apply a modification to the given :class:`.Query`."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.process_query_conditionally:1
msgid ""
"same as process_query(), except that this option may not apply to the "
"given query."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.process_query_conditionally:4
msgid ""
"This is typically used during a lazy load or scalar refresh operation to "
"propagate options stated in the original Query to the new Query being "
"used for the load.  It occurs for those options that specify "
"propagate_to_loaders=True."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.raiseload:1
msgid ""
"Produce a new :class:`.Load` object with the :func:`.orm.raiseload` "
"option applied."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.raiseload:4
msgid "See :func:`.orm.raiseload` for usage examples."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.selectin_polymorphic:1
msgid ""
"Produce a new :class:`.Load` object with the "
":func:`.orm.selectin_polymorphic` option applied."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.selectin_polymorphic:4
msgid "See :func:`.orm.selectin_polymorphic` for usage examples."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.selectinload:1
msgid ""
"Produce a new :class:`.Load` object with the :func:`.orm.selectinload` "
"option applied."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.selectinload:4
msgid "See :func:`.orm.selectinload` for usage examples."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.subqueryload:1
msgid ""
"Produce a new :class:`.Load` object with the :func:`.orm.subqueryload` "
"option applied."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.subqueryload:4
msgid "See :func:`.orm.subqueryload` for usage examples."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.undefer:1
msgid ""
"Produce a new :class:`.Load` object with the :func:`.orm.undefer` option "
"applied."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.undefer:4
msgid "See :func:`.orm.undefer` for usage examples."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.undefer_group:1
msgid ""
"Produce a new :class:`.Load` object with the :func:`.orm.undefer_group` "
"option applied."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.undefer_group:4
msgid "See :func:`.orm.undefer_group` for usage examples."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.with_expression:1
msgid ""
"Produce a new :class:`.Load` object with the :func:`.orm.with_expression`"
" option applied."
msgstr ""

#: of sqlalchemy.orm.strategy_options.Load.with_expression:4
msgid "See :func:`.orm.with_expression` for usage examples."
msgstr ""

#: of sqlalchemy.orm.join:1
msgid "Produce an inner join between left and right clauses."
msgstr ""

#: of sqlalchemy.orm.join:3
msgid ""
":func:`.orm.join` is an extension to the core join interface provided by "
":func:`.sql.expression.join()`, where the left and right selectables may "
"be not only core selectable objects such as :class:`.Table`, but also "
"mapped classes or :class:`.AliasedClass` instances.   The \"on\" clause "
"can be a SQL expression, or an attribute or string name referencing a "
"configured :func:`.relationship`."
msgstr ""

#: of sqlalchemy.orm.join:11
msgid ""
":func:`.orm.join` is not commonly needed in modern usage, as its "
"functionality is encapsulated within that of the :meth:`.Query.join` "
"method, which features a significant amount of automation beyond "
":func:`.orm.join` by itself.  Explicit usage of :func:`.orm.join` with "
":class:`.Query` involves usage of the :meth:`.Query.select_from` method, "
"as in::"
msgstr ""

#: of sqlalchemy.orm.join:24
msgid "In modern SQLAlchemy the above join can be written more succinctly as::"
msgstr ""

#: of sqlalchemy.orm.join:31
msgid ""
"See :meth:`.Query.join` for information on modern usage of ORM level "
"joins."
msgstr ""

#: of sqlalchemy.orm.join:34
msgid "- the ``join_to_left`` parameter is no longer used, and is deprecated."
msgstr ""

#: of sqlalchemy.orm.outerjoin:1
msgid "Produce a left outer join between left and right clauses."
msgstr ""

#: of sqlalchemy.orm.outerjoin:3
msgid ""
"This is the \"outer join\" version of the :func:`.orm.join` function, "
"featuring the same behavior except that an OUTER JOIN is generated. See "
"that function's documentation for other usage details."
msgstr ""

#: of sqlalchemy.orm.with_parent:1
msgid ""
"Create filtering criterion that relates this query's primary entity to "
"the given related instance, using established :func:`.relationship()` "
"configuration."
msgstr ""

#: of sqlalchemy.orm.with_parent:5
msgid ""
"The SQL rendered is the same as that rendered when a lazy loader would "
"fire off from the given parent on that attribute, meaning that the "
"appropriate state is taken from the parent object in Python without the "
"need to render joins to the parent table in the rendered statement."
msgstr ""

#: of sqlalchemy.orm.with_parent:19
msgid ""
"Entity in which to consider as the left side.  This defaults to the "
"\"zero\" entity of the :class:`.Query` itself.  .. versionadded:: 1.2"
msgstr ""

