# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: SQLAlchemy 1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-02-21 14:32+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../changelog/migration_10.rst:3
msgid "What's New in SQLAlchemy 1.0?"
msgstr ""

#: ../../changelog/migration_10.rst:5
msgid "About this Document"
msgstr ""

#: ../../changelog/migration_10.rst:7
msgid ""
"This document describes changes between SQLAlchemy version 0.9, "
"undergoing maintenance releases as of May, 2014, and SQLAlchemy version "
"1.0, released in April, 2015."
msgstr ""

#: ../../changelog/migration_10.rst:11
msgid "Document last updated: June 9, 2015"
msgstr ""

#: ../../changelog/migration_10.rst:14
msgid "Introduction"
msgstr ""

#: ../../changelog/migration_10.rst:16
msgid ""
"This guide introduces what's new in SQLAlchemy version 1.0, and also "
"documents changes which affect users migrating their applications from "
"the 0.9 series of SQLAlchemy to 1.0."
msgstr ""

#: ../../changelog/migration_10.rst:20
msgid ""
"Please carefully review the sections on behavioral changes for "
"potentially backwards-incompatible changes in behavior."
msgstr ""

#: ../../changelog/migration_10.rst:25
msgid "New Features and Improvements - ORM"
msgstr ""

#: ../../changelog/migration_10.rst:28
msgid "New Session Bulk INSERT/UPDATE API"
msgstr ""

#: ../../changelog/migration_10.rst:30
msgid ""
"A new series of :class:`.Session` methods which provide hooks directly "
"into the unit of work's facility for emitting INSERT and UPDATE "
"statements has been created.  When used correctly, this expert-oriented "
"system can allow ORM-mappings to be used to generate bulk insert and "
"update statements batched into executemany groups, allowing the "
"statements to proceed at speeds that rival direct use of the Core."
msgstr ""

#: ../../changelog/migration_10.rst:39
msgid ":ref:`bulk_operations` - introduction and full documentation"
msgstr ""

#: ../../changelog/migration_10.rst:41
msgid ":ticket:`3100`"
msgstr ""

#: ../../changelog/migration_10.rst:44
msgid "New Performance Example Suite"
msgstr ""

#: ../../changelog/migration_10.rst:46
msgid ""
"Inspired by the benchmarking done for the :ref:`bulk_operations` feature "
"as well as for the :ref:`faq_how_to_profile` section of the FAQ, a new "
"example section has been added which features several scripts designed to"
" illustrate the relative performance profile of various Core and ORM "
"techniques.  The scripts are organized into use cases, and are packaged "
"under a single console interface such that any combination of "
"demonstrations can be run, dumping out timings, Python profile results "
"and/or RunSnake profile displays."
msgstr ""

#: ../../changelog/migration_10.rst:57
msgid ":ref:`examples_performance`"
msgstr ""

#: ../../changelog/migration_10.rst:60
msgid "\"Baked\" Queries"
msgstr ""

#: ../../changelog/migration_10.rst:62
msgid ""
"The \"baked\" query feature is an unusual new approach which allows for "
"straightforward construction an invocation of :class:`.Query` objects "
"using caching, which upon successive calls features vastly reduced Python"
" function call overhead (over 75%).    By  specifying a :class:`.Query` "
"object as a series of lambdas which are only invoked once, a query as a "
"pre-compiled unit begins to be feasible::"
msgstr ""

#: ../../changelog/migration_10.rst:90
msgid ":ref:`baked_toplevel`"
msgstr ""

#: ../../changelog/migration_10.rst:92
msgid ":ticket:`3054`"
msgstr ""

#: ../../changelog/migration_10.rst:97
msgid ""
"Improvements to declarative mixins, ``@declared_attr`` and related "
"features"
msgstr ""

#: ../../changelog/migration_10.rst:99
msgid ""
"The declarative system in conjunction with :class:`.declared_attr` has "
"been overhauled to support new capabilities."
msgstr ""

#: ../../changelog/migration_10.rst:102
msgid ""
"A function decorated with :class:`.declared_attr` is now called only "
"**after** any mixin-based column copies are generated.  This means the "
"function can call upon mixin-established columns and will receive a "
"reference to the correct :class:`.Column` object::"
msgstr ""

#: ../../changelog/migration_10.rst:118
msgid ""
"Above, ``SomeClass.foobar_prop`` will be invoked against ``SomeClass``, "
"and ``SomeClass.foobar`` will be the final :class:`.Column` object that "
"is to be mapped to ``SomeClass``, as opposed to the non-copied object "
"present directly on ``HasFooBar``, even though the columns aren't mapped "
"yet."
msgstr ""

#: ../../changelog/migration_10.rst:123
msgid ""
"The :class:`.declared_attr` function now **memoizes** the value that's "
"returned on a per-class basis, so that repeated calls to the same "
"attribute will return the same value.  We can alter the example to "
"illustrate this::"
msgstr ""

#: ../../changelog/migration_10.rst:141
msgid ""
"Previously, ``SomeClass`` would be mapped with one particular copy of the"
" ``foobar`` column, but the ``foobar_prop`` by calling upon ``foobar`` a "
"second time would produce a different column.   The value of "
"``SomeClass.foobar`` is now memoized during declarative setup time, so "
"that even before the attribute is mapped by the mapper, the interim "
"column value will remain consistent no matter how many times the "
":class:`.declared_attr` is called upon."
msgstr ""

#: ../../changelog/migration_10.rst:149
msgid ""
"The two behaviors above should help considerably with declarative "
"definition of many types of mapper properties that derive from other "
"attributes, where the :class:`.declared_attr` function is called upon "
"from other :class:`.declared_attr` functions locally present before the "
"class is actually mapped."
msgstr ""

#: ../../changelog/migration_10.rst:155
msgid ""
"For a pretty slim edge case where one wishes to build a declarative mixin"
" that establishes distinct columns per subclass, a new modifier "
":attr:`.declared_attr.cascading` is added.  With this modifier, the "
"decorated function will be invoked individually for each class in the "
"mapped inheritance hierarchy.  While this is already the behavior for "
"special attributes such as ``__table_args__`` and ``__mapper_args__``, "
"for columns and other properties the behavior by default assumes that "
"attribute is affixed to the base class only, and just inherited from "
"subclasses. With :attr:`.declared_attr.cascading`, individual behaviors "
"can be applied::"
msgstr ""

#: ../../changelog/migration_10.rst:184
msgid ":ref:`mixin_inheritance_columns`"
msgstr ""

#: ../../changelog/migration_10.rst:186
msgid ""
"Finally, the :class:`.AbstractConcreteBase` class has been reworked so "
"that a relationship or other mapper property can be set up inline on the "
"abstract base::"
msgstr ""

#: ../../changelog/migration_10.rst:219
msgid ""
"The above mapping will set up a table ``cca`` with both an ``id`` and a "
"``something_id`` column, and ``Concrete`` will also have a relationship "
"``something``.  The new feature is that ``Abstract`` will also have an "
"independently configured relationship ``something`` that builds against "
"the polymorphic union of the base."
msgstr ""

#: ../../changelog/migration_10.rst:225
msgid ":ticket:`3150` :ticket:`2670` :ticket:`3149` :ticket:`2952` :ticket:`3050`"
msgstr ""

#: ../../changelog/migration_10.rst:228
#, python-format
msgid "ORM full object fetches 25% faster"
msgstr ""

#: ../../changelog/migration_10.rst:230
#, python-format
msgid ""
"The mechanics of the ``loading.py`` module as well as the identity map "
"have undergone several passes of inlining, refactoring, and pruning, so "
"that a raw load of rows now populates ORM-based objects around 25% "
"faster. Assuming a 1M row table, a script like the following illustrates "
"the type of load that's improved the most::"
msgstr ""

#: ../../changelog/migration_10.rst:266
msgid ""
"Local MacBookPro results bench from 19 seconds for 0.9 down to 14 seconds"
" for 1.0.  The :meth:`.Query.yield_per` call is always a good idea when "
"batching huge numbers of rows, as it prevents the Python interpreter from"
" having to allocate a huge amount of memory for all objects and their "
"instrumentation at once.  Without the :meth:`.Query.yield_per`, the above"
" script on the MacBookPro is 31 seconds on 0.9 and 26 seconds on 1.0, the"
" extra time spent setting up very large memory buffers."
msgstr ""

#: ../../changelog/migration_10.rst:277
msgid "New KeyedTuple implementation dramatically faster"
msgstr ""

#: ../../changelog/migration_10.rst:279
msgid ""
"We took a look into the :class:`.KeyedTuple` implementation in the hopes "
"of improving queries like this::"
msgstr ""

#: ../../changelog/migration_10.rst:284
msgid ""
"The :class:`.KeyedTuple` class is used rather than Python's "
"``collections.namedtuple()``, because the latter has a very complex type-"
"creation routine that benchmarks much slower than :class:`.KeyedTuple`. "
"However, when fetching hundreds of thousands of rows, "
"``collections.namedtuple()`` quickly overtakes :class:`.KeyedTuple` which"
" becomes dramatically slower as instance invocation goes up.   What to "
"do? A new type that hedges between the approaches of both.   Benching all"
" three types for \"size\" (number of rows returned) and \"num\" (number "
"of distinct queries), the new \"lightweight keyed tuple\" either "
"outperforms both, or lags very slightly behind the faster object, based "
"on which scenario.  In the \"sweet spot\", where we are both creating a "
"good number of new types as well as fetching a good number of rows, the "
"lightweight object totally smokes both namedtuple and KeyedTuple::"
msgstr ""

#: ../../changelog/migration_10.rst:320
msgid ":ticket:`3176`"
msgstr ""

#: ../../changelog/migration_10.rst:325
msgid "Significant Improvements in Structural Memory Use"
msgstr ""

#: ../../changelog/migration_10.rst:327
msgid ""
"Structural memory use has been improved via much more significant use of "
"``__slots__`` for many internal objects.  This optimization is "
"particularly geared towards the base memory size of large applications "
"that have lots of tables and columns, and reduces memory size for a "
"variety of high-volume objects including event listening internals, "
"comparator objects and parts of the ORM attribute and loader strategy "
"system."
msgstr ""

#: ../../changelog/migration_10.rst:335
msgid ""
"A bench that makes use of heapy measure the startup size of Nova "
"illustrates a difference of about 3.7 fewer megs, or 46%, taken up by "
"SQLAlchemy's objects, associated dictionaries, as well as weakrefs, "
"within a basic import of \"nova.db.sqlalchemy.models\"::"
msgstr ""

#: ../../changelog/migration_10.rst:356
msgid "UPDATE statements are now batched with executemany() in a flush"
msgstr ""

#: ../../changelog/migration_10.rst:358
msgid ""
"UPDATE statements can now be batched within an ORM flush into more "
"performant executemany() call, similarly to how INSERT statements can be "
"batched; this will be invoked within flush based on the following "
"criteria:"
msgstr ""

#: ../../changelog/migration_10.rst:363
msgid ""
"two or more UPDATE statements in sequence involve the identical set of "
"columns to be modified."
msgstr ""

#: ../../changelog/migration_10.rst:366
msgid "The statement has no embedded SQL expressions in the SET clause."
msgstr ""

#: ../../changelog/migration_10.rst:368
msgid ""
"The mapping does not use a :paramref:`~.orm.mapper.version_id_col`, or "
"the backend dialect supports a \"sane\" rowcount for an executemany() "
"operation; most DBAPIs support this correctly now."
msgstr ""

#: ../../changelog/migration_10.rst:378
msgid "Session.get_bind() handles a wider variety of inheritance scenarios"
msgstr ""

#: ../../changelog/migration_10.rst:380
msgid ""
"The :meth:`.Session.get_bind` method is invoked whenever a query or unit "
"of work flush process seeks to locate the database engine that "
"corresponds to a particular class.   The method has been improved to "
"handle a variety of inheritance-oriented scenarios, including:"
msgstr ""

#: ../../changelog/migration_10.rst:385
msgid "Binding to a Mixin or Abstract Class::"
msgstr ""

#: ../../changelog/migration_10.rst:394
msgid "Binding to inherited concrete subclasses individually based on table::"
msgstr ""

#: ../../changelog/migration_10.rst:415
msgid ":ticket:`3035`"
msgstr ""

#: ../../changelog/migration_10.rst:421
msgid "Session.get_bind() will receive the Mapper in all relevant Query cases"
msgstr ""

#: ../../changelog/migration_10.rst:423
msgid ""
"A series of issues were repaired where the :meth:`.Session.get_bind` "
"would not receive the primary :class:`.Mapper` of the :class:`.Query`, "
"even though this mapper was readily available (the primary mapper is the "
"single mapper, or alternatively the first mapper, that is associated with"
" a :class:`.Query` object)."
msgstr ""

#: ../../changelog/migration_10.rst:429
msgid ""
"The :class:`.Mapper` object, when passed to :meth:`.Session.get_bind`, is"
" typically used by sessions that make use of the "
":paramref:`.Session.binds` parameter to associate mappers with a series "
"of engines (although in this use case, things frequently \"worked\" in "
"most cases anyway as the bind would be located via the mapped table "
"object), or more specifically implement a user-defined "
":meth:`.Session.get_bind` method that provies some pattern of selecting "
"engines based on mappers, such as horizontal sharding or a so-called "
"\"routing\" session that routes queries to different backends."
msgstr ""

#: ../../changelog/migration_10.rst:439
msgid "These scenarios include:"
msgstr ""

#: ../../changelog/migration_10.rst:441
msgid ":meth:`.Query.count`::"
msgstr ""

#: ../../changelog/migration_10.rst:445
msgid ""
":meth:`.Query.update` and :meth:`.Query.delete`, both for the "
"UPDATE/DELETE statement as well as for the SELECT used by the \"fetch\" "
"strategy::"
msgstr ""

#: ../../changelog/migration_10.rst:454
msgid "Queries against individual columns::"
msgstr ""

#: ../../changelog/migration_10.rst:458
msgid ""
"SQL functions and other expressions against indirect mappings such as "
":obj:`.column_property`::"
msgstr ""

#: ../../changelog/migration_10.rst:468
msgid ":ticket:`3227` :ticket:`3242` :ticket:`1326`"
msgstr ""

#: ../../changelog/migration_10.rst:473
msgid ".info dictionary improvements"
msgstr ""

#: ../../changelog/migration_10.rst:475
msgid ""
"The :attr:`.InspectionAttr.info` collection is now available on every "
"kind of object that one would retrieve from the "
":attr:`.Mapper.all_orm_descriptors` collection.  This includes "
":class:`.hybrid_property` and :func:`.association_proxy`. However, as "
"these objects are class-bound descriptors, they must be accessed "
"**separately** from the class to which they are attached in order to get "
"at the attribute.  Below this is illustared using the "
":attr:`.Mapper.all_orm_descriptors` namespace::"
msgstr ""

#: ../../changelog/migration_10.rst:493
msgid ""
"It is also available as a constructor argument for all "
":class:`.SchemaItem` objects (e.g. :class:`.ForeignKey`, "
":class:`.UniqueConstraint` etc.) as well as remaining ORM constructs such"
" as :func:`.orm.synonym`."
msgstr ""

#: ../../changelog/migration_10.rst:497
msgid ":ticket:`2971`"
msgstr ""

#: ../../changelog/migration_10.rst:499
msgid ":ticket:`2963`"
msgstr ""

#: ../../changelog/migration_10.rst:504
msgid "ColumnProperty constructs work a lot better with aliases, order_by"
msgstr ""

#: ../../changelog/migration_10.rst:506
msgid ""
"A variety of issues regarding :func:`.column_property` have been fixed, "
"most specifically with regards to the :func:`.aliased` construct as well "
"as the \"order by label\" logic introduced in 0.9 (see "
":ref:`migration_1068`)."
msgstr ""

#: ../../changelog/migration_10.rst:510
msgid "Given a mapping like the following::"
msgstr ""

#: ../../changelog/migration_10.rst:528
msgid ""
"A simple scenario that included \"A.b\" twice would fail to render "
"correctly::"
msgstr ""

#: ../../changelog/migration_10.rst:533
msgid "This would order by the wrong column::"
msgstr ""

#: ../../changelog/migration_10.rst:541
msgid "New output::"
msgstr ""

#: ../../changelog/migration_10.rst:549
msgid ""
"There were also many scenarios where the \"order by\" logic would fail to"
" order by label, for example if the mapping were \"polymorphic\"::"
msgstr ""

#: ../../changelog/migration_10.rst:560
msgid ""
"The order_by would fail to use the label, as it would be anonymized due "
"to the polymorphic loading::"
msgstr ""

#: ../../changelog/migration_10.rst:568
msgid "Now that the order by label tracks the anonymized label, this now works::"
msgstr ""

#: ../../changelog/migration_10.rst:574
msgid ""
"Included in these fixes are a variety of heisenbugs that could corrupt "
"the state of an ``aliased()`` construct such that the labeling logic "
"would again fail; these have also been fixed."
msgstr ""

#: ../../changelog/migration_10.rst:578
msgid ":ticket:`3148` :ticket:`3188`"
msgstr ""

#: ../../changelog/migration_10.rst:581
msgid "New Features and Improvements - Core"
msgstr ""

#: ../../changelog/migration_10.rst:586
msgid ""
"Select/Query LIMIT / OFFSET may be specified as an arbitrary SQL "
"expression"
msgstr ""

#: ../../changelog/migration_10.rst:588
msgid ""
"The :meth:`.Select.limit` and :meth:`.Select.offset` methods now accept "
"any SQL expression, in addition to integer values, as arguments.  The ORM"
" :class:`.Query` object also passes through any expression to the "
"underlying :class:`.Select` object.   Typically this is used to allow a "
"bound parameter to be passed, which can be substituted with a value "
"later::"
msgstr ""

#: ../../changelog/migration_10.rst:597
msgid ""
"Dialects which don't support non-integer LIMIT or OFFSET expressions may "
"continue to not support this behavior; third party dialects may also need"
" modification in order to take advantage of the new behavior.  A dialect "
"which currently uses the ``._limit`` or ``._offset`` attributes will "
"continue to function for those cases where the limit/offset was specified"
" as a simple integer value. However, when a SQL expression is specified, "
"these two attributes will instead raise a :class:`.CompileError` on "
"access.  A third-party dialect which wishes to support the new feature "
"should now call upon the ``._limit_clause`` and ``._offset_clause`` "
"attributes to receive the full SQL expression, rather than the integer "
"value."
msgstr ""

#: ../../changelog/migration_10.rst:611
msgid ""
"The ``use_alter`` flag on ``ForeignKeyConstraint`` is (usually) no longer"
" needed"
msgstr ""

#: ../../changelog/migration_10.rst:613
msgid ""
"The :meth:`.MetaData.create_all` and :meth:`.MetaData.drop_all` methods "
"will now make use of a system that automatically renders an ALTER "
"statement for foreign key constraints that are involved in mutually-"
"dependent cycles between tables, without the need to specify "
":paramref:`.ForeignKeyConstraint.use_alter`.   Additionally, the foreign "
"key constraints no longer need to have a name in order to be created via "
"ALTER; only the DROP operation requires a name.   In the case of a DROP, "
"the feature will ensure that only constraints which have explicit names "
"are actually included as ALTER statements.  In the case of an "
"unresolvable cycle within a DROP, the system emits a succinct and clear "
"error message now if the DROP cannot proceed."
msgstr ""

#: ../../changelog/migration_10.rst:625
msgid ""
"The :paramref:`.ForeignKeyConstraint.use_alter` and "
":paramref:`.ForeignKey.use_alter` flags remain in place, and continue to "
"have the same effect of establishing those constraints for which ALTER is"
" required during a CREATE/DROP scenario."
msgstr ""

#: ../../changelog/migration_10.rst:630
msgid ""
"As of version 1.0.1, special logic takes over in the case of SQLite, "
"which does not support ALTER, in the case that during a DROP, the given "
"tables have an unresolvable cycle; in this case a warning is emitted, and"
" the tables are dropped with **no** ordering, which is usually fine on "
"SQLite unless constraints are enabled. To resolve the warning and proceed"
" with at least a partial ordering on a SQLite database, particularly one "
"where constraints are enabled, re-apply \"use_alter\" flags to those "
":class:`.ForeignKey` and :class:`.ForeignKeyConstraint` objects which "
"should be explicitly omitted from the sort."
msgstr ""

#: ../../changelog/migration_10.rst:642
msgid ":ref:`use_alter` - full description of the new behavior."
msgstr ""

#: ../../changelog/migration_10.rst:644
msgid ":ticket:`3282`"
msgstr ""

#: ../../changelog/migration_10.rst:649
msgid "ResultProxy \"auto close\" is now a \"soft\" close"
msgstr ""

#: ../../changelog/migration_10.rst:651
msgid ""
"For many releases, the :class:`.ResultProxy` object has always been "
"automatically closed out at the point at which all result rows have been "
"fetched.  This was to allow usage of the object without the need to call "
"upon :meth:`.ResultProxy.close` explicitly; as all DBAPI resources had "
"been freed, the object was safe to discard.   However, the object "
"maintained a strict \"closed\" behavior, which meant that any subsequent "
"calls to :meth:`.ResultProxy.fetchone`, :meth:`.ResultProxy.fetchmany` or"
" :meth:`.ResultProxy.fetchall` would now raise a "
":class:`.ResourceClosedError`::"
msgstr ""

#: ../../changelog/migration_10.rst:668
msgid ""
"This behavior is inconsistent vs. what pep-249 states, which is that you "
"can call upon the fetch methods repeatedly even after results are "
"exhausted.  It also interferes with behavior for some implementations of "
"result proxy, such as the :class:`.BufferedColumnResultProxy` used by the"
" cx_oracle dialect for certain datatypes."
msgstr ""

#: ../../changelog/migration_10.rst:674
msgid ""
"To solve this, the \"closed\" state of the :class:`.ResultProxy` has been"
" broken into two states; a \"soft close\" which does the majority of what"
" \"close\" does, in that it releases the DBAPI cursor and in the case of "
"a \"close with result\" object will also release the connection, and a "
"\"closed\" state which is everything included by \"soft close\" as well "
"as establishing the fetch methods as \"closed\".   The "
":meth:`.ResultProxy.close` method is now never called implicitly, only "
"the :meth:`.ResultProxy._soft_close` method which is non-public::"
msgstr ""

#: ../../changelog/migration_10.rst:696
msgid ":ticket:`3330` :ticket:`3329`"
msgstr ""

#: ../../changelog/migration_10.rst:700
#, python-format
msgid ""
"CHECK Constraints now support the ``%(column_0_name)s`` token in naming "
"conventions"
msgstr ""

#: ../../changelog/migration_10.rst:702
#, python-format
msgid ""
"The ``%(column_0_name)s`` will derive from the first column found in the "
"expression of a :class:`.CheckConstraint`::"
msgstr ""

#: ../../changelog/migration_10.rst:715 ../../changelog/migration_10.rst:848
#: ../../changelog/migration_10.rst:1387
msgid "Will render::"
msgstr ""

#: ../../changelog/migration_10.rst:722
msgid ""
"The combination of naming conventions with the constraint produced by a "
":class:`.SchemaType` such as :class:`.Boolean` or :class:`.Enum` will "
"also now make use of all CHECK constraint conventions."
msgstr ""

#: ../../changelog/migration_10.rst:728
msgid ":ref:`naming_check_constraints`"
msgstr ""

#: ../../changelog/migration_10.rst:730
msgid ":ref:`naming_schematypes`"
msgstr ""

#: ../../changelog/migration_10.rst:732
msgid ":ticket:`3299`"
msgstr ""

#: ../../changelog/migration_10.rst:737
msgid ""
"Constraints referring to unattached Columns can auto-attach to the Table "
"when their referred columns are attached"
msgstr ""

#: ../../changelog/migration_10.rst:739
msgid ""
"Since at least version 0.8, a :class:`.Constraint` has had the ability to"
" \"auto-attach\" itself to a :class:`.Table` based on being passed table-"
"attached columns::"
msgstr ""

#: ../../changelog/migration_10.rst:755
msgid ""
"In order to assist with some cases that tend to come up with declarative,"
" this same auto-attachment logic can now function even if the "
":class:`.Column` objects are not yet associated with the :class:`.Table`;"
" additional events are established such that when those :class:`.Column` "
"objects are associated, the :class:`.Constraint` is also added::"
msgstr ""

#: ../../changelog/migration_10.rst:774
msgid ""
"The above feature was a late add as of version 1.0.0b3.  A fix as of "
"version 1.0.4 for :ticket:`3411` ensures that this logic does not occur "
"if the :class:`.Constraint` refers to a mixture of :class:`.Column` "
"objects and string column names; as we do not yet have tracking for the "
"addition of names to a :class:`.Table`::"
msgstr ""

#: ../../changelog/migration_10.rst:795
msgid ""
"Above, the attachment event for column \"a\" to table \"t\" will fire off"
" before column \"b\" is attached (as \"a\" is stated in the "
":class:`.Table` constructor before \"b\"), and the constraint will fail "
"to locate \"b\" if it were to attempt an attachment.  For consistency, if"
" the constraint refers to any string names, the autoattach-on-column-"
"attach logic is skipped."
msgstr ""

#: ../../changelog/migration_10.rst:801
msgid ""
"The original auto-attach logic of course remains in place, if the "
":class:`.Table` already contains all the target :class:`.Column` objects "
"at the time the :class:`.Constraint` is constructed::"
msgstr ""

#: ../../changelog/migration_10.rst:821
msgid ":ticket:`3341` :ticket:`3411`"
msgstr ""

#: ../../changelog/migration_10.rst:829
msgid "INSERT FROM SELECT now includes Python and SQL-expression defaults"
msgstr ""

#: ../../changelog/migration_10.rst:831
msgid ""
":meth:`.Insert.from_select` now includes Python and SQL-expression "
"defaults if otherwise unspecified; the limitation where non-server column"
" defaults aren't included in an INSERT FROM SELECT is now lifted and "
"these expressions are rendered as constants into the SELECT statement::"
msgstr ""

#: ../../changelog/migration_10.rst:853
msgid ""
"The feature can be disabled using "
":paramref:`.Insert.from_select.include_defaults`."
msgstr ""

#: ../../changelog/migration_10.rst:859
msgid "Column server defaults now render literal values"
msgstr ""

#: ../../changelog/migration_10.rst:861
msgid ""
"The \"literal binds\" compiler flag is switched on when a "
":class:`.DefaultClause`, set up by :paramref:`.Column.server_default` is "
"present as a SQL expression to be compiled.  This allows literals "
"embedded in SQL to render correctly, such as::"
msgstr ""

#: ../../changelog/migration_10.rst:880
msgid "Now renders::"
msgstr ""

#: ../../changelog/migration_10.rst:886
msgid ""
"Previously, the literal values ``\"foo\", \"bar\", \"baz\"`` would render"
" as bound parameters, which are useless in DDL."
msgstr ""

#: ../../changelog/migration_10.rst:889
msgid ":ticket:`3087`"
msgstr ""

#: ../../changelog/migration_10.rst:894
msgid "UniqueConstraint is now part of the Table reflection process"
msgstr ""

#: ../../changelog/migration_10.rst:896
msgid ""
"A :class:`.Table` object populated using ``autoload=True`` will now "
"include :class:`.UniqueConstraint` constructs as well as :class:`.Index` "
"constructs.  This logic has a few caveats for PostgreSQL and MySQL:"
msgstr ""

#: ../../changelog/migration_10.rst:902
msgid "PostgreSQL"
msgstr ""

#: ../../changelog/migration_10.rst:904
msgid ""
"PostgreSQL has the behavior such that when a UNIQUE constraint is "
"created, it implicitly creates a UNIQUE INDEX corresponding to that "
"constraint as well. The :meth:`.Inspector.get_indexes` and the "
":meth:`.Inspector.get_unique_constraints` methods will continue to "
"**both** return these entries distinctly, where "
":meth:`.Inspector.get_indexes` now features a token "
"``duplicates_constraint`` within the index entry  indicating the "
"corresponding constraint when detected.   However, when performing full "
"table reflection using  ``Table(..., autoload=True)``, the "
":class:`.Index` construct is detected as being linked to the "
":class:`.UniqueConstraint`, and is **not** present within the "
":attr:`.Table.indexes` collection; only the :class:`.UniqueConstraint` "
"will be present in the :attr:`.Table.constraints` collection.   This "
"deduplication logic works by joining to the ``pg_constraint`` table when "
"querying ``pg_index`` to see if the two constructs are linked."
msgstr ""

#: ../../changelog/migration_10.rst:921
msgid "MySQL"
msgstr ""

#: ../../changelog/migration_10.rst:923
msgid ""
"MySQL does not have separate concepts for a UNIQUE INDEX and a UNIQUE "
"constraint.  While it supports both syntaxes when creating tables and "
"indexes, it does not store them any differently. The "
":meth:`.Inspector.get_indexes` and the "
":meth:`.Inspector.get_unique_constraints` methods will continue to "
"**both** return an entry for a UNIQUE index in MySQL, where "
":meth:`.Inspector.get_unique_constraints` features a new token "
"``duplicates_index`` within the constraint entry indicating that this is "
"a dupe entry corresponding to that index.  However, when performing full "
"table reflection using ``Table(..., autoload=True)``, the "
":class:`.UniqueConstraint` construct is **not** part of the fully "
"reflected :class:`.Table` construct under any circumstances; this "
"construct is always represented by a :class:`.Index` with the "
"``unique=True`` setting present in the :attr:`.Table.indexes` collection."
msgstr ""

#: ../../changelog/migration_10.rst:941
msgid ":ref:`postgresql_index_reflection`"
msgstr ""

#: ../../changelog/migration_10.rst:943
msgid ":ref:`mysql_unique_constraints`"
msgstr ""

#: ../../changelog/migration_10.rst:945
msgid ":ticket:`3184`"
msgstr ""

#: ../../changelog/migration_10.rst:949
msgid "New systems to safely emit parameterized warnings"
msgstr ""

#: ../../changelog/migration_10.rst:951
msgid ""
"For a long time, there has been a restriction that warning messages could"
" not refer to data elements, such that a particular function might emit "
"an infinite number of unique warnings.  The key place this occurs is in "
"the ``Unicode type received non-unicode bind param value`` warning.  "
"Placing the data value in this message would mean that the Python "
"``__warningregistry__`` for that module, or in some cases the Python-"
"global ``warnings.onceregistry``, would grow unbounded, as in most "
"warning scenarios, one of these two collections is populated with every "
"distinct warning message."
msgstr ""

#: ../../changelog/migration_10.rst:960
msgid ""
"The change here is that by using a special ``string`` type that purposely"
" changes how the string is hashed, we can control that a large number of "
"parameterized messages are hashed only on a small set of possible hash "
"values, such that a warning such as ``Unicode type received non-unicode "
"bind param value`` can be tailored to be emitted only a specific number "
"of times; beyond that, the Python warnings registry will begin recording "
"them as duplicates."
msgstr ""

#: ../../changelog/migration_10.rst:968
msgid ""
"To illustrate, the following test script will show only ten warnings "
"being emitted for ten of the parameter sets, out of a total of 1000::"
msgstr ""

#: ../../changelog/migration_10.rst:987
msgid "The format of the warning here is::"
msgstr ""

#: ../../changelog/migration_10.rst:994
msgid ":ticket:`3178`"
msgstr ""

#: ../../changelog/migration_10.rst:997
msgid "Key Behavioral Changes - ORM"
msgstr ""

#: ../../changelog/migration_10.rst:1002
msgid "query.update() now resolves string names into mapped attribute names"
msgstr ""

#: ../../changelog/migration_10.rst:1004
msgid ""
"The documentation for :meth:`.Query.update` states that the given "
"``values`` dictionary is \"a dictionary with attributes names as keys\", "
"implying that these are mapped attribute names.  Unfortunately, the "
"function was designed more in mind to receive attributes and SQL "
"expressions and not as much strings; when strings were passed, these "
"strings would be passed through straight to the core update statement "
"without any resolution as far as how these names are represented on the "
"mapped class, meaning the name would have to match that of a table column"
" exactly, not how an attribute of that name was mapped onto the class."
msgstr ""

#: ../../changelog/migration_10.rst:1015
msgid "The string names are now resolved as attribute names in earnest::"
msgstr ""

#: ../../changelog/migration_10.rst:1023
msgid ""
"Above, the column ``user_name`` is mapped as ``name``.  Previously, a "
"call to :meth:`.Query.update` that was passed strings would have to have "
"been called as follows::"
msgstr ""

#: ../../changelog/migration_10.rst:1029
msgid "The given string is now resolved against the entity::"
msgstr ""

#: ../../changelog/migration_10.rst:1033
msgid ""
"It is typically preferable to use the attribute directly, to avoid any "
"ambiguity::"
msgstr ""

#: ../../changelog/migration_10.rst:1038
msgid ""
"The change also indicates that synonyms and hybrid attributes can be "
"referred to by string name as well::"
msgstr ""

#: ../../changelog/migration_10.rst:1053
msgid ":ticket:`3228`"
msgstr ""

#: ../../changelog/migration_10.rst:1058
msgid "Warnings emitted when comparing objects with None values to relationships"
msgstr ""

#: ../../changelog/migration_10.rst:1060
msgid ""
"This change is new as of 1.0.1.  Some users are performing queries that "
"are essentially of this form::"
msgstr ""

#: ../../changelog/migration_10.rst:1065
msgid ""
"This pattern is not currently supported in SQLAlchemy.  For all versions,"
" it emits SQL resembling::"
msgstr ""

#: ../../changelog/migration_10.rst:1073
msgid ""
"Note above, there is a comparison ``WHERE ? = address.user_id`` where the"
" bound value ``?`` is receiving ``None``, or ``NULL`` in SQL.  **This "
"will always return False in SQL**.  The comparison here would in theory "
"generate SQL as follows::"
msgstr ""

#: ../../changelog/migration_10.rst:1082
msgid ""
"But right now, **it does not**.   Applications which are relying upon the"
" fact that \"NULL = NULL\" produces False in all cases run the risk that "
"someday, SQLAlchemy might fix this issue to generate \"IS NULL\", and the"
" queries will then produce different results.  Therefore with this kind "
"of operation, you will see a warning::"
msgstr ""

#: ../../changelog/migration_10.rst:1092
msgid ""
"Note that this pattern was broken in most cases for release 1.0.0 "
"including all of the betas; a value like ``SYMBOL('NEVER_SET')`` would be"
" generated. This issue has been fixed, but as a result of identifying "
"this pattern, the warning is now there so that we can more safely repair "
"this broken behavior (now captured in :ticket:`3373`) in a future "
"release."
msgstr ""

#: ../../changelog/migration_10.rst:1098
msgid ":ticket:`3371`"
msgstr ""

#: ../../changelog/migration_10.rst:1103
msgid ""
"A \"negated contains or equals\" relationship comparison will use the "
"current value of attributes, not the database value"
msgstr ""

#: ../../changelog/migration_10.rst:1105
msgid ""
"This change is new as of 1.0.1; while we would have preferred for this to"
" be in 1.0.0, it only became apparent as a result of :ticket:`3371`."
msgstr ""

#: ../../changelog/migration_10.rst:1108
msgid "Given a mapping::"
msgstr ""

#: ../../changelog/migration_10.rst:1120
msgid ""
"Given ``A``, with primary key of 7, but which we changed to be 10 without"
" flushing::"
msgstr ""

#: ../../changelog/migration_10.rst:1130
msgid ""
"A query against a many-to-one relationship with this object as the target"
" will use the value 10 in the bound parameters::"
msgstr ""

#: ../../changelog/migration_10.rst:1135
msgid "Produces::"
msgstr ""

#: ../../changelog/migration_10.rst:1142
msgid ""
"However, before this change, the negation of this criteria would **not** "
"use 10, it would use 7, unless the object were flushed first::"
msgstr ""

#: ../../changelog/migration_10.rst:1147
msgid "Produces (in 0.9 and all versions prior to 1.0.1)::"
msgstr ""

#: ../../changelog/migration_10.rst:1154
msgid "For a transient object, it would produce a broken query::"
msgstr ""

#: ../../changelog/migration_10.rst:1161
msgid ""
"This inconsistency has been repaired, and in all queries the current "
"attribute value, in this example ``10``, will now be used."
msgstr ""

#: ../../changelog/migration_10.rst:1164
msgid ":ticket:`3374`"
msgstr ""

#: ../../changelog/migration_10.rst:1169
msgid ""
"Changes to attribute events and other operations regarding attributes "
"that have no pre-existing value"
msgstr ""

#: ../../changelog/migration_10.rst:1171
msgid ""
"In this change, the default return value of ``None`` when accessing an "
"object is now returned dynamically on each access, rather than implicitly"
" setting the attribute's state with a special \"set\" operation when it "
"is first accessed. The visible result of this change is that "
"``obj.__dict__`` is not implicitly modified on get, and there are also "
"some minor behavioral changes for :func:`.attributes.get_history` and "
"related functions."
msgstr ""

#: ../../changelog/migration_10.rst:1178
msgid "Given an object with no state::"
msgstr ""

#: ../../changelog/migration_10.rst:1182
msgid ""
"It has always been SQLAlchemy's behavior such that if we access a scalar "
"or many-to-one attribute that was never set, it is returned as ``None``::"
msgstr ""

#: ../../changelog/migration_10.rst:1188
msgid ""
"This value of ``None`` is in fact now part of the state of ``obj``, and "
"is not unlike as though we had set the attribute explicitly, e.g. "
"``obj.someattr = None``.  However, the \"set on get\" here would behave "
"differently as far as history and events.   It would not emit any "
"attribute event, and additionally if we view history, we see this::"
msgstr ""

#: ../../changelog/migration_10.rst:1197
msgid ""
"That is, it's as though the attribute were always ``None`` and were never"
" changed.  This is explicitly different from if we had set the attribute "
"first instead::"
msgstr ""

#: ../../changelog/migration_10.rst:1206
msgid ""
"The above means that the behavior of our \"set\" operation can be "
"corrupted by the fact that the value was accessed via \"get\" earlier.  "
"In 1.0, this inconsistency has been resolved, by no longer actually "
"setting anything when the default \"getter\" is used."
msgstr ""

#: ../../changelog/migration_10.rst:1220
msgid ""
"The reason the above behavior hasn't had much impact is because the "
"INSERT statement in relational databases considers a missing value to be "
"the same as NULL in most cases.   Whether SQLAlchemy received a history "
"event for a particular attribute set to None or not would usually not "
"matter; as the difference between sending None/NULL or not wouldn't have "
"an impact. However, as :ticket:`3060` (described here in "
":ref:`migration_3060`) illustrates, there are some seldom edge cases "
"where we do in fact want to positively have ``None`` set.  Also, allowing"
" the attribute event here means it's now possible to create \"default "
"value\" functions for ORM mapped attributes."
msgstr ""

#: ../../changelog/migration_10.rst:1231
msgid ""
"As part of this change, the generation of the implicit \"None\" is now "
"disabled for other situations where this used to occur; this includes "
"when an attribute set operation on a many-to-one is received; previously,"
" the \"old\" value would be \"None\" if it had been not set otherwise; it"
" now will send the value :data:`.orm.attributes.NEVER_SET`, which is a "
"value that may be sent to an attribute listener now.   This symbol may "
"also be received when calling on mapper utility functions such as "
":meth:`.Mapper.primary_key_from_instance`; if the primary key attributes "
"have no setting at all, whereas the value would be ``None`` before, it "
"will now be the :data:`.orm.attributes.NEVER_SET` symbol, and no change "
"to the object's state occurs."
msgstr ""

#: ../../changelog/migration_10.rst:1242
msgid ":ticket:`3061`"
msgstr ""

#: ../../changelog/migration_10.rst:1247
msgid ""
"Priority of attribute changes on relationship-bound attributes vs. FK-"
"bound may appear to change"
msgstr ""

#: ../../changelog/migration_10.rst:1249
msgid ""
"As a side effect of :ticket:`3060`, setting a relationship-bound "
"attribute to ``None`` is now a tracked history event which refers to the "
"intention of persisting ``None`` to that attribute.   As it has always "
"been the case that setting a relationship-bound attribute will trump "
"direct assignment to the foreign key attributes, a change in behavior can"
" be seen here when assigning None. Given a mapping::"
msgstr ""

#: ../../changelog/migration_10.rst:1268
msgid ""
"In 1.0, the relationship-bound attribute takes precedence over the FK-"
"bound attribute in all cases, whether or not the value we assign is a "
"reference to an ``A`` object or is ``None``. In 0.9, the behavior is "
"inconsistent and only takes effect if a value is assigned; the None is "
"not considered::"
msgstr ""

#: ../../changelog/migration_10.rst:1294
msgid ":ticket:`3060`"
msgstr ""

#: ../../changelog/migration_10.rst:1299
msgid "session.expunge() will fully detach an object that's been deleted"
msgstr ""

#: ../../changelog/migration_10.rst:1301
msgid ""
"The behavior of :meth:`.Session.expunge` had a bug that caused an "
"inconsistency in behavior regarding deleted objects.  The "
":func:`.object_session` function as well as the "
":attr:`.InstanceState.session` attribute would still report object as "
"belonging to the :class:`.Session` subsequent to the expunge::"
msgstr ""

#: ../../changelog/migration_10.rst:1320
msgid ""
"Note that it is normal for ``u1 not in sess`` to be True while "
"``inspect(u1).session`` still refers to the session, while the "
"transaction is ongoing subsequent to the delete operation and "
":meth:`.Session.expunge` has not been called; the full detachment "
"normally completes once the transaction is committed.  This issue would "
"also impact functions that rely on :meth:`.Session.expunge` such as "
":func:`.make_transient`."
msgstr ""

#: ../../changelog/migration_10.rst:1327
msgid ":ticket:`3139`"
msgstr ""

#: ../../changelog/migration_10.rst:1332
msgid "Joined/Subquery eager loading explicitly disallowed with yield_per"
msgstr ""

#: ../../changelog/migration_10.rst:1334
msgid ""
"In order to make the :meth:`.Query.yield_per` method easier to use, an "
"exception is raised if any subquery eager loaders, or joined eager "
"loaders that would use collections, are to take effect when yield_per is "
"used, as these are currently not compatible with yield-per (subquery "
"loading could be in theory, however). When this error is raised, the "
":func:`.lazyload` option can be sent with an asterisk::"
msgstr ""

#: ../../changelog/migration_10.rst:1344
msgid "or use :meth:`.Query.enable_eagerloads`::"
msgstr ""

#: ../../changelog/migration_10.rst:1348
msgid ""
"The :func:`.lazyload` option has the advantage that additional many-to-"
"one joined loader options can still be used::"
msgstr ""

#: ../../changelog/migration_10.rst:1357
msgid "Changes and fixes in handling of duplicate join targets"
msgstr ""

#: ../../changelog/migration_10.rst:1359
msgid ""
"Changes here encompass bugs where an unexpected and inconsistent behavior"
" would occur in some scenarios when joining to an entity twice, or to "
"multple single-table entities against the same table, without using a "
"relationship-based ON clause, as well as when joining multiple times to "
"the same target relationship."
msgstr ""

#: ../../changelog/migration_10.rst:1365
msgid "Starting with a mapping as::"
msgstr ""

#: ../../changelog/migration_10.rst:1383
msgid "A query that joins to ``A.bs`` twice::"
msgstr ""

#: ../../changelog/migration_10.rst:1392
msgid ""
"The query deduplicates the redundant ``A.bs`` because it is attempting to"
" support a case like the following::"
msgstr ""

#: ../../changelog/migration_10.rst:1399
msgid ""
"That is, the ``A.bs`` is part of a \"path\".  As part of :ticket:`3367`, "
"arriving at the same endpoint twice without it being part of a larger "
"path will now emit a warning::"
msgstr ""

#: ../../changelog/migration_10.rst:1405
msgid ""
"The bigger change involves when joining to an entity without using a "
"relationship-bound path.  If we join to ``B`` twice::"
msgstr ""

#: ../../changelog/migration_10.rst:1410
msgid "In 0.9, this would render as follows::"
msgstr ""

#: ../../changelog/migration_10.rst:1415
msgid ""
"This is problematic since the aliasing is implicit and in the case of "
"different ON clauses can lead to unpredictable results."
msgstr ""

#: ../../changelog/migration_10.rst:1418
msgid "In 1.0, no automatic aliasing is applied and we get::"
msgstr ""

#: ../../changelog/migration_10.rst:1423
msgid ""
"This will raise an error from the database.  While it might be nice if "
"the \"duplicate join target\" acted identically if we joined both from "
"redundant relationships vs. redundant non-relationship based targets, for"
" now we are only changing the behavior in the more serious case where "
"implicit aliasing would have occurred previously, and only emitting a "
"warning in the relationship case.  Ultimately, joining to the same thing "
"twice without any aliasing to disambiguate should raise an error in all "
"cases."
msgstr ""

#: ../../changelog/migration_10.rst:1431
msgid ""
"The change also has an impact on single-table inheritance targets.  Using"
" a mapping as follows::"
msgstr ""

#: ../../changelog/migration_10.rst:1472
msgid ""
"The two queries at the bottom are equivalent, and should both render the "
"identical SQL::"
msgstr ""

#: ../../changelog/migration_10.rst:1479
msgid ""
"The above SQL is invalid, as it renders \"a\" within the FROM list twice."
" However, the implicit aliasing bug would occur with the second query "
"only and render this instead::"
msgstr ""

#: ../../changelog/migration_10.rst:1488
msgid ""
"Where above, the second join to \"a\" is aliased.  While this seems "
"convenient, it's not how single-inheritance queries work in general and "
"is misleading and inconsistent."
msgstr ""

#: ../../changelog/migration_10.rst:1492
msgid ""
"The net effect is that applications which were relying on this bug will "
"now have an error raised by the database.   The solution is to use the "
"expected form.  When referring to multiple subclasses of a single-"
"inheritance entity in a query, you must manually use aliases to "
"disambiguate the table, as all the subclasses normally refer to the same "
"table::"
msgstr ""

#: ../../changelog/migration_10.rst:1502
msgid ":ticket:`3233` :ticket:`3367`"
msgstr ""

#: ../../changelog/migration_10.rst:1507
msgid "Deferred Columns No Longer Implicitly Undefer"
msgstr ""

#: ../../changelog/migration_10.rst:1509
msgid ""
"Mapped attributes marked as deferred without explicit undeferral will now"
" remain \"deferred\" even if their column is otherwise present in the "
"result set in some way.   This is a performance enhancement in that an "
"ORM load no longer spends time searching for each deferred column when "
"the result set is obtained.  However, for an application that has been "
"relying upon this, an explicit :func:`.undefer` or similar option should "
"now be used, in order to prevent a SELECT from being emitted when the "
"attribute is accessed."
msgstr ""

#: ../../changelog/migration_10.rst:1522
msgid "Deprecated ORM Event Hooks Removed"
msgstr ""

#: ../../changelog/migration_10.rst:1524
msgid ""
"The following ORM event hooks, some of which have been deprecated since "
"0.5, have been removed:   ``translate_row``, ``populate_instance``, "
"``append_result``, ``create_instance``.  The use cases for these hooks "
"originated in the very early 0.1 / 0.2 series of SQLAlchemy and have long"
" since been unnecessary.  In particular, the hooks were largely unusable "
"as the behavioral contracts within these events was strongly linked to "
"the surrounding internals, such as how an instance needs to be created "
"and initialized as well as how columns are located within an ORM-"
"generated row.   The removal of these hooks greatly simplifies the "
"mechanics of ORM object loading."
msgstr ""

#: ../../changelog/migration_10.rst:1538
msgid "API Change for new Bundle feature when custom row loaders are used"
msgstr ""

#: ../../changelog/migration_10.rst:1540
msgid ""
"The new :class:`.Bundle` object of 0.9 has a small change in API, when "
"the ``create_row_processor()`` method is overridden on a custom class. "
"Previously, the sample code looked like::"
msgstr ""

#: ../../changelog/migration_10.rst:1555
msgid "The unused ``result`` member is now removed::"
msgstr ""

#: ../../changelog/migration_10.rst:1570
msgid ":ref:`bundles`"
msgstr ""

#: ../../changelog/migration_10.rst:1575
msgid ""
"Right inner join nesting now the default for joinedload with "
"innerjoin=True"
msgstr ""

#: ../../changelog/migration_10.rst:1577
msgid ""
"The behavior of :paramref:`.joinedload.innerjoin` as well as "
":paramref:`.relationship.innerjoin` is now to use \"nested\" inner joins,"
" that is, right-nested, as the default behavior when an inner join joined"
" eager load is chained to an outer join eager load.  In order to get the "
"old behavior of chaining all joined eager loads as outer join when an "
"outer join is present, use ``innerjoin=\"unnested\"``."
msgstr ""

#: ../../changelog/migration_10.rst:1584
msgid ""
"As introduced in :ref:`feature_2976` from version 0.9, the behavior of "
"``innerjoin=\"nested\"`` is that an inner join eager load chained to an "
"outer join eager load will use a right-nested join.  ``\"nested\"`` is "
"now implied when using ``innerjoin=True``::"
msgstr ""

#: ../../changelog/migration_10.rst:1592
msgid "With the new default, this will render the FROM clause in the form::"
msgstr ""

#: ../../changelog/migration_10.rst:1596
msgid ""
"That is, using a right-nested join for the INNER join so that the full "
"result of ``users`` can be returned.   The use of an INNER join is more "
"efficient than using an OUTER join, and allows the "
":paramref:`.joinedload.innerjoin` optimization parameter to take effect "
"in all cases."
msgstr ""

#: ../../changelog/migration_10.rst:1601
msgid "To get the older behavior, use ``innerjoin=\"unnested\"``::"
msgstr ""

#: ../../changelog/migration_10.rst:1606
msgid ""
"This will avoid right-nested joins and chain the joins together using all"
" OUTER joins despite the innerjoin directive::"
msgstr ""

#: ../../changelog/migration_10.rst:1611
msgid ""
"As noted in the 0.9 notes, the only database backend that has difficulty "
"with right-nested joins is SQLite; SQLAlchemy as of 0.9 converts a right-"
"nested join into a subquery as a join target on SQLite."
msgstr ""

#: ../../changelog/migration_10.rst:1617
msgid ":ref:`feature_2976` - description of the feature as introduced in 0.9.4."
msgstr ""

#: ../../changelog/migration_10.rst:1619
msgid ":ticket:`3008`"
msgstr ""

#: ../../changelog/migration_10.rst:1624
msgid "Subqueries no longer applied to uselist=False joined eager loads"
msgstr ""

#: ../../changelog/migration_10.rst:1626
msgid "Given a joined eager load like the following::"
msgstr ""

#: ../../changelog/migration_10.rst:1642
msgid ""
"SQLAlchemy considers the relationship ``A.b`` to be a \"one to many, "
"loaded as a single value\", which is essentially a \"one to one\" "
"relationship.  However, joined eager loading has always treated the above"
" as a situation where the main query needs to be inside a subquery, as "
"would normally be needed for a collection of B objects where the main "
"query has a LIMIT applied::"
msgstr ""

#: ../../changelog/migration_10.rst:1654
msgid ""
"However, since the relationship of the inner query to the outer one is "
"that at most only one row is shared in the case of ``uselist=False`` (in "
"the same way as a many-to-one), the \"subquery\" used with LIMIT + joined"
" eager loading is now dropped in this case::"
msgstr ""

#: ../../changelog/migration_10.rst:1663
msgid ""
"In the case that the LEFT OUTER JOIN returns more than one row, the ORM "
"has always emitted a warning here and ignored additional results for "
"``uselist=False``, so the results in that error situation should not "
"change."
msgstr ""

#: ../../changelog/migration_10.rst:1667
msgid ":ticket:`3249`"
msgstr ""

#: ../../changelog/migration_10.rst:1671
msgid ""
"query.update() / query.delete() raises if used with join(), "
"select_from(), from_self()"
msgstr ""

#: ../../changelog/migration_10.rst:1673
msgid ""
"A warning is emitted in SQLAlchemy 0.9.10 (not yet released as of June 9,"
" 2015) when the :meth:`.Query.update` or :meth:`.Query.delete` methods "
"are invoked against a query which has also called upon "
":meth:`.Query.join`, :meth:`.Query.outerjoin`, :meth:`.Query.select_from`"
" or :meth:`.Query.from_self`.  These are unsupported use cases which "
"silently fail in the 0.9 series up until 0.9.10 where it emits a warning."
"  In 1.0, these cases raise an exception."
msgstr ""

#: ../../changelog/migration_10.rst:1681
msgid ":ticket:`3349`"
msgstr ""

#: ../../changelog/migration_10.rst:1685
msgid ""
"query.update() with ``synchronize_session='evaluate'`` raises on multi-"
"table update"
msgstr ""

#: ../../changelog/migration_10.rst:1687
msgid ""
"The \"evaluator\" for :meth:`.Query.update` won't work with multi-table "
"updates, and needs to be set to ``synchronize_session=False`` or "
"``synchronize_session='fetch'`` when multiple tables are present. The new"
" behavior is that an explicit exception is now raised, with a message to "
"change the synchronize setting. This is upgraded from a warning emitted "
"as of 0.9.7."
msgstr ""

#: ../../changelog/migration_10.rst:1694
msgid ":ticket:`3117`"
msgstr ""

#: ../../changelog/migration_10.rst:1697
msgid "Resurrect Event has been Removed"
msgstr ""

#: ../../changelog/migration_10.rst:1699
msgid ""
"The \"resurrect\" ORM event has been removed entirely.  This event ceased"
" to have any function since version 0.8 removed the older \"mutable\" "
"system from the unit of work."
msgstr ""

#: ../../changelog/migration_10.rst:1707
msgid ""
"Change to single-table-inheritance criteria when using from_self(), "
"count()"
msgstr ""

#: ../../changelog/migration_10.rst:1709
msgid "Given a single-table inheritance mapping, such as::"
msgstr ""

#: ../../changelog/migration_10.rst:1717
msgid ""
"Using :meth:`.Query.from_self` or :meth:`.Query.count` against a subclass"
" would produce a subquery, but then add the \"WHERE\" criteria for "
"subtypes to the outside::"
msgstr ""

#: ../../changelog/migration_10.rst:1723
msgid "rendering::"
msgstr ""

#: ../../changelog/migration_10.rst:1732
msgid ""
"The issue with this is that if the inner query does not specify all "
"columns, then we can't add the WHERE clause on the outside (it actually "
"tries, and produces a bad query).  This decision apparently goes way back"
" to 0.6.5 with the note \"may need to make more adjustments to this\".   "
"Well, those adjustments have arrived!  So now the above query will "
"render::"
msgstr ""

#: ../../changelog/migration_10.rst:1746
msgid "So that queries that don't include \"type\" will still work!::"
msgstr ""

#: ../../changelog/migration_10.rst:1750
msgid "Renders::"
msgstr ""

#: ../../changelog/migration_10.rst:1758
msgid ":ticket:`3177`"
msgstr ""

#: ../../changelog/migration_10.rst:1765
msgid "single-table-inheritance criteria added to all ON clauses unconditionally"
msgstr ""

#: ../../changelog/migration_10.rst:1767
msgid ""
"When joining to a single-table inheritance subclass target, the ORM "
"always adds the \"single table criteria\" when joining on a relationship."
"  Given a mapping as::"
msgstr ""

#: ../../changelog/migration_10.rst:1788
msgid ""
"It's been the behavior for quite some time that a JOIN on the "
"relationship will render a \"single inheritance\" clause for the type::"
msgstr ""

#: ../../changelog/migration_10.rst:1793
msgid "SQL output::"
msgstr ""

#: ../../changelog/migration_10.rst:1798
msgid ""
"Above, because we joined to a subclass ``FooWidget``, :meth:`.Query.join`"
" knew to add the ``AND widget.type IN ('foo')`` criteria to the ON "
"clause."
msgstr ""

#: ../../changelog/migration_10.rst:1801
msgid ""
"The change here is that the ``AND widget.type IN()`` criteria is now "
"appended to *any* ON clause, not just those generated from a "
"relationship, including one that is explicitly stated::"
msgstr ""

#: ../../changelog/migration_10.rst:1809
msgid "As well as the \"implicit\" join when no ON clause of any kind is stated::"
msgstr ""

#: ../../changelog/migration_10.rst:1815
msgid ""
"Previously, the ON clause for these would not include the single-"
"inheritance criteria.  Applications that are already adding this criteria"
" to work around this will want to remove its explicit use, though it "
"should continue to work fine if the criteria happens to be rendered twice"
" in the meantime."
msgstr ""

#: ../../changelog/migration_10.rst:1822
msgid ":ref:`bug_3233`"
msgstr ""

#: ../../changelog/migration_10.rst:1824
msgid ":ticket:`3222`"
msgstr ""

#: ../../changelog/migration_10.rst:1827
msgid "Key Behavioral Changes - Core"
msgstr ""

#: ../../changelog/migration_10.rst:1832
msgid "Warnings emitted when coercing full SQL fragments into text()"
msgstr ""

#: ../../changelog/migration_10.rst:1834
msgid ""
"Since SQLAlchemy's inception, there has always been an emphasis on not "
"getting in the way of the usage of plain text.   The Core and ORM "
"expression systems were intended to allow any number of points at which "
"the user can just use plain text SQL expressions, not just in the sense "
"that you can send a full SQL string to :meth:`.Connection.execute`, but "
"that you can send strings with SQL expressions into many functions, such "
"as :meth:`.Select.where`, :meth:`.Query.filter`, and "
":meth:`.Select.order_by`."
msgstr ""

#: ../../changelog/migration_10.rst:1842
msgid ""
"Note that by \"SQL expressions\" we mean a **full fragment of a SQL "
"string**, such as::"
msgstr ""

#: ../../changelog/migration_10.rst:1848
msgid ""
"and we are **not talking about string arguments**, that is, the normal "
"behavior of passing string values that become parameterized::"
msgstr ""

#: ../../changelog/migration_10.rst:1855
msgid ""
"The Core tutorial has long featured an example of the use of this "
"technique, using a :func:`.select` construct where virtually all "
"components of it are specified as straight strings.  However, despite "
"this long-standing behavior and example, users are apparently surprised "
"that this behavior exists, and when asking around the community, I was "
"unable to find any user that was in fact *not* surprised that you can "
"send a full string into a method like :meth:`.Query.filter`."
msgstr ""

#: ../../changelog/migration_10.rst:1863
msgid ""
"So the change here is to encourage the user to qualify textual strings "
"when composing SQL that is partially or fully composed from textual "
"fragments. When composing a select as below::"
msgstr ""

#: ../../changelog/migration_10.rst:1869
msgid ""
"The statement is built up normally, with all the same coercions as "
"before. However, one will see the following warnings emitted::"
msgstr ""

#: ../../changelog/migration_10.rst:1887
msgid ""
"These warnings attempt to show exactly where the issue is by displaying "
"the parameters as well as where the string was received. The warnings "
"make use of the :ref:`feature_3178` so that parameterized warnings can be"
" emitted safely without running out of memory, and as always, if one "
"wishes the warnings to be exceptions, the `Python Warnings Filter "
"<https://docs.python.org/2/library/warnings.html>`_ should be used::"
msgstr ""

#: ../../changelog/migration_10.rst:1898
msgid ""
"Given the above warnings, our statement works just fine, but to get rid "
"of the warnings we would rewrite our statement as follows::"
msgstr ""

#: ../../changelog/migration_10.rst:1907
msgid ""
"and as the warnings suggest, we can give our statement more specificity "
"about the text if we use :func:`.column` and :func:`.table`::"
msgstr ""

#: ../../changelog/migration_10.rst:1915
msgid ""
"Where note also that :func:`.table` and :func:`.column` can now be "
"imported from \"sqlalchemy\" without the \"sql\" part."
msgstr ""

#: ../../changelog/migration_10.rst:1918
msgid ""
"The behavior here applies to :func:`.select` as well as to key methods on"
" :class:`.Query`, including :meth:`.Query.filter`, "
":meth:`.Query.from_statement` and :meth:`.Query.having`."
msgstr ""

#: ../../changelog/migration_10.rst:1923
msgid "ORDER BY and GROUP BY are special cases"
msgstr ""

#: ../../changelog/migration_10.rst:1925
msgid ""
"There is one case where usage of a string has special meaning, and as "
"part of this change we have enhanced its functionality.  When we have a "
":func:`.select` or :class:`.Query` that refers to some column name or "
"named label, we might want to GROUP BY and/or ORDER BY known columns or "
"labels::"
msgstr ""

#: ../../changelog/migration_10.rst:1935
msgid ""
"In the above statement we expect to see \"ORDER BY id_count\", as opposed"
" to a re-statement of the function.   The string argument given is "
"actively matched to an entry in the columns clause during compilation, so"
" the above statement would produce as we expect, without warnings (though"
" note that the ``\"name\"`` expression has been resolved to "
"``users.name``!)::"
msgstr ""

#: ../../changelog/migration_10.rst:1944
msgid ""
"However, if we refer to a name that cannot be located, then we get the "
"warning again, as below::"
msgstr ""

#: ../../changelog/migration_10.rst:1952
msgid "The output does what we say, but again it warns us::"
msgstr ""

#: ../../changelog/migration_10.rst:1960
msgid ""
"The above behavior applies to all those places where we might want to "
"refer to a so-called \"label reference\"; ORDER BY and GROUP BY, but also"
" within an OVER clause as well as a DISTINCT ON clause that refers to "
"columns (e.g. the PostgreSQL syntax)."
msgstr ""

#: ../../changelog/migration_10.rst:1965
msgid ""
"We can still specify any arbitrary expression for ORDER BY or others "
"using :func:`.text`::"
msgstr ""

#: ../../changelog/migration_10.rst:1970
msgid ""
"The upshot of the whole change is that SQLAlchemy now would like us to "
"tell it when a string is sent that this string is explicitly a "
":func:`.text` construct, or a column, table, etc., and if we use it as a "
"label name in an order by, group by, or other expression, SQLAlchemy "
"expects that the string resolves to something known, else it should again"
" be qualified with :func:`.text` or similar."
msgstr ""

#: ../../changelog/migration_10.rst:1977
msgid ":ticket:`2992`"
msgstr ""

#: ../../changelog/migration_10.rst:1982
msgid ""
"Python-side defaults invoked for each row invidually when using a "
"multivalued insert"
msgstr ""

#: ../../changelog/migration_10.rst:1984
msgid ""
"Support for Python-side column defaults when using the multi-valued "
"version of :meth:`.Insert.values` were essentially not implemented, and "
"would only work \"by accident\" in specific situations, when the dialect "
"in use was using a non-positional (e.g. named) style of bound parameter, "
"and when it was not necessary that a Python-side callable be invoked for "
"each row."
msgstr ""

#: ../../changelog/migration_10.rst:1991
msgid ""
"The feature has been overhauled so that it works more similarly to that "
"of an \"executemany\" style of invocation::"
msgstr ""

#: ../../changelog/migration_10.rst:2009
msgid ""
"The above example will invoke ``next(counter)`` for each row individually"
" as would be expected::"
msgstr ""

#: ../../changelog/migration_10.rst:2015
msgid ""
"Previously, a positional dialect would fail as a bind would not be "
"generated for additional positions::"
msgstr ""

#: ../../changelog/migration_10.rst:2023
msgid ""
"And with a \"named\" dialect, the same value for \"id\" would be re-used "
"in each row (hence this change is backwards-incompatible with a system "
"that relied on this)::"
msgstr ""

#: ../../changelog/migration_10.rst:2030
msgid ""
"The system will also refuse to invoke a \"server side\" default as "
"inline-rendered SQL, since it cannot be guaranteed that a server side "
"default is compatible with this.  If the VALUES clause renders for a "
"specific column, then a Python-side value is required; if an omitted "
"value only refers to a server-side default, an exception is raised::"
msgstr ""

#: ../../changelog/migration_10.rst:2048
msgid "will raise::"
msgstr ""

#: ../../changelog/migration_10.rst:2054
msgid ""
"Previously, the value \"d1\" would be copied into that of the third row "
"(but again, only with named format!)::"
msgstr ""

#: ../../changelog/migration_10.rst:2060
msgid ":ticket:`3288`"
msgstr ""

#: ../../changelog/migration_10.rst:2065
msgid ""
"Event listeners can not be added or removed from within that event's "
"runner"
msgstr ""

#: ../../changelog/migration_10.rst:2067
msgid ""
"Removal of an event listener from inside that same event itself would "
"modify  the elements of a list during iteration, which would cause still-"
"attached event listeners to silently fail to fire.    To prevent this "
"while still maintaining performance, the lists have been replaced with "
"``collections.deque()``, which does not allow any additions or removals "
"during iteration, and instead raises ``RuntimeError``."
msgstr ""

#: ../../changelog/migration_10.rst:2074
msgid ":ticket:`3163`"
msgstr ""

#: ../../changelog/migration_10.rst:2079
msgid "The INSERT...FROM SELECT construct now implies ``inline=True``"
msgstr ""

#: ../../changelog/migration_10.rst:2081
msgid ""
"Using :meth:`.Insert.from_select` now implies ``inline=True`` on "
":func:`.insert`.  This helps to fix a bug where an INSERT...FROM SELECT "
"construct would inadvertently be compiled as \"implicit returning\" on "
"supporting backends, which would cause breakage in the case of an INSERT "
"that inserts zero rows (as implicit returning expects a row), as well as "
"arbitrary return data in the case of an INSERT that inserts multiple rows"
" (e.g. only the first row of many). A similar change is also applied to "
"an INSERT..VALUES with multiple parameter sets; implicit RETURNING will "
"no longer emit for this statement either.  As both of these constructs "
"deal with varible numbers of rows, the "
":attr:`.ResultProxy.inserted_primary_key` accessor does not apply.   "
"Previously, there was a documentation note that one may prefer "
"``inline=True`` with INSERT..FROM SELECT as some databases don't support "
"returning and therefore can't do \"implicit\" returning, but there's no "
"reason an INSERT...FROM SELECT needs implicit returning in any case.   "
"Regular explicit :meth:`.Insert.returning` should be used to return "
"variable numbers of result rows if inserted data is needed."
msgstr ""

#: ../../changelog/migration_10.rst:2102
msgid ":ticket:`3169`"
msgstr ""

#: ../../changelog/migration_10.rst:2107
msgid "``autoload_with`` now implies ``autoload=True``"
msgstr ""

#: ../../changelog/migration_10.rst:2109
msgid ""
"A :class:`.Table` can be set up for reflection by passing "
":paramref:`.Table.autoload_with` alone::"
msgstr ""

#: ../../changelog/migration_10.rst:2114
msgid ":ticket:`3027`"
msgstr ""

#: ../../changelog/migration_10.rst:2119
msgid "DBAPI exception wrapping and handle_error() event improvements"
msgstr ""

#: ../../changelog/migration_10.rst:2121
msgid ""
"SQLAlchemy's wrapping of DBAPI exceptions was not taking place in the "
"case where a :class:`.Connection` object was invalidated, and then tried "
"to reconnect and encountered an error; this has been resolved."
msgstr ""

#: ../../changelog/migration_10.rst:2125
msgid ""
"Additionally, the recently added :meth:`.ConnectionEvents.handle_error` "
"event is now invoked for errors that occur upon initial connect, upon "
"reconnect, and when :func:`.create_engine` is used given a custom "
"connection function via :paramref:`.create_engine.creator`."
msgstr ""

#: ../../changelog/migration_10.rst:2130
msgid ""
"The :class:`.ExceptionContext` object has a new datamember "
":attr:`.ExceptionContext.engine` that will always refer to the "
":class:`.Engine` in use, in those cases when the :class:`.Connection` "
"object is not available (e.g. on initial connect)."
msgstr ""

#: ../../changelog/migration_10.rst:2136
msgid ":ticket:`3266`"
msgstr ""

#: ../../changelog/migration_10.rst:2141
msgid "ForeignKeyConstraint.columns is now a ColumnCollection"
msgstr ""

#: ../../changelog/migration_10.rst:2143
msgid ""
":attr:`.ForeignKeyConstraint.columns` was previously a plain list "
"containing either strings or :class:`.Column` objects, depending on how "
"the :class:`.ForeignKeyConstraint` was constructed and whether it was "
"associated with a table.  The collection is now a "
":class:`.ColumnCollection`, and is only initialized after the "
":class:`.ForeignKeyConstraint` is associated with a :class:`.Table`.  A "
"new accessor :attr:`.ForeignKeyConstraint.column_keys` is added to "
"unconditionally return string keys for the local set of columns "
"regardless of how the object was constructed or its current state."
msgstr ""

#: ../../changelog/migration_10.rst:2158
msgid "MetaData.sorted_tables accessor is \"deterministic\""
msgstr ""

#: ../../changelog/migration_10.rst:2160
msgid ""
"The sorting of tables resulting from the :attr:`.MetaData.sorted_tables` "
"accessor is \"deterministic\"; the ordering should be the same in all "
"cases regardless of Python hashing.   This is done by first sorting the "
"tables by name before passing them to the topological algorithm, which "
"maintains that ordering as it iterates."
msgstr ""

#: ../../changelog/migration_10.rst:2166
msgid ""
"Note that this change does **not** yet apply to the ordering applied when"
" emitting :meth:`.MetaData.create_all` or :meth:`.MetaData.drop_all`."
msgstr ""

#: ../../changelog/migration_10.rst:2169
msgid ":ticket:`3084`"
msgstr ""

#: ../../changelog/migration_10.rst:2174
msgid "null(), false() and true() constants are no longer singletons"
msgstr ""

#: ../../changelog/migration_10.rst:2176
msgid ""
"These three constants were changed to return a \"singleton\" value in "
"0.9; unfortunately, that would lead to a query like the following to not "
"render as expected::"
msgstr ""

#: ../../changelog/migration_10.rst:2182
msgid ""
"rendering only ``SELECT NULL AS anon_1``, because the two :func:`.null` "
"constructs would come out as the same  ``NULL`` object, and SQLAlchemy's "
"Core model is based on object identity in order to determine lexical "
"significance.    The change in 0.9 had no importance other than the "
"desire to save on object overhead; in general, an unnamed construct needs"
" to stay lexically unique so that it gets labeled uniquely."
msgstr ""

#: ../../changelog/migration_10.rst:2190
msgid ":ticket:`3170`"
msgstr ""

#: ../../changelog/migration_10.rst:2195
msgid ""
"SQLite/Oracle have distinct methods for temporary table/view name "
"reporting"
msgstr ""

#: ../../changelog/migration_10.rst:2197
msgid ""
"The :meth:`.Inspector.get_table_names` and "
":meth:`.Inspector.get_view_names` methods in the case of SQLite/Oracle "
"would also return the names of temporary tables and views, which is not "
"provided by any other dialect (in the case of MySQL at least it is not "
"even possible).  This logic has been moved out to two new methods "
":meth:`.Inspector.get_temp_table_names` and "
":meth:`.Inspector.get_temp_view_names`."
msgstr ""

#: ../../changelog/migration_10.rst:2204
msgid ""
"Note that reflection of a specific named temporary table or temporary "
"view, either by ``Table('name', autoload=True)`` or via methods like "
":meth:`.Inspector.get_columns` continues to function for most if not all "
"dialects.   For SQLite specifically, there is a bug fix for UNIQUE "
"constraint reflection from temp tables as well, which is :ticket:`3203`."
msgstr ""

#: ../../changelog/migration_10.rst:2210
msgid ":ticket:`3204`"
msgstr ""

#: ../../changelog/migration_10.rst:2213
msgid "Dialect Improvements and Changes - PostgreSQL"
msgstr ""

#: ../../changelog/migration_10.rst:2218
msgid "Overhaul of ENUM type create/drop rules"
msgstr ""

#: ../../changelog/migration_10.rst:2220
msgid ""
"The rules for PostgreSQL :class:`.postgresql.ENUM` have been made more "
"strict with regards to creating and dropping of the TYPE."
msgstr ""

#: ../../changelog/migration_10.rst:2223
msgid ""
"An :class:`.postgresql.ENUM` that is created **without** being explicitly"
" associated with a :class:`.MetaData` object will be created *and* "
"dropped corresponding to :meth:`.Table.create` and :meth:`.Table.drop`::"
msgstr ""

#: ../../changelog/migration_10.rst:2234
msgid ""
"This means that if a second table also has an enum named 'myenum', the "
"above DROP operation will now fail.    In order to accommodate the use "
"case of a common shared enumerated type, the behavior of a metadata-"
"associated enumeration has been enhanced."
msgstr ""

#: ../../changelog/migration_10.rst:2239
msgid ""
"An :class:`.postgresql.ENUM` that is created **with** being explicitly "
"associated with a :class:`.MetaData` object will *not* be created *or* "
"dropped corresponding to :meth:`.Table.create` and :meth:`.Table.drop`, "
"with the exception of :meth:`.Table.create` called with the "
"``checkfirst=True`` flag::"
msgstr ""

#: ../../changelog/migration_10.rst:2264
msgid ":ticket:`3319`"
msgstr ""

#: ../../changelog/migration_10.rst:2267
msgid "New PostgreSQL Table options"
msgstr ""

#: ../../changelog/migration_10.rst:2269
msgid ""
"Added support for PG table options TABLESPACE, ON COMMIT, WITH(OUT) OIDS,"
" and INHERITS, when rendering DDL via the :class:`.Table` construct."
msgstr ""

#: ../../changelog/migration_10.rst:2275
msgid ":ref:`postgresql_table_options`"
msgstr ""

#: ../../changelog/migration_10.rst:2277
msgid ":ticket:`2051`"
msgstr ""

#: ../../changelog/migration_10.rst:2282
msgid "New get_enums() method with PostgreSQL Dialect"
msgstr ""

#: ../../changelog/migration_10.rst:2284
msgid ""
"The :func:`.inspect` method returns a :class:`.PGInspector` object in the"
" case of PostgreSQL, which includes a new :meth:`.PGInspector.get_enums` "
"method that returns information on all available ``ENUM`` types::"
msgstr ""

#: ../../changelog/migration_10.rst:2296
msgid ":meth:`.PGInspector.get_enums`"
msgstr ""

#: ../../changelog/migration_10.rst:2301
msgid "PostgreSQL Dialect reflects Materialized Views, Foreign Tables"
msgstr ""

#: ../../changelog/migration_10.rst:2303
msgid "Changes are as follows:"
msgstr ""

#: ../../changelog/migration_10.rst:2305
msgid ""
"the :class:`Table` construct with ``autoload=True`` will now match a name"
" that exists in the database as a materialized view or foreign table."
msgstr ""

#: ../../changelog/migration_10.rst:2308
msgid ""
":meth:`.Inspector.get_view_names` will return plain and materialized view"
" names."
msgstr ""

#: ../../changelog/migration_10.rst:2311
msgid ""
":meth:`.Inspector.get_table_names` does **not** change for PostgreSQL, it"
" continues to return only the names of plain tables."
msgstr ""

#: ../../changelog/migration_10.rst:2314
msgid ""
"A new method :meth:`.PGInspector.get_foreign_table_names` is added which "
"will return the names of tables that are specifically marked as "
"\"foreign\" in the PostgreSQL schema tables."
msgstr ""

#: ../../changelog/migration_10.rst:2318
msgid ""
"The change to reflection involves adding ``'m'`` and ``'f'`` to the list "
"of qualifiers we use when querying ``pg_class.relkind``, but this change "
"is new in 1.0.0 to avoid any backwards-incompatible surprises for those "
"running 0.9 in production."
msgstr ""

#: ../../changelog/migration_10.rst:2323
msgid ":ticket:`2891`"
msgstr ""

#: ../../changelog/migration_10.rst:2328
msgid "PostgreSQL ``has_table()`` now works for temporary tables"
msgstr ""

#: ../../changelog/migration_10.rst:2330
msgid ""
"This is a simple fix such that \"has table\" for temporary tables now "
"works, so that code like the following may proceed::"
msgstr ""

#: ../../changelog/migration_10.rst:2350
msgid ""
"The very unlikely case that this behavior will cause a non-failing "
"application to behave differently, is because PostgreSQL allows a non-"
"temporary table to silently overwrite a temporary table.  So code like "
"the following will now act completely differently, no longer creating the"
" real table following the temporary table::"
msgstr ""

#: ../../changelog/migration_10.rst:2381
msgid ":ticket:`3264`"
msgstr ""

#: ../../changelog/migration_10.rst:2386
msgid "PostgreSQL FILTER keyword"
msgstr ""

#: ../../changelog/migration_10.rst:2388
msgid ""
"The SQL standard FILTER keyword for aggregate functions is now supported "
"by PostgreSQL as of 9.4.  SQLAlchemy allows this using "
":meth:`.FunctionElement.filter`::"
msgstr ""

#: ../../changelog/migration_10.rst:2396
msgid ":meth:`.FunctionElement.filter`"
msgstr ""

#: ../../changelog/migration_10.rst:2398
msgid ":class:`.FunctionFilter`"
msgstr ""

#: ../../changelog/migration_10.rst:2401
msgid "PG8000 dialect supports client side encoding"
msgstr ""

#: ../../changelog/migration_10.rst:2403
msgid ""
"The :paramref:`.create_engine.encoding` parameter is now honored by the "
"pg8000 dialect, using on connect handler which emits ``SET "
"CLIENT_ENCODING`` matching the selected encoding."
msgstr ""

#: ../../changelog/migration_10.rst:2408
msgid "PG8000 native JSONB support"
msgstr ""

#: ../../changelog/migration_10.rst:2410
msgid ""
"Support for PG8000 versions greater than 1.10.1 has been added, where "
"JSONB is supported natively."
msgstr ""

#: ../../changelog/migration_10.rst:2415
msgid "Support for psycopg2cffi Dialect on Pypy"
msgstr ""

#: ../../changelog/migration_10.rst:2417
msgid "Support for the pypy psycopg2cffi dialect is added."
msgstr ""

#: ../../changelog/migration_10.rst:2421
msgid ":mod:`sqlalchemy.dialects.postgresql.psycopg2cffi`"
msgstr ""

#: ../../changelog/migration_10.rst:2424
msgid "Dialect Improvements and Changes - MySQL"
msgstr ""

#: ../../changelog/migration_10.rst:2429
msgid "MySQL TIMESTAMP Type now renders NULL / NOT NULL in all cases"
msgstr ""

#: ../../changelog/migration_10.rst:2431
msgid ""
"The MySQL dialect has always worked around MySQL's implicit NOT NULL "
"default associated with TIMESTAMP columns by emitting NULL for such a "
"type, if the column is set up with ``nullable=True``.   However, MySQL "
"5.6.6 and above features a new flag `explicit_defaults_for_timestamp "
"<http://dev.mysql.com/doc/refman/ 5.6/en/server-system-variables.html "
"#sysvar_explicit_defaults_for_timestamp>`_ which repairs MySQL's non-"
"standard behavior to make it behave like any other type; to accommodate "
"this, SQLAlchemy now emits NULL/NOT NULL unconditionally for all "
"TIMESTAMP columns."
msgstr ""

#: ../../changelog/migration_10.rst:2444
msgid ":ref:`mysql_timestamp_null`"
msgstr ""

#: ../../changelog/migration_10.rst:2446
msgid ":ticket:`3155`"
msgstr ""

#: ../../changelog/migration_10.rst:2452
msgid ""
"MySQL SET Type Overhauled to support empty sets, unicode, blank value "
"handling"
msgstr ""

#: ../../changelog/migration_10.rst:2454
msgid ""
"The :class:`.mysql.SET` type historically not included a system of "
"handling blank sets and empty values separately; as different drivers had"
" different behaviors for treatment of empty strings and empty-string-set "
"representations, the SET type tried only to hedge between these "
"behaviors, opting to treat the empty set as ``set([''])`` as is still the"
" current behavior for the MySQL-Connector-Python DBAPI. Part of the "
"rationale here was that it was otherwise impossible to actually store a "
"blank string within a MySQL SET, as the driver gives us back strings with"
" no way to discern between ``set([''])`` and ``set()``.  It was left to "
"the user to determine if ``set([''])`` actually meant \"empty set\" or "
"not."
msgstr ""

#: ../../changelog/migration_10.rst:2465
msgid ""
"The new behavior moves the use case for the blank string, which is an "
"unusual case that isn't even documented in MySQL's documentation, into a "
"special case, and the default behavior of :class:`.mysql.SET` is now:"
msgstr ""

#: ../../changelog/migration_10.rst:2469
msgid ""
"to treat the empty string ``''`` as returned by MySQL-python into the "
"empty set ``set()``;"
msgstr ""

#: ../../changelog/migration_10.rst:2472
msgid ""
"to convert the single-blank value set ``set([''])`` returned by MySQL-"
"Connector-Python into the empty set ``set()``;"
msgstr ""

#: ../../changelog/migration_10.rst:2475
msgid ""
"To handle the case of a set type that actually wishes includes the blank "
"value ``''`` in its list of possible values, a new feature (required in "
"this use case) is implemented whereby the set value is persisted and "
"loaded as a bitwise integer value; the flag "
":paramref:`.mysql.SET.retrieve_as_bitwise` is added in order to enable "
"this."
msgstr ""

#: ../../changelog/migration_10.rst:2482
msgid ""
"Using the :paramref:`.mysql.SET.retrieve_as_bitwise` flag allows the set "
"to be persisted and retrieved with no ambiguity of values.   "
"Theoretically this flag can be turned on in all cases, as long as the "
"given list of values to the type matches the ordering exactly as declared"
" in the database; it only makes the SQL echo output a bit more unusual."
msgstr ""

#: ../../changelog/migration_10.rst:2488
msgid ""
"The default behavior of :class:`.mysql.SET` otherwise remains the same, "
"roundtripping values using strings.   The string-based behavior now "
"supports unicode fully including MySQL-python with use_unicode=0."
msgstr ""

#: ../../changelog/migration_10.rst:2492
msgid ":ticket:`3283`"
msgstr ""

#: ../../changelog/migration_10.rst:2496
msgid "MySQL internal \"no such table\" exceptions not passed to event handlers"
msgstr ""

#: ../../changelog/migration_10.rst:2498
msgid ""
"The MySQL dialect will now disable :meth:`.ConnectionEvents.handle_error`"
" events from firing for those statements which it uses internally to "
"detect if a table exists or not.   This is achieved using an execution "
"option ``skip_user_error_events`` that disables the handle error event "
"for the scope of that execution.   In this way, user code that rewrites "
"exceptions doesn't need to worry about the MySQL dialect or other "
"dialects that occasionally need to catch SQLAlchemy specific exceptions."
msgstr ""

#: ../../changelog/migration_10.rst:2509
msgid "Changed the default value of ``raise_on_warnings`` for MySQL-Connector"
msgstr ""

#: ../../changelog/migration_10.rst:2511
msgid ""
"Changed the default value of \"raise_on_warnings\" to False for MySQL-"
"Connector.  This was set at True for some reason.  The \"buffered\" flag "
"unfortunately must stay at True as MySQLconnector does not allow a cursor"
" to be closed unless all results are fully fetched."
msgstr ""

#: ../../changelog/migration_10.rst:2516
msgid ":ticket:`2515`"
msgstr ""

#: ../../changelog/migration_10.rst:2521
msgid "MySQL boolean symbols \"true\", \"false\" work again"
msgstr ""

#: ../../changelog/migration_10.rst:2523
msgid ""
"0.9's overhaul of the IS/IS NOT operators as well as boolean types in "
":ticket:`2682` disallowed the MySQL dialect from making use of the "
"\"true\" and \"false\" symbols in the context of \"IS\" / \"IS NOT\".  "
"Apparently, even though MySQL has no \"boolean\" type, it supports IS / "
"IS NOT when the special \"true\" and \"false\" symbols are used, even "
"though these are otherwise synonymous with \"1\" and \"0\" (and IS/IS NOT"
" don't work with the numerics)."
msgstr ""

#: ../../changelog/migration_10.rst:2530
msgid ""
"So the change here is that the MySQL dialect remains \"non native "
"boolean\", but the :func:`.true` and :func:`.false` symbols again produce"
" the keywords \"true\" and \"false\", so that an expression like "
"``column.is_(true())`` again works on MySQL."
msgstr ""

#: ../../changelog/migration_10.rst:2535
msgid ":ticket:`3186`"
msgstr ""

#: ../../changelog/migration_10.rst:2540
msgid ""
"The match() operator now returns an agnostic MatchType compatible with "
"MySQL's floating point return value"
msgstr ""

#: ../../changelog/migration_10.rst:2542
msgid ""
"The return type of a :meth:`.ColumnOperators.match` expression is now a "
"new type called :class:`.MatchType`.  This is a subclass of "
":class:`.Boolean`, that can be intercepted by the dialect in order to "
"produce a different result type at SQL execution time."
msgstr ""

#: ../../changelog/migration_10.rst:2547
msgid ""
"Code like the following will now function correctly and return floating "
"points on MySQL::"
msgstr ""

#: ../../changelog/migration_10.rst:2566
msgid ":ticket:`3263`"
msgstr ""

#: ../../changelog/migration_10.rst:2571
msgid "Drizzle Dialect is now an External Dialect"
msgstr ""

#: ../../changelog/migration_10.rst:2573
msgid ""
"The dialect for `Drizzle <http://www.drizzle.org/>`_ is now an external "
"dialect, available at https://bitbucket.org/zzzeek/sqlalchemy-drizzle. "
"This dialect was added to SQLAlchemy right before SQLAlchemy was able to "
"accommodate third party dialects well; going forward, all databases that "
"aren't within the \"ubiquitous use\" category are third party dialects. "
"The dialect's implementation hasn't changed and is still based on the "
"MySQL + MySQLdb dialects within SQLAlchemy.  The dialect is as of yet "
"unreleased and in \"attic\" status; however it passes the majority of "
"tests and is generally in decent working order, if someone wants to pick "
"up on polishing it."
msgstr ""

#: ../../changelog/migration_10.rst:2585
msgid "Dialect Improvements and Changes - SQLite"
msgstr ""

#: ../../changelog/migration_10.rst:2588
msgid ""
"SQLite named and unnamed UNIQUE and FOREIGN KEY constraints will inspect "
"and reflect"
msgstr ""

#: ../../changelog/migration_10.rst:2590
msgid ""
"UNIQUE and FOREIGN KEY constraints are now fully reflected on SQLite both"
" with and without names.  Previously, foreign key names were ignored and "
"unnamed unique constraints were skipped.   In particular this will help "
"with Alembic's new SQLite migration features."
msgstr ""

#: ../../changelog/migration_10.rst:2595
msgid ""
"To achieve this, for both foreign keys and unique constraints, the result"
" of PRAGMA foreign_keys, index_list, and index_info is combined with "
"regular expression parsing of the CREATE TABLE statement overall to form "
"a complete picture of the names of constraints, as well as "
"differentiating UNIQUE constraints that were created as UNIQUE vs. "
"unnamed INDEXes."
msgstr ""

#: ../../changelog/migration_10.rst:2601
msgid ":ticket:`3244`"
msgstr ""

#: ../../changelog/migration_10.rst:2603
msgid ":ticket:`3261`"
msgstr ""

#: ../../changelog/migration_10.rst:2606
msgid "Dialect Improvements and Changes - SQL Server"
msgstr ""

#: ../../changelog/migration_10.rst:2611
msgid "PyODBC driver name is required with hostname-based SQL Server connections"
msgstr ""

#: ../../changelog/migration_10.rst:2613
msgid ""
"Connecting to SQL Server with PyODBC using a DSN-less connection, e.g. "
"with an explicit hostname, now requires a driver name - SQLAlchemy will "
"no longer attempt to guess a default::"
msgstr ""

#: ../../changelog/migration_10.rst:2619
msgid ""
"SQLAlchemy's previously hardcoded default of \"SQL Server\" is obsolete "
"on Windows, and SQLAlchemy cannot be tasked with guessing the best driver"
" based on operation system/driver detection.   Using a DSN is always "
"preferred when using ODBC to avoid this issue entirely."
msgstr ""

#: ../../changelog/migration_10.rst:2624
msgid ":ticket:`3182`"
msgstr ""

#: ../../changelog/migration_10.rst:2627
msgid ""
"SQL Server 2012 large text / binary types render as VARCHAR, NVARCHAR, "
"VARBINARY"
msgstr ""

#: ../../changelog/migration_10.rst:2629
msgid ""
"The rendering of the :class:`.Text`, :class:`.UnicodeText`, and "
":class:`.LargeBinary` types has been changed for SQL Server 2012 and "
"greater, with options to control the behavior completely, based on "
"deprecation guidelines from Microsoft.  See "
":ref:`mssql_large_type_deprecation` for details."
msgstr ""

#: ../../changelog/migration_10.rst:2635
msgid "Dialect Improvements and Changes - Oracle"
msgstr ""

#: ../../changelog/migration_10.rst:2640
msgid "Improved support for CTEs in Oracle"
msgstr ""

#: ../../changelog/migration_10.rst:2642
msgid ""
"CTE support has been fixed up for Oracle, and there is also a new feature"
" :meth:`.CTE.with_suffixes` that can assist with Oracle's special "
"directives::"
msgstr ""

#: ../../changelog/migration_10.rst:2653
msgid ":ticket:`3220`"
msgstr ""

#: ../../changelog/migration_10.rst:2656
msgid "New Oracle Keywords for DDL"
msgstr ""

#: ../../changelog/migration_10.rst:2658
msgid "Keywords such as COMPRESS, ON COMMIT, BITMAP:"
msgstr ""

#: ../../changelog/migration_10.rst:2660
msgid ":ref:`oracle_table_options`"
msgstr ""

#: ../../changelog/migration_10.rst:2662
msgid ":ref:`oracle_index_options`"
msgstr ""

