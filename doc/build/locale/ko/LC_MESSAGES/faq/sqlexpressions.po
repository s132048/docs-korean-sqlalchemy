# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: SQLAlchemy 1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-02-21 14:32+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../faq/sqlexpressions.rst:2
msgid "SQL Expressions"
msgstr ""

#: ../../faq/sqlexpressions.rst:12
msgid ""
"How do I render SQL expressions as strings, possibly with bound "
"parameters inlined?"
msgstr ""

#: ../../faq/sqlexpressions.rst:14
msgid ""
"The \"stringification\" of a SQLAlchemy statement or Query in the vast "
"majority of cases is as simple as::"
msgstr ""

#: ../../faq/sqlexpressions.rst:19
msgid ""
"this applies both to an ORM :class:`~.orm.query.Query` as well as any "
":func:`.select` or other statement.   Additionally, to get the statement "
"as compiled to a specific dialect or engine, if the statement itself is "
"not already bound to one you can pass this in to "
":meth:`.ClauseElement.compile`::"
msgstr ""

#: ../../faq/sqlexpressions.rst:26
msgid "or without an :class:`.Engine`::"
msgstr ""

#: ../../faq/sqlexpressions.rst:31
msgid ""
"When given an ORM :class:`~.orm.query.Query` object, in order to get at "
"the :meth:`.ClauseElement.compile` method we only need access the "
":attr:`~.orm.query.Query.statement` accessor first::"
msgstr ""

#: ../../faq/sqlexpressions.rst:39
msgid ""
"The above forms will render the SQL statement as it is passed to the "
"Python :term:`DBAPI`, which includes that bound parameters are not "
"rendered inline. SQLAlchemy normally does not stringify bound parameters,"
" as this is handled appropriately by the Python DBAPI, not to mention "
"bypassing bound parameters is probably the most widely exploited security"
" hole in modern web applications.   SQLAlchemy has limited ability to do "
"this stringification in certain circumstances such as that of emitting "
"DDL. In order to access this functionality one can use the "
"``literal_binds`` flag, passed to ``compile_kwargs``::"
msgstr ""

#: ../../faq/sqlexpressions.rst:57
msgid ""
"the above approach has the caveats that it is only supported for basic "
"types, such as ints and strings, and furthermore if a :func:`.bindparam` "
"without a pre-set value is used directly, it won't be able to stringify "
"that either."
msgstr ""

#: ../../faq/sqlexpressions.rst:62
msgid ""
"To support inline literal rendering for types not supported, implement a "
":class:`.TypeDecorator` for the target type which includes a "
":meth:`.TypeDecorator.process_literal_param` method::"
msgstr ""

#: ../../faq/sqlexpressions.rst:84
msgid "producing output like::"
msgstr ""

#: ../../faq/sqlexpressions.rst:94
msgid ""
"I'm using op() to generate a custom operator and my parenthesis are not "
"coming out correctly"
msgstr ""

#: ../../faq/sqlexpressions.rst:96
msgid ""
"The :meth:`.Operators.op` method allows one to create a custom database "
"operator otherwise not known by SQLAlchemy::"
msgstr ""

#: ../../faq/sqlexpressions.rst:102
msgid ""
"However, when using it on the right side of a compound expression, it "
"doesn't generate parenthesis as we expect::"
msgstr ""

#: ../../faq/sqlexpressions.rst:108
msgid "Where above, we probably want ``(q1 + q2) -> p``."
msgstr ""

#: ../../faq/sqlexpressions.rst:110
msgid ""
"The solution to this case is to set the precedence of the operator, using"
" the :paramref:`.Operators.op.precedence` parameter, to a high number, "
"where 100 is the maximum value, and the highest number used by any "
"SQLAlchemy operator is currently 15::"
msgstr ""

#: ../../faq/sqlexpressions.rst:118
msgid ""
"We can also usually force parenthesization around a binary expression "
"(e.g. an expression that has left/right operands and an operator) using "
"the :meth:`.ColumnElement.self_group` method::"
msgstr ""

#: ../../faq/sqlexpressions.rst:126
msgid "Why are the parentheses rules like this?"
msgstr ""

#: ../../faq/sqlexpressions.rst:128
msgid ""
"A lot of databases barf when there are excessive parenthesis or when "
"parenthesis are in unusual places they doesn't expect, so SQLAlchemy does"
" not generate parenthesis based on groupings, it uses operator precedence"
" and if the operator is known to be associative, so that parenthesis are "
"generated minimally. Otherwise, an expression like::"
msgstr ""

#: ../../faq/sqlexpressions.rst:136 ../../faq/sqlexpressions.rst:146
msgid "would produce::"
msgstr ""

#: ../../faq/sqlexpressions.rst:140
msgid ""
"which is fine but would probably annoy people (and be reported as a bug)."
" In other cases, it leads to things that are more likely to confuse "
"databases or at the very least readability, such as::"
msgstr ""

#: ../../faq/sqlexpressions.rst:150
msgid ""
"There are also some edge cases where we get things like ``\"(x) = 7\"`` "
"and databases really don't like that either.  So parenthesization doesn't"
" naively parenthesize, it uses operator precedence and associativity to "
"determine groupings."
msgstr ""

#: ../../faq/sqlexpressions.rst:155
msgid "For :meth:`.Operators.op`, the value of precedence defaults to zero."
msgstr ""

#: ../../faq/sqlexpressions.rst:157
msgid ""
"What if we defaulted the value of :paramref:`.Operators.op.precedence` to"
" 100, e.g. the highest?  Then this expression makes more parenthesis, but"
" is otherwise OK, that is, these two are equivalent::"
msgstr ""

#: ../../faq/sqlexpressions.rst:166
msgid "but these two are not::"
msgstr ""

#: ../../faq/sqlexpressions.rst:173
msgid ""
"For now, it's not clear that as long as we are doing parenthesization "
"based on operator precedence and associativity, if there is really a way "
"to parenthesize automatically for a generic operator with no precedence "
"given that is going to work in all cases, because sometimes you want a "
"custom op to have a lower precedence than the other operators and "
"sometimes you want it to be higher."
msgstr ""

#: ../../faq/sqlexpressions.rst:179
msgid ""
"It is possible that maybe if the \"binary\" expression above forced the "
"use of the ``self_group()`` method when ``op()`` is called, making the "
"assumption that a compound expression on the left side can always be "
"parenthesized harmlessly. Perhaps this change can be made at some point, "
"however for the time being keeping the parenthesization rules more "
"internally consistent seems to be the safer approach."
msgstr ""

